""" 
 * Copyright(c) Microsoft Corporation.All rights reserved. 
 * Licensed under the MIT License. 
 * See the LICENSE file in the project root for full license information. 
"""

"""
 * This file is automatically generated from the TPM 2.0 rev. 1.46 specification documents.
 * Do not edit it directly.
"""


from .TpmMarshaler import *


# Selector type for TPMU_NAME [TSS]
class NameUnionTagValues(TpmEnum): # byte
    TAG_TPMU_NAME_TPMT_HA = 0
    
    TAG_TPMU_NAME_TPM_HANDLE = 1
    
# enum NameUnionTagValues

# Table 2 is the list of algorithms to which the TCG has assigned an algorithm identifier along with its numeric identifier.
class TPM_ALG_ID(TpmEnum): # UINT16
    # should not occur
    ERROR = 0x0000
    
    # an object type that contains an RSA key
    FIRST = 0x0001
    
    # an object type that contains an RSA key
    RSA = 0x0001
    
    TDES = 0x0003
    
    # hash algorithm producing a 160-bit digest
    SHA = 0x0004
    
    # redefinition for documentation consistency
    SHA1 = 0x0004
    
    # Hash Message Authentication Code (HMAC) algorithm
    HMAC = 0x0005
    
    # block cipher with various key sizes
    AES = 0x0006
    
    # hash-based mask-generation function
    MGF1 = 0x0007
    
    # an object type that may use XOR for encryption or an HMAC for signing and may also refer to a data object that is neither signing nor encrypting
    KEYEDHASH = 0x0008
    
    # hash-based stream cipher
    XOR = 0x000A
    
    # hash algorithm producing a 256-bit digest
    SHA256 = 0x000B
    
    # hash algorithm producing a 384-bit digest
    SHA384 = 0x000C
    
    # hash algorithm producing a 512-bit digest
    SHA512 = 0x000D
    
    # Indication that no algorithm is selected
    NULL = 0x0010
    
    # hash algorithm producing a 256-bit digest
    SM3_256 = 0x0012
    
    # symmetric block cipher with 128 bit key
    SM4 = 0x0013
    
    # a signature algorithm defined in section 8.2 (RSASSA-PKCS1-v1_5)
    RSASSA = 0x0014
    
    # a padding algorithm defined in section 7.2 (RSAES-PKCS1-v1_5)
    RSAES = 0x0015
    
    # a signature algorithm defined in section 8.1 (RSASSA-PSS)
    RSAPSS = 0x0016
    
    # a padding algorithm defined in Section 7.1 (RSAES_OAEP)
    OAEP = 0x0017
    
    # signature algorithm using elliptic curve cryptography (ECC)
    ECDSA = 0x0018
    
    # secret sharing using ECC Based on context, this can be either One-Pass Diffie-Hellman, C(1, 1, ECC CDH) defined in 6.2.2.2 or Full Unified Model C(2, 2, ECC CDH) defined in 6.1.1.2
    ECDH = 0x0019
    
    # elliptic-curve based, anonymous signing scheme
    ECDAA = 0x001A
    
    # depending on context, either an elliptic-curve based, signature algorithm or a key exchange protocol NOTE Type listed as signing but, other uses are allowed according to context.
    SM2 = 0x001B
    
    # elliptic-curve based Schnorr signature
    ECSCHNORR = 0x001C
    
    # two-phase elliptic-curve key exchange C(2, 2, ECC MQV) Section 6.1.1.4
    ECMQV = 0x001D
    
    # concatenation key derivation function (approved alternative 1) Section 5.8.1
    KDF1_SP800_56A = 0x0020
    
    # key derivation function KDF2 Section 13.2
    KDF2 = 0x0021
    
    # a key derivation method SP800-108, Section 5.1 KDF in Counter Mode
    KDF1_SP800_108 = 0x0022
    
    # prime field ECC
    ECC = 0x0023
    
    # the object type for a symmetric block cipher key
    SYMCIPHER = 0x0025
    
    # symmetric block cipher with various key sizes
    CAMELLIA = 0x0026
    
    CMAC = 0x003F
    
    # Counter mode if implemented, all symmetric block ciphers (S type) implemented shall be capable of using this mode.
    CTR = 0x0040
    
    # Output Feedback mode if implemented, all symmetric block ciphers (S type) implemented shall be capable of using this mode.
    OFB = 0x0041
    
    # Cipher Block Chaining mode if implemented, all symmetric block ciphers (S type) implemented shall be capable of using this mode.
    CBC = 0x0042
    
    # Cipher Feedback mode if implemented, all symmetric block ciphers (S type) implemented shall be capable of using this mode.
    CFB = 0x0043
    
    # Electronic Codebook mode if implemented, all implemented symmetric block ciphers (S type) shall be capable of using this mode. NOTE This mode is not recommended for uses unless the key is frequently rotated such as in video codecs
    ECB = 0x0044
    
    LAST = 0x0044
    
    # Phony alg ID to be used for the first union member with no selector
    ANY = 0x7FFF
    
    # Phony alg ID to be used for the second union member with no selector
    ANY2 = 0x7FFE
    
# enum TPM_ALG_ID

# Table 3 is the list of identifiers for TCG-registered curve ID values for elliptic curve cryptography.
class TPM_ECC_CURVE(TpmEnum): # UINT16
    NONE = 0x0000
    
    NIST_P192 = 0x0001
    
    NIST_P224 = 0x0002
    
    NIST_P256 = 0x0003
    
    NIST_P384 = 0x0004
    
    NIST_P521 = 0x0005
    
    # curve to support ECDAA
    BN_P256 = 0x0010
    
    # curve to support ECDAA
    BN_P638 = 0x0011
    
    SM2_P256 = 0x0020
    
# enum TPM_ECC_CURVE

# Table 12 Defines for SHA1 Hash Values
class SHA1(TpmEnum): # UINT32
    # size of digest in octets
    DIGEST_SIZE = 20
    
    # size of hash block in octets
    BLOCK_SIZE = 64
    
    # size of the DER in octets
    DER_SIZE = 15
    
# enum SHA1

# Table 13 Defines for SHA256 Hash Values
class SHA256(TpmEnum): # UINT32
    # size of digest
    DIGEST_SIZE = 32
    
    # size of hash block
    BLOCK_SIZE = 64
    
    # size of the DER in octets
    DER_SIZE = 19
    
# enum SHA256

# Table 14 Defines for SHA384 Hash Values
class SHA384(TpmEnum): # UINT32
    # size of digest in octets
    DIGEST_SIZE = 48
    
    # size of hash block in octets
    BLOCK_SIZE = 128
    
    # size of the DER in octets
    DER_SIZE = 19
    
# enum SHA384

# Table 15 Defines for SHA512 Hash Values
class SHA512(TpmEnum): # UINT32
    # size of digest in octets
    DIGEST_SIZE = 64
    
    # size of hash block in octets
    BLOCK_SIZE = 128
    
    # size of the DER in octets
    DER_SIZE = 19
    
# enum SHA512

# Table 16 Defines for SM3_256 Hash Values
class SM3_256(TpmEnum): # UINT32
    # size of digest in octets
    DIGEST_SIZE = 32
    
    # size of hash block in octets
    BLOCK_SIZE = 64
    
    # size of the DER in octets
    DER_SIZE = 18
    
# enum SM3_256

# Architecturally defined constants
class ImplementationConstants(TpmEnum): # uint
    OSSL = 1
    
    LTC = 2
    
    MSBN = 3
    
    SYMCRYPT = 4
    
    HASH_COUNT = 3
    
    MAX_SYM_KEY_BITS = 256
    
    MAX_SYM_KEY_BYTES = ((MAX_SYM_KEY_BITS + 7) / 8)
    
    MAX_SYM_BLOCK_SIZE = 16
    
    MAX_CAP_CC = 0x00000196
    
    MAX_RSA_KEY_BYTES = 256
    
    MAX_AES_KEY_BYTES = 32
    
    MAX_ECC_KEY_BYTES = 48
    
    LABEL_MAX_BUFFER = 32
    
    MAX_CAP_DATA = (1024-4-4)
    
    MAX_CAP_ALGS = (MAX_CAP_DATA / 6)
    
    MAX_CAP_HANDLES = (MAX_CAP_DATA / 4)
    
    MAX_TPM_PROPERTIES = (MAX_CAP_DATA / 8)
    
    MAX_PCR_PROPERTIES = (MAX_CAP_DATA / 8)
    
    MAX_ECC_CURVES = (MAX_CAP_DATA / 2)
    
    MAX_TAGGED_POLICIES = (MAX_CAP_DATA / 54)
    
    MAX_AC_CAPABILITIES = (MAX_CAP_DATA / 8)
    
# enum ImplementationConstants

# Table 4 Defines for Logic Values
class Logic(TpmEnum): # byte
    TRUE = 1
    
    FALSE = 0
    
    YES = 1
    
    NO = 0
    
    SET = 1
    
    CLEAR = 0
    
# enum Logic

# These values are readable with TPM2_GetCapability() (see 6.13 for the format).
class TPM_SPEC(TpmEnum): # UINT32
    # ASCII 2.0 with null terminator
    FAMILY = 0x322E3000
    
    # the level number for the specification
    LEVEL = 0
    
    # the version number of the spec (001.46 * 100)
    VERSION = 146
    
    # the year of the version
    YEAR = 2017
    
    # the day of the year (June 15, 2017)
    DAY_OF_YEAR = 167
    
# enum TPM_SPEC

# This constant value differentiates TPM-generated structures from non-TPM structures.
class TPM_GENERATED(TpmEnum): # UINT32
    # 0xFF TCG (FF 54 43 4716)
    VALUE = 0xff544347
    
# enum TPM_GENERATED

# Table 12 lists the command codes and their attributes. The only normative column in this table is the column indicating the command code assigned to a specific command (the "Command Code" column). For all other columns, the command and response tables in TPM 2.0 Part 3 are definitive.
class TPM_CC(TpmEnum): # UINT32
    # Compile variable. May decrease based on implementation.
    FIRST = 0x0000011F
    
    NV_UndefineSpaceSpecial = 0x0000011F
    
    EvictControl = 0x00000120
    
    HierarchyControl = 0x00000121
    
    NV_UndefineSpace = 0x00000122
    
    ChangeEPS = 0x00000124
    
    ChangePPS = 0x00000125
    
    Clear = 0x00000126
    
    ClearControl = 0x00000127
    
    ClockSet = 0x00000128
    
    HierarchyChangeAuth = 0x00000129
    
    NV_DefineSpace = 0x0000012A
    
    PCR_Allocate = 0x0000012B
    
    PCR_SetAuthPolicy = 0x0000012C
    
    PP_Commands = 0x0000012D
    
    SetPrimaryPolicy = 0x0000012E
    
    FieldUpgradeStart = 0x0000012F
    
    ClockRateAdjust = 0x00000130
    
    CreatePrimary = 0x00000131
    
    NV_GlobalWriteLock = 0x00000132
    
    GetCommandAuditDigest = 0x00000133
    
    NV_Increment = 0x00000134
    
    NV_SetBits = 0x00000135
    
    NV_Extend = 0x00000136
    
    NV_Write = 0x00000137
    
    NV_WriteLock = 0x00000138
    
    DictionaryAttackLockReset = 0x00000139
    
    DictionaryAttackParameters = 0x0000013A
    
    NV_ChangeAuth = 0x0000013B
    
    # PCR
    PCR_Event = 0x0000013C
    
    # PCR
    PCR_Reset = 0x0000013D
    
    SequenceComplete = 0x0000013E
    
    SetAlgorithmSet = 0x0000013F
    
    SetCommandCodeAuditStatus = 0x00000140
    
    FieldUpgradeData = 0x00000141
    
    IncrementalSelfTest = 0x00000142
    
    SelfTest = 0x00000143
    
    Startup = 0x00000144
    
    Shutdown = 0x00000145
    
    StirRandom = 0x00000146
    
    ActivateCredential = 0x00000147
    
    Certify = 0x00000148
    
    # Policy
    PolicyNV = 0x00000149
    
    CertifyCreation = 0x0000014A
    
    Duplicate = 0x0000014B
    
    GetTime = 0x0000014C
    
    GetSessionAuditDigest = 0x0000014D
    
    NV_Read = 0x0000014E
    
    NV_ReadLock = 0x0000014F
    
    ObjectChangeAuth = 0x00000150
    
    # Policy
    PolicySecret = 0x00000151
    
    Rewrap = 0x00000152
    
    Create = 0x00000153
    
    ECDH_ZGen = 0x00000154
    
    # See NOTE 1
    HMAC = 0x00000155
    
    # See NOTE 1
    MAC = 0x00000155
    
    Import = 0x00000156
    
    Load = 0x00000157
    
    Quote = 0x00000158
    
    RSA_Decrypt = 0x00000159
    
    # See NOTE 1
    HMAC_Start = 0x0000015B
    
    # See NOTE 1
    MAC_Start = 0x0000015B
    
    SequenceUpdate = 0x0000015C
    
    Sign = 0x0000015D
    
    Unseal = 0x0000015E
    
    # Policy
    PolicySigned = 0x00000160
    
    # Context
    ContextLoad = 0x00000161
    
    # Context
    ContextSave = 0x00000162
    
    ECDH_KeyGen = 0x00000163
    
    EncryptDecrypt = 0x00000164
    
    # Context
    FlushContext = 0x00000165
    
    LoadExternal = 0x00000167
    
    MakeCredential = 0x00000168
    
    # NV
    NV_ReadPublic = 0x00000169
    
    # Policy
    PolicyAuthorize = 0x0000016A
    
    # Policy
    PolicyAuthValue = 0x0000016B
    
    # Policy
    PolicyCommandCode = 0x0000016C
    
    # Policy
    PolicyCounterTimer = 0x0000016D
    
    # Policy
    PolicyCpHash = 0x0000016E
    
    # Policy
    PolicyLocality = 0x0000016F
    
    # Policy
    PolicyNameHash = 0x00000170
    
    # Policy
    PolicyOR = 0x00000171
    
    # Policy
    PolicyTicket = 0x00000172
    
    ReadPublic = 0x00000173
    
    RSA_Encrypt = 0x00000174
    
    StartAuthSession = 0x00000176
    
    VerifySignature = 0x00000177
    
    ECC_Parameters = 0x00000178
    
    FirmwareRead = 0x00000179
    
    GetCapability = 0x0000017A
    
    GetRandom = 0x0000017B
    
    GetTestResult = 0x0000017C
    
    Hash = 0x0000017D
    
    # PCR
    PCR_Read = 0x0000017E
    
    # Policy
    PolicyPCR = 0x0000017F
    
    PolicyRestart = 0x00000180
    
    ReadClock = 0x00000181
    
    PCR_Extend = 0x00000182
    
    PCR_SetAuthValue = 0x00000183
    
    NV_Certify = 0x00000184
    
    EventSequenceComplete = 0x00000185
    
    HashSequenceStart = 0x00000186
    
    # Policy
    PolicyPhysicalPresence = 0x00000187
    
    # Policy
    PolicyDuplicationSelect = 0x00000188
    
    # Policy
    PolicyGetDigest = 0x00000189
    
    TestParms = 0x0000018A
    
    Commit = 0x0000018B
    
    # Policy
    PolicyPassword = 0x0000018C
    
    ZGen_2Phase = 0x0000018D
    
    EC_Ephemeral = 0x0000018E
    
    # Policy
    PolicyNvWritten = 0x0000018F
    
    # Policy
    PolicyTemplate = 0x00000190
    
    CreateLoaded = 0x00000191
    
    # Policy
    PolicyAuthorizeNV = 0x00000192
    
    EncryptDecrypt2 = 0x00000193
    
    AC_GetCapability = 0x00000194
    
    AC_Send = 0x00000195
    
    # Policy
    Policy_AC_SendSelect = 0x00000196
    
    # Compile variable. May increase based on implementation.
    LAST = 0x00000196
    
    CC_VEND = 0x20000000
    
    # Used for testing of command dispatch
    Vendor_TCG_Test = CC_VEND+0x0000
    
# enum TPM_CC

# In general, response codes defined in TPM 2.0 Part 2 will be unmarshaling errors and will have the F (format) bit SET. Codes that are unique to TPM 2.0 Part 3 will have the F bit CLEAR but the V (version) attribute will be SET to indicate that it is a TPM 2.0 response code. See Response Code Details in TPM 2.0 Part 1.
class TPM_RC(TpmEnum): # UINT32
    SUCCESS = 0x000
    
    # defined for compatibility with TPM 1.2
    BAD_TAG = 0x01E
    
    # set for all format 0 response codes
    RC_VER1 = 0x100
    
    # TPM not initialized by TPM2_Startup or already initialized
    INITIALIZE = RC_VER1 + 0x000
    
    # commands not being accepted because of a TPM failure NOTE This may be returned by TPM2_GetTestResult() as the testResult parameter.
    FAILURE = RC_VER1 + 0x001
    
    # improper use of a sequence handle
    SEQUENCE = RC_VER1 + 0x003
    
    # not currently used
    PRIVATE = RC_VER1 + 0x00B
    
    # not currently used
    HMAC = RC_VER1 + 0x019
    
    # the command is disabled
    DISABLED = RC_VER1 + 0x020
    
    # command failed because audit sequence required exclusivity
    EXCLUSIVE = RC_VER1 + 0x021
    
    # authorization handle is not correct for command
    AUTH_TYPE = RC_VER1 + 0x024
    
    # command requires an authorization session for handle and it is not present.
    AUTH_MISSING = RC_VER1 + 0x025
    
    # policy failure in math operation or an invalid authPolicy value
    POLICY = RC_VER1 + 0x026
    
    # PCR check fail
    PCR = RC_VER1 + 0x027
    
    # PCR have changed since checked.
    PCR_CHANGED = RC_VER1 + 0x028
    
    # for all commands other than TPM2_FieldUpgradeData(), this code indicates that the TPM is in field upgrade mode; for TPM2_FieldUpgradeData(), this code indicates that the TPM is not in field upgrade mode
    UPGRADE = RC_VER1 + 0x02D
    
    # context ID counter is at maximum.
    TOO_MANY_CONTEXTS = RC_VER1 + 0x02E
    
    # authValue or authPolicy is not available for selected entity.
    AUTH_UNAVAILABLE = RC_VER1 + 0x02F
    
    # a _TPM_Init and Startup(CLEAR) is required before the TPM can resume operation.
    REBOOT = RC_VER1 + 0x030
    
    # the protection algorithms (hash and symmetric) are not reasonably balanced. The digest size of the hash must be larger than the key size of the symmetric algorithm.
    UNBALANCED = RC_VER1 + 0x031
    
    # command commandSize value is inconsistent with contents of the command buffer; either the size is not the same as the octets loaded by the hardware interface layer or the value is not large enough to hold a command header
    COMMAND_SIZE = RC_VER1 + 0x042
    
    # command code not supported
    COMMAND_CODE = RC_VER1 + 0x043
    
    # the value of authorizationSize is out of range or the number of octets in the Authorization Area is greater than required
    AUTHSIZE = RC_VER1 + 0x044
    
    # use of an authorization session with a context command or another command that cannot have an authorization session.
    AUTH_CONTEXT = RC_VER1 + 0x045
    
    # NV offset+size is out of range.
    NV_RANGE = RC_VER1 + 0x046
    
    # Requested allocation size is larger than allowed.
    NV_SIZE = RC_VER1 + 0x047
    
    # NV access locked.
    NV_LOCKED = RC_VER1 + 0x048
    
    # NV access authorization fails in command actions (this failure does not affect lockout.action)
    NV_AUTHORIZATION = RC_VER1 + 0x049
    
    # an NV Index is used before being initialized or the state saved by TPM2_Shutdown(STATE) could not be restored
    NV_UNINITIALIZED = RC_VER1 + 0x04A
    
    # insufficient space for NV allocation
    NV_SPACE = RC_VER1 + 0x04B
    
    # NV Index or persistent object already defined
    NV_DEFINED = RC_VER1 + 0x04C
    
    # context in TPM2_ContextLoad() is not valid
    BAD_CONTEXT = RC_VER1 + 0x050
    
    # cpHash value already set or not correct for use
    CPHASH = RC_VER1 + 0x051
    
    # handle for parent is not a valid parent
    PARENT = RC_VER1 + 0x052
    
    # some function needs testing.
    NEEDS_TEST = RC_VER1 + 0x053
    
    # returned when an internal function cannot process a request due to an unspecified problem. This code is usually related to invalid parameters that are not properly filtered by the input unmarshaling code.
    NO_RESULT = RC_VER1 + 0x054
    
    # the sensitive area did not unmarshal correctly after decryption this code is used in lieu of the other unmarshaling errors so that an attacker cannot determine where the unmarshaling error occurred
    SENSITIVE = RC_VER1 + 0x055
    
    # largest version 1 code that is not a warning
    RC_MAX_FM0 = RC_VER1 + 0x07F
    
    # This bit is SET in all format 1 response codes The codes in this group may have a value added to them to indicate the handle, session, or parameter to which they apply.
    RC_FMT1 = 0x080
    
    # asymmetric algorithm not supported or not correct
    ASYMMETRIC = RC_FMT1 + 0x001
    
    # inconsistent attributes
    ATTRIBUTES = RC_FMT1 + 0x002
    
    # hash algorithm not supported or not appropriate
    HASH = RC_FMT1 + 0x003
    
    # value is out of range or is not correct for the context
    VALUE = RC_FMT1 + 0x004
    
    # hierarchy is not enabled or is not correct for the use
    HIERARCHY = RC_FMT1 + 0x005
    
    # key size is not supported
    KEY_SIZE = RC_FMT1 + 0x007
    
    # mask generation function not supported
    MGF = RC_FMT1 + 0x008
    
    # mode of operation not supported
    MODE = RC_FMT1 + 0x009
    
    # the type of the value is not appropriate for the use
    TYPE = RC_FMT1 + 0x00A
    
    # the handle is not correct for the use
    HANDLE = RC_FMT1 + 0x00B
    
    # unsupported key derivation function or function not appropriate for use
    KDF = RC_FMT1 + 0x00C
    
    # value was out of allowed range.
    RANGE = RC_FMT1 + 0x00D
    
    # the authorization HMAC check failed and DA counter incremented
    AUTH_FAIL = RC_FMT1 + 0x00E
    
    # invalid nonce size or nonce value mismatch
    NONCE = RC_FMT1 + 0x00F
    
    # authorization requires assertion of PP
    PP = RC_FMT1 + 0x010
    
    # unsupported or incompatible scheme
    SCHEME = RC_FMT1 + 0x012
    
    # structure is the wrong size
    SIZE = RC_FMT1 + 0x015
    
    # unsupported symmetric algorithm or key size, or not appropriate for instance
    SYMMETRIC = RC_FMT1 + 0x016
    
    # incorrect structure tag
    TAG = RC_FMT1 + 0x017
    
    # union selector is incorrect
    SELECTOR = RC_FMT1 + 0x018
    
    # the TPM was unable to unmarshal a value because there were not enough octets in the input buffer
    INSUFFICIENT = RC_FMT1 + 0x01A
    
    # the signature is not valid
    SIGNATURE = RC_FMT1 + 0x01B
    
    # key fields are not compatible with the selected use
    KEY = RC_FMT1 + 0x01C
    
    # a policy check failed
    POLICY_FAIL = RC_FMT1 + 0x01D
    
    # integrity check failed
    INTEGRITY = RC_FMT1 + 0x01F
    
    # invalid ticket
    TICKET = RC_FMT1 + 0x020
    
    # authorization failure without DA implications
    BAD_AUTH = RC_FMT1 + 0x022
    
    # the policy has expired
    EXPIRED = RC_FMT1 + 0x023
    
    # the commandCode in the policy is not the commandCode of the command or the command code in a policy command references a command that is not implemented
    POLICY_CC = RC_FMT1 + 0x024
    
    # public and sensitive portions of an object are not cryptographically bound
    BINDING = RC_FMT1 + 0x025
    
    # curve not supported
    CURVE = RC_FMT1 + 0x026
    
    # point is not on the required curve.
    ECC_POINT = RC_FMT1 + 0x027
    
    # set for warning response codes
    RC_WARN = 0x900
    
    # gap for context ID is too large
    CONTEXT_GAP = RC_WARN + 0x001
    
    # out of memory for object contexts
    OBJECT_MEMORY = RC_WARN + 0x002
    
    # out of memory for session contexts
    SESSION_MEMORY = RC_WARN + 0x003
    
    # out of shared object/session memory or need space for internal operations
    MEMORY = RC_WARN + 0x004
    
    # out of session handles a session must be flushed before a new session may be created
    SESSION_HANDLES = RC_WARN + 0x005
    
    # out of object handles the handle space for objects is depleted and a reboot is required NOTE 1 This cannot occur on the reference implementation. NOTE 2 There is no reason why an implementation would implement a design that would deplete handle space. Platform specifications are encouraged to forbid it.
    OBJECT_HANDLES = RC_WARN + 0x006
    
    # bad locality
    LOCALITY = RC_WARN + 0x007
    
    # the TPM has suspended operation on the command; forward progress was made and the command may be retried See TPM 2.0 Part 1, Multi-tasking. NOTE This cannot occur on the reference implementation.
    YIELDED = RC_WARN + 0x008
    
    # the command was canceled
    CANCELED = RC_WARN + 0x009
    
    # TPM is performing self-tests
    TESTING = RC_WARN + 0x00A
    
    # the 1st handle in the handle area references a transient object or session that is not loaded
    REFERENCE_H0 = RC_WARN + 0x010
    
    # the 2nd handle in the handle area references a transient object or session that is not loaded
    REFERENCE_H1 = RC_WARN + 0x011
    
    # the 3rd handle in the handle area references a transient object or session that is not loaded
    REFERENCE_H2 = RC_WARN + 0x012
    
    # the 4th handle in the handle area references a transient object or session that is not loaded
    REFERENCE_H3 = RC_WARN + 0x013
    
    # the 5th handle in the handle area references a transient object or session that is not loaded
    REFERENCE_H4 = RC_WARN + 0x014
    
    # the 6th handle in the handle area references a transient object or session that is not loaded
    REFERENCE_H5 = RC_WARN + 0x015
    
    # the 7th handle in the handle area references a transient object or session that is not loaded
    REFERENCE_H6 = RC_WARN + 0x016
    
    # the 1st authorization session handle references a session that is not loaded
    REFERENCE_S0 = RC_WARN + 0x018
    
    # the 2nd authorization session handle references a session that is not loaded
    REFERENCE_S1 = RC_WARN + 0x019
    
    # the 3rd authorization session handle references a session that is not loaded
    REFERENCE_S2 = RC_WARN + 0x01A
    
    # the 4th authorization session handle references a session that is not loaded
    REFERENCE_S3 = RC_WARN + 0x01B
    
    # the 5th session handle references a session that is not loaded
    REFERENCE_S4 = RC_WARN + 0x01C
    
    # the 6th session handle references a session that is not loaded
    REFERENCE_S5 = RC_WARN + 0x01D
    
    # the 7th authorization session handle references a session that is not loaded
    REFERENCE_S6 = RC_WARN + 0x01E
    
    # the TPM is rate-limiting accesses to prevent wearout of NV
    NV_RATE = RC_WARN + 0x020
    
    # authorizations for objects subject to DA protection are not allowed at this time because the TPM is in DA lockout mode
    LOCKOUT = RC_WARN + 0x021
    
    # the TPM was not able to start the command
    RETRY = RC_WARN + 0x022
    
    # the command may require writing of NV and NV is not current accessible
    NV_UNAVAILABLE = RC_WARN + 0x023
    
    # this value is reserved and shall not be returned by the TPM
    NOT_USED = RC_WARN + 0x7F
    
    # add to a parameter-related error
    P = 0x040
    
    # add to a session-related error
    S = 0x800
    
    # add to a parameter-, handle-, or session-related error
    _1 = 0x100
    
    # add to a parameter-, handle-, or session-related error
    _2 = 0x200
    
    # add to a parameter-, handle-, or session-related error
    _3 = 0x300
    
    # add to a parameter-, handle-, or session-related error
    _4 = 0x400
    
    # add to a parameter-, handle-, or session-related error
    _5 = 0x500
    
    # add to a parameter-, handle-, or session-related error
    _6 = 0x600
    
    # add to a parameter-, handle-, or session-related error
    _7 = 0x700
    
    # add to a parameter-related error
    _8 = 0x800
    
    # add to a parameter-related error
    _9 = 0x900
    
    # add to a parameter-related error
    A = 0xA00
    
    # add to a parameter-related error
    B = 0xB00
    
    # add to a parameter-related error
    C = 0xC00
    
    # add to a parameter-related error
    D = 0xD00
    
    # add to a parameter-related error
    E = 0xE00
    
    # add to a parameter-related error
    F = 0xF00
    
    # number mask
    N_MASK = 0xF00
    
    # Response buffer returned by the TPM is too short
    TSS_TCP_BAD_HANDSHAKE_RESP = 0x40280001
    
    # Too old TCP server version
    TSS_TCP_SERVER_TOO_OLD = 0x40280002
    
    # Bad ack from the TCP end point
    TSS_TCP_BAD_ACK = 0x40280003
    
    # Wrong length of the response buffer returned by the TPM
    TSS_TCP_BAD_RESP_LEN = 0x40280004
    
    # TPM2_Startup returned unexpected response code
    TSS_TCP_UNEXPECTED_STARTUP_RESP = 0x40280005
    
    # Invalid size tag in the TPM response TCP packet
    TSS_TCP_INVALID_SIZE_TAG = 0x40280006
    
    # Sending data to TPM failed
    TSS_SEND_OP_FAILED = 0x40280011
    
    # Response buffer returned by the TPM is too short
    TSS_RESP_BUF_TOO_SHORT = 0x40280021
    
    # Invalid tag in the response buffer returned by the TPM
    TSS_RESP_BUF_INVALID_SESSION_TAG = 0x40280022
    
    # Windows TBS error TPM_E_COMMAND_BLOCKED
    TBS_COMMAND_BLOCKED = 0x80280400
    
    # Windows TBS error TPM_E_INVALID_HANDLE
    TBS_INVALID_HANDLE = 0x80280401
    
    # Windows TBS error TPM_E_DUPLICATE_VHANDLE
    TBS_DUPLICATE_V_HANDLE = 0x80280402
    
    # Windows TBS error TPM_E_EMBEDDED_COMMAND_BLOCKED
    TBS_EMBEDDED_COMMAND_BLOCKED = 0x80280403
    
    # Windows TBS error TPM_E_EMBEDDED_COMMAND_UNSUPPORTED
    TBS_EMBEDDED_COMMAND_UNSUPPORTED = 0x80280404
    
    # Windows TBS returned success but empty response buffer
    TBS_UNKNOWN_ERROR = 0x80284000
    
    # Windows TBS error TBS_E_INTERNAL_ERROR
    TBS_INTERNAL_ERROR = 0x80284001
    
    # Windows TBS error TBS_E_BAD_PARAMETER
    TBS_BAD_PARAMETER = 0x80284002
    
    # Windows TBS error TBS_E_INVALID_OUTPUT_POINTER
    TBS_INVALID_OUTPUT_POINTER = 0x80284003
    
    # Windows TBS error TBS_E_INVALID_CONTEXT
    TBS_INVALID_CONTEXT = 0x80284004
    
    # Windows TBS error TBS_E_INSUFFICIENT_BUFFER
    TBS_INSUFFICIENT_BUFFER = 0x80284005
    
    # Windows TBS error TBS_E_IOERROR
    TBS_IO_ERROR = 0x80284006
    
    # Windows TBS error TBS_E_INVALID_CONTEXT_PARAM
    TBS_INVALID_CONTEXT_PARAM = 0x80284007
    
    # Windows TBS error TBS_E_SERVICE_NOT_RUNNING
    TBS_SERVICE_NOT_RUNNING = 0x80284008
    
    # Windows TBS error TBS_E_TOO_MANY_TBS_CONTEXTS
    TBS_TOO_MANY_CONTEXTS = 0x80284009
    
    # Windows TBS error TBS_E_TOO_MANY_TBS_RESOURCES
    TBS_TOO_MANY_RESOURCES = 0x8028400A
    
    # Windows TBS error TBS_E_SERVICE_START_PENDING
    TBS_SERVICE_START_PENDING = 0x8028400B
    
    # Windows TBS error TBS_E_PPI_NOT_SUPPORTED
    TBS_PPI_NOT_SUPPORTED = 0x8028400C
    
    # Windows TBS error TBS_E_COMMAND_CANCELED
    TBS_COMMAND_CANCELED = 0x8028400D
    
    # Windows TBS error TBS_E_BUFFER_TOO_LARGE
    TBS_BUFFER_TOO_LARGE = 0x8028400E
    
    # Windows TBS error TBS_E_TPM_NOT_FOUND
    TBS_NOT_FOUND = 0x8028400F
    
    # Windows TBS error TBS_E_SERVICE_DISABLED
    TBS_SERVICE_DISABLED = 0x80284010
    
    # Windows TBS error TBS_E_ACCESS_DENIED
    TBS_ACCESS_DENIED = 0x80284012
    
    # Windows TBS error TBS_E_PPI_FUNCTION_UNSUPPORTED
    TBS_PPI_FUNCTION_NOT_SUPPORTED = 0x80284014
    
    # Windows TBS error TBS_E_OWNERAUTH_NOT_FOUND
    TBS_OWNER_AUTH_NOT_FOUND = 0x80284015
    
# enum TPM_RC

# A TPM_CLOCK_ADJUST value is used to change the rate at which the TPM internal oscillator is divided. A change to the divider will change the rate at which Clock and Time change.
class TPM_CLOCK_ADJUST(TpmEnum): # INT8
    # Slow the Clock update rate by one coarse adjustment step.
    COARSE_SLOWER = -3
    
    # Slow the Clock update rate by one medium adjustment step.
    MEDIUM_SLOWER = -2
    
    # Slow the Clock update rate by one fine adjustment step.
    FINE_SLOWER = -1
    
    # No change to the Clock update rate.
    NO_CHANGE = 0
    
    # Speed the Clock update rate by one fine adjustment step.
    FINE_FASTER = 1
    
    # Speed the Clock update rate by one medium adjustment step.
    MEDIUM_FASTER = 2
    
    # Speed the Clock update rate by one coarse adjustment step.
    COARSE_FASTER = 3
    
# enum TPM_CLOCK_ADJUST

# Table 18 Definition of (UINT16) TPM_EO Constants (IN/OUT)
class TPM_EO(TpmEnum): # UINT16
    # A = B
    EQ = 0x0000
    
    # A B
    NEQ = 0x0001
    
    # A ) B signed
    SIGNED_GT = 0x0002
    
    # A ) B unsigned
    UNSIGNED_GT = 0x0003
    
    # A ( B signed
    SIGNED_LT = 0x0004
    
    # A ( B unsigned
    UNSIGNED_LT = 0x0005
    
    # A B signed
    SIGNED_GE = 0x0006
    
    # A B unsigned
    UNSIGNED_GE = 0x0007
    
    # A B signed
    SIGNED_LE = 0x0008
    
    # A B unsigned
    UNSIGNED_LE = 0x0009
    
    # All bits SET in B are SET in A. ((A AND B)=B)
    BITSET = 0x000A
    
    # All bits SET in B are CLEAR in A. ((A AND B)=0)
    BITCLEAR = 0x000B
    
# enum TPM_EO

# Structure tags are used to disambiguate structures. They are 16-bit values with the most significant bit SET so that they do not overlap TPM_ALG_ID values. A single exception is made for the value associated with TPM_ST_RSP_COMMAND (0x00C4), which has the same value as the TPM_TAG_RSP_COMMAND tag from earlier versions of this specification. This value is used when the TPM is compatible with a previous TPM specification and the TPM cannot determine which family of response code to return because the command tag is not valid.
class TPM_ST(TpmEnum): # UINT16
    # tag value for a response; used when there is an error in the tag. This is also the value returned from a TPM 1.2 when an error occurs. This value is used in this specification because an error in the command tag may prevent determination of the family. When this tag is used in the response, the response code will be TPM_RC_BAD_TAG (0 1E16), which has the same numeric value as the TPM 1.2 response code for TPM_BADTAG. NOTE In a previously published version of this specification, TPM_RC_BAD_TAG was incorrectly assigned a value of 0x030 instead of 30 (0x01e). Some implementations my return the old value instead of the new value.
    RSP_COMMAND = 0x00C4
    
    # no structure type specified
    NULL = 0X8000
    
    # tag value for a command/response for a command defined in this specification; indicating that the command/response has no attached sessions and no authorizationSize/parameterSize value is present If the responseCode from the TPM is not TPM_RC_SUCCESS, then the response tag shall have this value.
    NO_SESSIONS = 0x8001
    
    # tag value for a command/response for a command defined in this specification; indicating that the command/response has one or more attached sessions and the authorizationSize/parameterSize field is present
    SESSIONS = 0x8002
    
    # tag for an attestation structure
    ATTEST_NV = 0x8014
    
    # tag for an attestation structure
    ATTEST_COMMAND_AUDIT = 0x8015
    
    # tag for an attestation structure
    ATTEST_SESSION_AUDIT = 0x8016
    
    # tag for an attestation structure
    ATTEST_CERTIFY = 0x8017
    
    # tag for an attestation structure
    ATTEST_QUOTE = 0x8018
    
    # tag for an attestation structure
    ATTEST_TIME = 0x8019
    
    # tag for an attestation structure
    ATTEST_CREATION = 0x801A
    
    # tag for a ticket type
    CREATION = 0x8021
    
    # tag for a ticket type
    VERIFIED = 0x8022
    
    # tag for a ticket type
    AUTH_SECRET = 0x8023
    
    # tag for a ticket type
    HASHCHECK = 0x8024
    
    # tag for a ticket type
    AUTH_SIGNED = 0x8025
    
    # tag for a structure describing a Field Upgrade Policy
    FU_MANIFEST = 0x8029
    
# enum TPM_ST

# These values are used in TPM2_Startup() to indicate the shutdown and startup mode. The defined startup sequences are:
class TPM_SU(TpmEnum): # UINT16
    # on TPM2_Shutdown(), indicates that the TPM should prepare for loss of power and save state required for an orderly startup (TPM Reset). on TPM2_Startup(), indicates that the TPM should perform TPM Reset or TPM Restart
    CLEAR = 0x0000
    
    # on TPM2_Shutdown(), indicates that the TPM should prepare for loss of power and save state required for an orderly startup (TPM Restart or TPM Resume) on TPM2_Startup(), indicates that the TPM should restore the state saved by TPM2_Shutdown(TPM_SU_STATE)
    STATE = 0x0001
    
# enum TPM_SU

# This type is used in TPM2_StartAuthSession() to indicate the type of the session to be created.
class TPM_SE(TpmEnum): # UINT8
    HMAC = 0x00
    
    POLICY = 0x01
    
    # The policy session is being used to compute the policyHash and not for command authorization. This setting modifies some policy commands and prevents session from being used to authorize a command.
    TRIAL = 0x03
    
# enum TPM_SE

# The TPM_CAP values are used in TPM2_GetCapability() to select the type of the value to be returned. The format of the response varies according to the type of the value.
class TPM_CAP(TpmEnum): # UINT32
    FIRST = 0x00000000
    
    # TPML_ALG_PROPERTY
    ALGS = 0x00000000
    
    # TPML_HANDLE
    HANDLES = 0x00000001
    
    # TPML_CCA
    COMMANDS = 0x00000002
    
    # TPML_CC
    PP_COMMANDS = 0x00000003
    
    # TPML_CC
    AUDIT_COMMANDS = 0x00000004
    
    # TPML_PCR_SELECTION
    PCRS = 0x00000005
    
    # TPML_TAGGED_TPM_PROPERTY
    TPM_PROPERTIES = 0x00000006
    
    # TPML_TAGGED_PCR_PROPERTY
    PCR_PROPERTIES = 0x00000007
    
    # TPML_ECC_CURVE
    ECC_CURVES = 0x00000008
    
    # TPML_TAGGED_POLICY
    AUTH_POLICIES = 0x00000009
    
    LAST = 0x00000009
    
    # manufacturer-specific values
    VENDOR_PROPERTY = 0x00000100
    
# enum TPM_CAP

# The TPM_PT constants are used in TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES) to indicate the property being selected or returned.
class TPM_PT(TpmEnum): # UINT32
    # indicates no property type
    NONE = 0x00000000
    
    # The number of properties in each group. NOTE The first group with any properties is group 1 (PT_GROUP * 1). Group 0 is reserved.
    PT_GROUP = 0x00000100
    
    # the group of fixed properties returned as TPMS_TAGGED_PROPERTY The values in this group are only changed due to a firmware change in the TPM.
    PT_FIXED = PT_GROUP * 1
    
    # a 4-octet character string containing the TPM Family value (TPM_SPEC_FAMILY)
    FAMILY_INDICATOR = PT_FIXED + 0
    
    # the level of the specification NOTE 1 For this specification, the level is zero. NOTE 2 The level is on the title page of the specification.
    LEVEL = PT_FIXED + 1
    
    # the specification Revision times 100 EXAMPLE Revision 01.01 would have a value of 101. NOTE The Revision value is on the title page of the specification.
    REVISION = PT_FIXED + 2
    
    # the specification day of year using TCG calendar EXAMPLE November 15, 2010, has a day of year value of 319 (0000013F16). NOTE The specification date is on the title page of the specification or errata (see 6.1).
    DAY_OF_YEAR = PT_FIXED + 3
    
    # the specification year using the CE EXAMPLE The year 2010 has a value of 000007DA16. NOTE The specification date is on the title page of the specification or errata (see 6.1).
    YEAR = PT_FIXED + 4
    
    # the vendor ID unique to each TPM manufacturer
    MANUFACTURER = PT_FIXED + 5
    
    # the first four characters of the vendor ID string NOTE When the vendor string is fewer than 16 octets, the additional property values do not have to be present. A vendor string of 4 octets can be represented in one 32-bit value and no null terminating character is required.
    VENDOR_STRING_1 = PT_FIXED + 6
    
    # the second four characters of the vendor ID string
    VENDOR_STRING_2 = PT_FIXED + 7
    
    # the third four characters of the vendor ID string
    VENDOR_STRING_3 = PT_FIXED + 8
    
    # the fourth four characters of the vendor ID sting
    VENDOR_STRING_4 = PT_FIXED + 9
    
    # vendor-defined value indicating the TPM model
    VENDOR_TPM_TYPE = PT_FIXED + 10
    
    # the most-significant 32 bits of a TPM vendor-specific value indicating the version number of the firmware. See 10.12.2 and 10.12.8.
    FIRMWARE_VERSION_1 = PT_FIXED + 11
    
    # the least-significant 32 bits of a TPM vendor-specific value indicating the version number of the firmware. See 10.12.2 and 10.12.8.
    FIRMWARE_VERSION_2 = PT_FIXED + 12
    
    # the maximum size of a parameter (typically, a TPM2B_MAX_BUFFER)
    INPUT_BUFFER = PT_FIXED + 13
    
    # the minimum number of transient objects that can be held in TPM RAM NOTE This minimum shall be no less than the minimum value required by the platform-specific specification to which the TPM is built.
    HR_TRANSIENT_MIN = PT_FIXED + 14
    
    # the minimum number of persistent objects that can be held in TPM NV memory NOTE This minimum shall be no less than the minimum value required by the platform-specific specification to which the TPM is built.
    HR_PERSISTENT_MIN = PT_FIXED + 15
    
    # the minimum number of authorization sessions that can be held in TPM RAM NOTE This minimum shall be no less than the minimum value required by the platform-specific specification to which the TPM is built.
    HR_LOADED_MIN = PT_FIXED + 16
    
    # the number of authorization sessions that may be active at a time A session is active when it has a context associated with its handle. The context may either be in TPM RAM or be context saved. NOTE This value shall be no less than the minimum value required by the platform-specific specification to which the TPM is built.
    ACTIVE_SESSIONS_MAX = PT_FIXED + 17
    
    # the number of PCR implemented NOTE This number is determined by the defined attributes, not the number of PCR that are populated.
    PCR_COUNT = PT_FIXED + 18
    
    # the minimum number of octets in a TPMS_PCR_SELECT.sizeOfSelect NOTE This value is not determined by the number of PCR implemented but by the number of PCR required by the platform-specific specification with which the TPM is compliant or by the implementer if not adhering to a platform-specific specification.
    PCR_SELECT_MIN = PT_FIXED + 19
    
    # the maximum allowed difference (unsigned) between the contextID values of two saved session contexts This value shall be 2n-1, where n is at least 16.
    CONTEXT_GAP_MAX = PT_FIXED + 20
    
    # the maximum number of NV Indexes that are allowed to have the TPM_NT_COUNTER attribute NOTE It is allowed for this value to be larger than the number of NV Indexes that can be defined. This would be indicative of a TPM implementation that did not use different implementation technology for different NV Index types.
    NV_COUNTERS_MAX = PT_FIXED + 22
    
    # the maximum size of an NV Index data area
    NV_INDEX_MAX = PT_FIXED + 23
    
    # a TPMA_MEMORY indicating the memory management method for the TPM
    MEMORY = PT_FIXED + 24
    
    # interval, in milliseconds, between updates to the copy of TPMS_CLOCK_INFO.clock in NV
    CLOCK_UPDATE = PT_FIXED + 25
    
    # the algorithm used for the integrity HMAC on saved contexts and for hashing the fuData of TPM2_FirmwareRead()
    CONTEXT_HASH = PT_FIXED + 26
    
    # TPM_ALG_ID, the algorithm used for encryption of saved contexts
    CONTEXT_SYM = PT_FIXED + 27
    
    # TPM_KEY_BITS, the size of the key used for encryption of saved contexts
    CONTEXT_SYM_SIZE = PT_FIXED + 28
    
    # the modulus - 1 of the count for NV update of an orderly counter The returned value is MAX_ORDERLY_COUNT. This will have a value of 2N 1 where 1 N 32 NOTE 1 An orderly counter is an NV Index with an TPM_NT of TPM_NV_COUNTER and TPMA_NV_ORDERLY SET. NOTE 2 When the low-order bits of a counter equal this value, an NV write occurs on the next increment.
    ORDERLY_COUNT = PT_FIXED + 29
    
    # the maximum value for commandSize in a command
    MAX_COMMAND_SIZE = PT_FIXED + 30
    
    # the maximum value for responseSize in a response
    MAX_RESPONSE_SIZE = PT_FIXED + 31
    
    # the maximum size of a digest that can be produced by the TPM
    MAX_DIGEST = PT_FIXED + 32
    
    # the maximum size of an object context that will be returned by TPM2_ContextSave
    MAX_OBJECT_CONTEXT = PT_FIXED + 33
    
    # the maximum size of a session context that will be returned by TPM2_ContextSave
    MAX_SESSION_CONTEXT = PT_FIXED + 34
    
    # platform-specific family (a TPM_PS value)(see Table 25) NOTE The platform-specific values for the TPM_PT_PS parameters are in the relevant platform-specific specification. In the reference implementation, all of these values are 0.
    PS_FAMILY_INDICATOR = PT_FIXED + 35
    
    # the level of the platform-specific specification
    PS_LEVEL = PT_FIXED + 36
    
    # the specification Revision times 100 for the platform-specific specification EXAMPLE Revision 01.01 would have a value of 101.
    PS_REVISION = PT_FIXED + 37
    
    # the platform-specific TPM specification day of year using TCG calendar EXAMPLE November 15, 2010, has a day of year value of 319 (0000013F16).
    PS_DAY_OF_YEAR = PT_FIXED + 38
    
    # the platform-specific TPM specification year using the CE EXAMPLE The year 2010 has a value of 000007DA16.
    PS_YEAR = PT_FIXED + 39
    
    # the number of split signing operations supported by the TPM
    SPLIT_MAX = PT_FIXED + 40
    
    # total number of commands implemented in the TPM
    TOTAL_COMMANDS = PT_FIXED + 41
    
    # number of commands from the TPM library that are implemented
    LIBRARY_COMMANDS = PT_FIXED + 42
    
    # number of vendor commands that are implemented
    VENDOR_COMMANDS = PT_FIXED + 43
    
    # the maximum data size in one NV write or NV read command
    NV_BUFFER_MAX = PT_FIXED + 44
    
    # a TPMA_MODES value, indicating that the TPM is designed for these modes.
    MODES = PT_FIXED + 45
    
    # the maximum size of a TPMS_CAPABILITY_DATA structure returned in TPM2_GetCapability().
    MAX_CAP_BUFFER = PT_FIXED + 46
    
    # the group of variable properties returned as TPMS_TAGGED_PROPERTY The properties in this group change because of a Protected Capability other than a firmware update. The values are not necessarily persistent across all power transitions.
    PT_VAR = PT_GROUP * 2
    
    # TPMA_PERMANENT
    PERMANENT = PT_VAR + 0
    
    # TPMA_STARTUP_CLEAR
    STARTUP_CLEAR = PT_VAR + 1
    
    # the number of NV Indexes currently defined
    HR_NV_INDEX = PT_VAR + 2
    
    # the number of authorization sessions currently loaded into TPM RAM
    HR_LOADED = PT_VAR + 3
    
    # the number of additional authorization sessions, of any type, that could be loaded into TPM RAM This value is an estimate. If this value is at least 1, then at least one authorization session of any type may be loaded. Any command that changes the RAM memory allocation can make this estimate invalid. NOTE A valid implementation may return 1 even if more than one authorization session would fit into RAM.
    HR_LOADED_AVAIL = PT_VAR + 4
    
    # the number of active authorization sessions currently being tracked by the TPM This is the sum of the loaded and saved sessions.
    HR_ACTIVE = PT_VAR + 5
    
    # the number of additional authorization sessions, of any type, that could be created This value is an estimate. If this value is at least 1, then at least one authorization session of any type may be created. Any command that changes the RAM memory allocation can make this estimate invalid. NOTE A valid implementation may return 1 even if more than one authorization session could be created.
    HR_ACTIVE_AVAIL = PT_VAR + 6
    
    # estimate of the number of additional transient objects that could be loaded into TPM RAM This value is an estimate. If this value is at least 1, then at least one object of any type may be loaded. Any command that changes the memory allocation can make this estimate invalid. NOTE A valid implementation may return 1 even if more than one transient object would fit into RAM.
    HR_TRANSIENT_AVAIL = PT_VAR + 7
    
    # the number of persistent objects currently loaded into TPM NV memory
    HR_PERSISTENT = PT_VAR + 8
    
    # the number of additional persistent objects that could be loaded into NV memory This value is an estimate. If this value is at least 1, then at least one object of any type may be made persistent. Any command that changes the NV memory allocation can make this estimate invalid. NOTE A valid implementation may return 1 even if more than one persistent object would fit into NV memory.
    HR_PERSISTENT_AVAIL = PT_VAR + 9
    
    # the number of defined NV Indexes that have NV the TPM_NT_COUNTER attribute
    NV_COUNTERS = PT_VAR + 10
    
    # the number of additional NV Indexes that can be defined with their TPM_NT of TPM_NV_COUNTER and the TPMA_NV_ORDERLY attribute SET This value is an estimate. If this value is at least 1, then at least one NV Index may be created with a TPM_NT of TPM_NV_COUNTER and the TPMA_NV_ORDERLY attributes. Any command that changes the NV memory allocation can make this estimate invalid. NOTE A valid implementation may return 1 even if more than one NV counter could be defined.
    NV_COUNTERS_AVAIL = PT_VAR + 11
    
    # code that limits the algorithms that may be used with the TPM
    ALGORITHM_SET = PT_VAR + 12
    
    # the number of loaded ECC curves
    LOADED_CURVES = PT_VAR + 13
    
    # the current value of the lockout counter (failedTries)
    LOCKOUT_COUNTER = PT_VAR + 14
    
    # the number of authorization failures before DA lockout is invoked
    MAX_AUTH_FAIL = PT_VAR + 15
    
    # the number of seconds before the value reported by TPM_PT_LOCKOUT_COUNTER is decremented
    LOCKOUT_INTERVAL = PT_VAR + 16
    
    # the number of seconds after a lockoutAuth failure before use of lockoutAuth may be attempted again
    LOCKOUT_RECOVERY = PT_VAR + 17
    
    # number of milliseconds before the TPM will accept another command that will modify NV This value is an approximation and may go up or down over time.
    NV_WRITE_RECOVERY = PT_VAR + 18
    
    # the high-order 32 bits of the command audit counter
    AUDIT_COUNTER_0 = PT_VAR + 19
    
    # the low-order 32 bits of the command audit counter
    AUDIT_COUNTER_1 = PT_VAR + 20
    
# enum TPM_PT

# The TPM_PT_PCR constants are used in TPM2_GetCapability() to indicate the property being selected or returned. The PCR properties can be read when capability == TPM_CAP_PCR_PROPERTIES. If there is no property that corresponds to the value of property, the next higher value is returned, if it exists.
class TPM_PT_PCR(TpmEnum): # UINT32
    # bottom of the range of TPM_PT_PCR properties
    FIRST = 0x00000000
    
    # a SET bit in the TPMS_PCR_SELECT indicates that the PCR is saved and restored by TPM_SU_STATE
    SAVE = 0x00000000
    
    # a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 0 This property is only present if a locality other than 0 is implemented.
    EXTEND_L0 = 0x00000001
    
    # a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset() from locality 0
    RESET_L0 = 0x00000002
    
    # a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 1 This property is only present if locality 1 is implemented.
    EXTEND_L1 = 0x00000003
    
    # a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset() from locality 1 This property is only present if locality 1 is implemented.
    RESET_L1 = 0x00000004
    
    # a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 2 This property is only present if localities 1 and 2 are implemented.
    EXTEND_L2 = 0x00000005
    
    # a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset() from locality 2 This property is only present if localities 1 and 2 are implemented.
    RESET_L2 = 0x00000006
    
    # a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 3 This property is only present if localities 1, 2, and 3 are implemented.
    EXTEND_L3 = 0x00000007
    
    # a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset() from locality 3 This property is only present if localities 1, 2, and 3 are implemented.
    RESET_L3 = 0x00000008
    
    # a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 4 This property is only present if localities 1, 2, 3, and 4 are implemented.
    EXTEND_L4 = 0x00000009
    
    # a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset() from locality 4 This property is only present if localities 1, 2, 3, and 4 are implemented.
    RESET_L4 = 0x0000000A
    
    # a SET bit in the TPMS_PCR_SELECT indicates that modifications to this PCR (reset or Extend) will not increment the pcrUpdateCounter
    NO_INCREMENT = 0x00000011
    
    # a SET bit in the TPMS_PCR_SELECT indicates that the PCR is reset by a D-RTM event These PCR are reset to -1 on TPM2_Startup() and reset to 0 on a _TPM_Hash_End event following a _TPM_Hash_Start event.
    DRTM_RESET = 0x00000012
    
    # a SET bit in the TPMS_PCR_SELECT indicates that the PCR is controlled by policy This property is only present if the TPM supports policy control of a PCR.
    POLICY = 0x00000013
    
    # a SET bit in the TPMS_PCR_SELECT indicates that the PCR is controlled by an authorization value This property is only present if the TPM supports authorization control of a PCR.
    AUTH = 0x00000014
    
    # top of the range of TPM_PT_PCR properties of the implementation If the TPM receives a request for a PCR property with a value larger than this, the TPM will return a zero length list and set the moreData parameter to NO. NOTE This is an implementation-specific value. The value shown reflects the reference code implementation.
    LAST = 0x00000014
    
# enum TPM_PT_PCR

# The platform values in Table 25 are used for the TPM_PT_PS_FAMILY_INDICATOR.
class TPM_PS(TpmEnum): # UINT32
    # not platform specific
    MAIN = 0x00000000
    
    # PC Client
    PC = 0x00000001
    
    # PDA (includes all mobile devices that are not specifically cell phones)
    PDA = 0x00000002
    
    # Cell Phone
    CELL_PHONE = 0x00000003
    
    # Server WG
    SERVER = 0x00000004
    
    # Peripheral WG
    PERIPHERAL = 0x00000005
    
    # TSS WG (deprecated)
    TSS = 0x00000006
    
    # Storage WG
    STORAGE = 0x00000007
    
    # Authentication WG
    AUTHENTICATION = 0x00000008
    
    # Embedded WG
    EMBEDDED = 0x00000009
    
    # Hardcopy WG
    HARDCOPY = 0x0000000A
    
    # Infrastructure WG (deprecated)
    INFRASTRUCTURE = 0x0000000B
    
    # Virtualization WG
    VIRTUALIZATION = 0x0000000C
    
    # Trusted Network Connect WG (deprecated)
    TNC = 0x0000000D
    
    # Multi-tenant WG (deprecated)
    MULTI_TENANT = 0x0000000E
    
    # Technical Committee (deprecated)
    TC = 0x0000000F
    
# enum TPM_PS

# The 32-bit handle space is divided into 256 regions of equal size with 224 values in each. Each of these ranges represents a handle type.
class TPM_HT(TpmEnum): # UINT8
    # PCR consecutive numbers, starting at 0, that reference the PCR registers A platform-specific specification will set the minimum number of PCR and an implementation may have more.
    PCR = 0x00
    
    # NV Index assigned by the caller
    NV_INDEX = 0x01
    
    # HMAC Authorization Session assigned by the TPM when the session is created
    HMAC_SESSION = 0x02
    
    # Loaded Authorization Session used only in the context of TPM2_GetCapability This type references both loaded HMAC and loaded policy authorization sessions.
    LOADED_SESSION = 0x02
    
    # Policy Authorization Session assigned by the TPM when the session is created
    POLICY_SESSION = 0x03
    
    # Saved Authorization Session used only in the context of TPM2_GetCapability This type references saved authorization session contexts for which the TPM is maintaining tracking information.
    SAVED_SESSION = 0x03
    
    # Permanent Values assigned by this specification in Table 28
    PERMANENT = 0x40
    
    # Transient Objects assigned by the TPM when an object is loaded into transient-object memory or when a persistent object is converted to a transient object
    TRANSIENT = 0x80
    
    # Persistent Objects assigned by the TPM when a loaded transient object is made persistent
    PERSISTENT = 0x81
    
    # Attached Component handle for an Attached Component.
    AC = 0x90
    
# enum TPM_HT

# Table 28 lists the architecturally defined handles that cannot be changed. The handles include authorization handles, and special handles.
class TPM_RH(TpmEnum): # TPM_HANDLE
    FIRST = 0x40000000
    
    # not used1
    SRK = 0x40000000
    
    # handle references the Storage Primary Seed (SPS), the ownerAuth, and the ownerPolicy
    OWNER = 0x40000001
    
    # not used1
    REVOKE = 0x40000002
    
    # not used1
    TRANSPORT = 0x40000003
    
    # not used1
    OPERATOR = 0x40000004
    
    # not used1
    ADMIN = 0x40000005
    
    # not used1
    EK = 0x40000006
    
    # a handle associated with the null hierarchy, an EmptyAuth authValue, and an Empty Policy authPolicy.
    NULL = 0x40000007
    
    # value reserved to the TPM to indicate a handle location that has not been initialized or assigned
    UNASSIGNED = 0x40000008
    
    # authorization value used to indicate a password authorization session
    RS_PW = 0x40000009
    
    # references the authorization associated with the dictionary attack lockout reset
    LOCKOUT = 0x4000000A
    
    # references the Endorsement Primary Seed (EPS), endorsementAuth, and endorsementPolicy
    ENDORSEMENT = 0x4000000B
    
    # references the Platform Primary Seed (PPS), platformAuth, and platformPolicy
    PLATFORM = 0x4000000C
    
    # for phEnableNV
    PLATFORM_NV = 0x4000000D
    
    # Start of a range of authorization values that are vendor-specific. A TPM may support any of the values in this range as are needed for vendor-specific purposes. Disabled if ehEnable is CLEAR. NOTE Any includes none.
    AUTH_00 = 0x40000010
    
    # End of the range of vendor-specific authorization values.
    AUTH_FF = 0x4000010F
    
    # the top of the reserved handle area This is set to allow TPM2_GetCapability() to know where to stop. It may vary as implementations add to the permanent handle area.
    LAST = 0x4000010F
    
# enum TPM_RH

# This table lists the values of the TPM_NT field of a TPMA_NV. See Table 205 for usage.
class TPM_NT(TpmEnum): # UINT32
    # Ordinary contains data that is opaque to the TPM that can only be modified using TPM2_NV_Write().
    ORDINARY = 0x0
    
    # Counter contains an 8-octet value that is to be used as a counter and can only be modified with TPM2_NV_Increment()
    COUNTER = 0x1
    
    # Bit Field contains an 8-octet value to be used as a bit field and can only be modified with TPM2_NV_SetBits().
    BITS = 0x2
    
    # Extend contains a digest-sized value used like a PCR. The Index can only be modified using TPM2_NV_Extend(). The extend will use the nameAlg of the Index.
    EXTEND = 0x4
    
    # PIN Fail - contains pinCount that increments on a PIN authorization failure and a pinLimit
    PIN_FAIL = 0x8
    
    # PIN Pass - contains pinCount that increments on a PIN authorization success and a pinLimit
    PIN_PASS = 0x9
    
# enum TPM_NT

# These constants are used in TPM2_AC_GetCapability() to indicate the first tagged value returned from an attached component.
class TPM_AT(TpmEnum): # UINT32
    # in a command, a non-specific request for AC information; in a response, indicates that outputData is not meaningful
    ANY = 0x00000000
    
    # indicates a TCG defined, device-specific error
    ERROR = 0x00000001
    
    # indicates the most significant 32 bits of a pairing value for the AC
    PV1 = 0x00000002
    
    # value added to a TPM_AT to indicate a vendor-specific tag value
    VEND = 0x80000000
    
# enum TPM_AT

# These constants are the TCG-defined error values returned by an AC.
class TPM_AE(TpmEnum): # UINT32
    # in a command, a non-specific request for AC information; in a response, indicates that outputData is not meaningful
    NONE = 0x00000000
    
# enum TPM_AE

# These values are readable with TPM2_GetCapability(). They are the TPM_PT_PS_xxx values.
class PLATFORM(TpmEnum): # UINT32
    FAMILY = TPM_SPEC.FAMILY
    
    LEVEL = TPM_SPEC.LEVEL
    
    VERSION = TPM_SPEC.VERSION
    
    YEAR = TPM_SPEC.YEAR
    
    DAY_OF_YEAR = TPM_SPEC.DAY_OF_YEAR
    
# enum PLATFORM

# This table contains a collection of values used in various parts of the reference code. The values shown are illustrative.
class Implementation(TpmEnum): # UINT32
    # temporary define
    FIELD_UPGRADE_IMPLEMENTED = Logic.NO
    
    # The number of bits in a word. This is used in the big number library to set the unit of allocation. The reference implementation allows values of 32 and 64. It should be set to a value that is compatible with libraries that are used (e.g, OpenSSL).
    RADIX_BITS = 32
    
    # The byte alignment for hash structure
    HASH_ALIGNMENT = 4
    
    # The alignment for symmetric structures.
    SYMMETRIC_ALIGNMENT = 4
    
    # Selection of the library that provides the basic hashing functions.
    HASH_LIB = ImplementationConstants.OSSL
    
    # Selection of the library that provides the low-level symmetric cryptography. Choices are determined by the vendor (See LibSupport.h for implications).
    SYM_LIB = ImplementationConstants.OSSL
    
    # Selection of the library that provides the big number math including ECC. Choices are determined by the vendor (See LibSupport.h for implications).
    MATH_LIB = ImplementationConstants.OSSL
    
    # the number of PCR in the TPM
    IMPLEMENTATION_PCR = 24
    
    # the number of PCR required by the relevant platform specification
    PLATFORM_PCR = 24
    
    # the D-RTM PCR NOTE This value is not defined when the TPM does not implement D-RTM
    DRTM_PCR = 17
    
    # the PCR that will receive the H-CRTM value at TPM2_Startup. This value should not be changed.
    HCRTM_PCR = 0
    
    # the number of localities supported by the TPM This is expected to be either 5 for a PC, or 1 for just about everything else.
    NUM_LOCALITIES = 5
    
    # the maximum number of handles in the handle area This should be produced by the Part 3 parser but is here for now.
    MAX_HANDLE_NUM = 3
    
    # the number of simultaneously active sessions that are supported by the TPM implementation
    MAX_ACTIVE_SESSIONS = 64
    
    # the number of sessions that the TPM may have in memory
    MAX_LOADED_SESSIONS = 3
    
    # this is the current maximum value
    MAX_SESSION_NUM = 3
    
    # the number of simultaneously loaded objects that are supported by the TPM; this number does not include the objects that may be placed in NV memory by TPM2_EvictControl().
    MAX_LOADED_OBJECTS = 3
    
    # the minimum number of evict objects supported by the TPM
    MIN_EVICT_OBJECTS = 2
    
    PCR_SELECT_MIN = ((PLATFORM_PCR+7)/8)
    
    PCR_SELECT_MAX = ((IMPLEMENTATION_PCR+7)/8)
    
    # number of PCR groups that have individual policies
    NUM_POLICY_PCR_GROUP = 1
    
    # number of PCR groups that have individual authorization values
    NUM_AUTHVALUE_PCR_GROUP = 1
    
    MAX_CONTEXT_SIZE = 2474
    
    MAX_DIGEST_BUFFER = 1024
    
    # maximum data size allowed in an NV Index
    MAX_NV_INDEX_SIZE = 2048
    
    # maximum data size in one NV read or write command
    MAX_NV_BUFFER_SIZE = 1024
    
    # maximum size of a capability buffer
    MAX_CAP_BUFFER = 1024
    
    # size of NV memory in octets
    NV_MEMORY_SIZE = 16384
    
    # the TPM will not allocate a non-counter index if it would prevent allocation of this number of indices.
    MIN_COUNTER_INDICES = 8
    
    NUM_STATIC_PCR = 16
    
    # number of algorithms that can be in a list
    MAX_ALG_LIST_SIZE = 64
    
    # size of the Primary Seed in octets
    PRIMARY_SEED_SIZE = 32
    
    # context encryption algorithm Just use the root so that the macros in GpMacros.h will work correctly.
    CONTEXT_ENCRYPT_ALGORITHM = TPM_ALG_ID.AES
    
    # the update interval expressed as a power of 2 seconds A value of 12 is 4,096 seconds (~68 minutes).
    NV_CLOCK_UPDATE_INTERVAL = 12
    
    # number of PCR groups that allow policy/auth
    NUM_POLICY_PCR = 1
    
    # maximum size of a command
    MAX_COMMAND_SIZE = 4096
    
    # maximum size of a response
    MAX_RESPONSE_SIZE = 4096
    
    # number between 1 and 32 inclusive
    ORDERLY_BITS = 8
    
    # the maximum number of octets that may be in a sealed blob; 128 is the minimum allowed value
    MAX_SYM_DATA = 128
    
    MAX_RNG_ENTROPY_SIZE = 64
    
    # Number of bytes used for the RAM index space. If this is not large enough, it might not be possible to allocate orderly indices.
    RAM_INDEX_SPACE = 512
    
    # 216 + 1
    RSA_DEFAULT_PUBLIC_EXPONENT = 0x00010001
    
    # indicates if the TPM_PT_PCR_NO_INCREMENT group is implemented
    ENABLE_PCR_NO_INCREMENT = Logic.YES
    
    CRT_FORMAT_RSA = Logic.YES
    
    VENDOR_COMMAND_COUNT = 0
    
    # MAX_RSA_KEY_BYTES is auto generated from the RSA key size selection in Table 4. If RSA is not implemented, this may need to be manually removed.
    PRIVATE_VENDOR_SPECIFIC_BYTES = ((ImplementationConstants.MAX_RSA_KEY_BYTES/2) * (3 + CRT_FORMAT_RSA * 2))
    
    # Maximum size of the vendor-specific buffer
    MAX_VENDOR_BUFFER_SIZE = 1024
    
# enum Implementation

# The definitions in Table 29 are used to define many of the interface data types.
class TPM_HC(TpmEnum): # TPM_HANDLE
    # to mask off the HR
    HR_HANDLE_MASK = 0x00FFFFFF
    
    # to mask off the variable part
    HR_RANGE_MASK = 0xFF000000
    
    HR_SHIFT = 24
    
    HR_PCR = (TPM_HT.PCR << HR_SHIFT)
    
    HR_HMAC_SESSION = (TPM_HT.HMAC_SESSION << HR_SHIFT)
    
    HR_POLICY_SESSION = (TPM_HT.POLICY_SESSION << HR_SHIFT)
    
    HR_TRANSIENT = (TPM_HT.TRANSIENT << HR_SHIFT)
    
    HR_PERSISTENT = (TPM_HT.PERSISTENT << HR_SHIFT)
    
    HR_NV_INDEX = (TPM_HT.NV_INDEX << HR_SHIFT)
    
    HR_PERMANENT = (TPM_HT.PERMANENT << HR_SHIFT)
    
    # first PCR
    PCR_FIRST = (HR_PCR + 0)
    
    # last PCR
    PCR_LAST = (PCR_FIRST + Implementation.IMPLEMENTATION_PCR-1)
    
    # first HMAC session
    HMAC_SESSION_FIRST = (HR_HMAC_SESSION + 0)
    
    # last HMAC session
    HMAC_SESSION_LAST = (HMAC_SESSION_FIRST+Implementation.MAX_ACTIVE_SESSIONS-1)
    
    # used in GetCapability
    LOADED_SESSION_FIRST = HMAC_SESSION_FIRST
    
    # used in GetCapability
    LOADED_SESSION_LAST = HMAC_SESSION_LAST
    
    # first policy session
    POLICY_SESSION_FIRST = (HR_POLICY_SESSION + 0)
    
    # last policy session
    POLICY_SESSION_LAST = (POLICY_SESSION_FIRST + Implementation.MAX_ACTIVE_SESSIONS-1)
    
    # first transient object
    TRANSIENT_FIRST = (HR_TRANSIENT + 0)
    
    # used in GetCapability
    ACTIVE_SESSION_FIRST = POLICY_SESSION_FIRST
    
    # used in GetCapability
    ACTIVE_SESSION_LAST = POLICY_SESSION_LAST
    
    # last transient object
    TRANSIENT_LAST = (TRANSIENT_FIRST+Implementation.MAX_LOADED_OBJECTS-1)
    
    # first persistent object
    PERSISTENT_FIRST = (HR_PERSISTENT + 0)
    
    # last persistent object
    PERSISTENT_LAST = (PERSISTENT_FIRST + 0x00FFFFFF)
    
    # first platform persistent object
    PLATFORM_PERSISTENT = (PERSISTENT_FIRST + 0x00800000)
    
    # first allowed NV Index
    NV_INDEX_FIRST = (HR_NV_INDEX + 0)
    
    # last allowed NV Index
    NV_INDEX_LAST = (NV_INDEX_FIRST + 0x00FFFFFF)
    
    PERMANENT_FIRST = TPM_RH.FIRST
    
    PERMANENT_LAST = TPM_RH.LAST
    
    # AC aliased NV Index
    HR_NV_AC = ((TPM_HT.NV_INDEX << HR_SHIFT) + 0xD00000)
    
    # first NV Index aliased to Attached Component
    NV_AC_FIRST = (HR_NV_AC + 0)
    
    # last NV Index aliased to Attached Component
    NV_AC_LAST = (HR_NV_AC + 0x0000FFFF)
    
    # AC Handle
    HR_AC = (TPM_HT.AC << HR_SHIFT)
    
    # first Attached Component
    AC_FIRST = (HR_AC + 0)
    
    # last Attached Component
    AC_LAST = (HR_AC + 0x0000FFFF)
    
# enum TPM_HC

# This structure defines the attributes of an algorithm.
class TPMA_ALGORITHM(TpmEnum): # UINT32
    # SET (1): an asymmetric algorithm with public and private portions CLEAR (0): not an asymmetric algorithm
    asymmetric = 0x1
    
    # SET (1): a symmetric block cipher CLEAR (0): not a symmetric block cipher
    symmetric = 0x2
    
    # SET (1): a hash algorithm CLEAR (0): not a hash algorithm
    hash = 0x4
    
    # SET (1): an algorithm that may be used as an object type CLEAR (0): an algorithm that is not used as an object type
    object = 0x8
    
    # SET (1): a signing algorithm. The setting of asymmetric, symmetric, and hash will indicate the type of signing algorithm. CLEAR (0): not a signing algorithm
    signing = 0x100
    
    # SET (1): an encryption/decryption algorithm. The setting of asymmetric, symmetric, and hash will indicate the type of encryption/decryption algorithm. CLEAR (0): not an encryption/decryption algorithm
    encrypting = 0x200
    
    # SET (1): a method such as a key derivative function (KDF) CLEAR (0): not a method
    method = 0x400
    
# bitfield TPMA_ALGORITHM

# This attribute structure indicates an objects use, its authorization types, and its relationship to other objects.
class TPMA_OBJECT(TpmEnum): # UINT32
    # SET (1): The hierarchy of the object, as indicated by its Qualified Name, may not change. CLEAR (0): The hierarchy of the object may change as a result of this object or an ancestor key being duplicated for use in another hierarchy. NOTE fixedTPM does not indicate that key material resides on a single TPM (see sensitiveDataOrigin).
    fixedTPM = 0x2
    
    # SET (1): Previously saved contexts of this object may not be loaded after Startup(CLEAR). CLEAR (0): Saved contexts of this object may be used after a Shutdown(STATE) and subsequent Startup().
    stClear = 0x4
    
    # SET (1): The parent of the object may not change. CLEAR (0): The parent of the object may change as the result of a TPM2_Duplicate() of the object.
    fixedParent = 0x10
    
    # SET (1): Indicates that, when the object was created with TPM2_Create() or TPM2_CreatePrimary(), the TPM generated all of the sensitive data other than the authValue. CLEAR (0): A portion of the sensitive data, other than the authValue, was provided by the caller.
    sensitiveDataOrigin = 0x20
    
    # SET (1): Approval of USER role actions with this object may be with an HMAC session or with a password using the authValue of the object or a policy session. CLEAR (0): Approval of USER role actions with this object may only be done with a policy session.
    userWithAuth = 0x40
    
    # SET (1): Approval of ADMIN role actions with this object may only be done with a policy session. CLEAR (0): Approval of ADMIN role actions with this object may be with an HMAC session or with a password using the authValue of the object or a policy session.
    adminWithPolicy = 0x80
    
    # SET (1): The object is not subject to dictionary attack protections. CLEAR (0): The object is subject to dictionary attack protections.
    noDA = 0x400
    
    # SET (1): If the object is duplicated, then symmetricAlg shall not be TPM_ALG_NULL and newParentHandle shall not be TPM_RH_NULL. CLEAR (0): The object may be duplicated without an inner wrapper on the private portion of the object and the new parent may be TPM_RH_NULL.
    encryptedDuplication = 0x800
    
    # SET (1): Key usage is restricted to manipulate structures of known format; the parent of this key shall have restricted SET. CLEAR (0): Key usage is not restricted to use on special formats.
    restricted = 0x10000
    
    # SET (1): The private portion of the key may be used to decrypt. CLEAR (0): The private portion of the key may not be used to decrypt.
    decrypt = 0x20000
    
    # SET (1): For a symmetric cipher object, the private portion of the key may be used to encrypt. For other objects, the private portion of the key may be used to sign. CLEAR (0): The private portion of the key may not be used to sign or encrypt.
    sign = 0x40000
    
    # Alias to the Sign value.
    encrypt = 0x40000
    
# bitfield TPMA_OBJECT

# This octet in each session is used to identify the session type, indicate its relationship to any handles in the command, and indicate its use in parameter encryption.
class TPMA_SESSION(TpmEnum): # UINT8
    # SET (1): In a command, this setting indicates that the session is to remain active after successful completion of the command. In a response, it indicates that the session is still active. If SET in the command, this attribute shall be SET in the response. CLEAR (0): In a command, this setting indicates that the TPM should close the session and flush any related context when the command completes successfully. In a response, it indicates that the session is closed and the context is no longer active. This attribute has no meaning for a password authorization and the TPM will allow any setting of the attribute in the command and SET the attribute in the response. This attribute will only be CLEAR in one response for a logical session. If the attribute is CLEAR, the context associated with the session is no longer in use and the space is available. A session created after another session is ended may have the same handle but logically is not the same session. This attribute has no effect if the command does not complete successfully.
    continueSession = 0x1
    
    # SET (1): In a command, this setting indicates that the command should only be executed if the session is exclusive at the start of the command. In a response, it indicates that the session is exclusive. This setting is only allowed if the audit attribute is SET (TPM_RC_ATTRIBUTES). CLEAR (0): In a command, indicates that the session need not be exclusive at the start of the command. In a response, indicates that the session is not exclusive.
    auditExclusive = 0x2
    
    # SET (1): In a command, this setting indicates that the audit digest of the session should be initialized and the exclusive status of the session SET. This setting is only allowed if the audit attribute is SET (TPM_RC_ATTRIBUTES). CLEAR (0): In a command, indicates that the audit digest should not be initialized. This bit is always CLEAR in a response.
    auditReset = 0x4
    
    # SET (1): In a command, this setting indicates that the first parameter in the command is symmetrically encrypted using the parameter encryption scheme described in TPM 2.0 Part 1. The TPM will decrypt the parameter after performing any HMAC computations and before unmarshaling the parameter. In a response, the attribute is copied from the request but has no effect on the response. CLEAR (0): Session not used for encryption. For a password authorization, this attribute will be CLEAR in both the command and response. This attribute may be SET in a session that is not associated with a command handle. Such a session is provided for purposes of encrypting a parameter and not for authorization. This attribute may be SET in combination with any other session attributes.
    decrypt = 0x20
    
    # SET (1): In a command, this setting indicates that the TPM should use this session to encrypt the first parameter in the response. In a response, it indicates that the attribute was set in the command and that the TPM used the session to encrypt the first parameter in the response using the parameter encryption scheme described in TPM 2.0 Part 1. CLEAR (0): Session not used for encryption. For a password authorization, this attribute will be CLEAR in both the command and response. This attribute may be SET in a session that is not associated with a command handle. Such a session is provided for purposes of encrypting a parameter and not for authorization.
    encrypt = 0x40
    
    # SET (1): In a command or response, this setting indicates that the session is for audit and that auditExclusive and auditReset have meaning. This session may also be used for authorization, encryption, or decryption. The encrypted and encrypt fields may be SET or CLEAR. CLEAR (0): Session is not used for audit. If SET in the command, then this attribute will be SET in the response.
    audit = 0x80
    
# bitfield TPMA_SESSION

# In a TPMS_CREATION_DATA structure, this structure is used to indicate the locality of the command that created the object. No more than one of the locality attributes shall be set in the creation data.
class TPMA_LOCALITY(TpmEnum): # UINT8
    LOC_ZERO = 0x1
    
    LOC_ONE = 0x2
    
    LOC_TWO = 0x4
    
    LOC_THREE = 0x8
    
    LOC_FOUR = 0x10
    
    # If any of these bits is set, an extended locality is indicated
    Extended_BIT_0 = 0x20
    
    Extended_BIT_1 = 0x40
    
    Extended_BIT_2 = 0x80
    
# bitfield TPMA_LOCALITY

# The attributes in this structure are persistent and are not changed as a result of _TPM_Init or any TPM2_Startup(). Some of the attributes in this structure may change as the result of specific Protected Capabilities. This structure may be read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_PERMANENT).
class TPMA_PERMANENT(TpmEnum): # UINT32
    # SET (1): TPM2_HierarchyChangeAuth() with ownerAuth has been executed since the last TPM2_Clear(). CLEAR (0): ownerAuth has not been changed since TPM2_Clear().
    ownerAuthSet = 0x1
    
    # SET (1): TPM2_HierarchyChangeAuth() with endorsementAuth has been executed since the last TPM2_Clear(). CLEAR (0): endorsementAuth has not been changed since TPM2_Clear().
    endorsementAuthSet = 0x2
    
    # SET (1): TPM2_HierarchyChangeAuth() with lockoutAuth has been executed since the last TPM2_Clear(). CLEAR (0): lockoutAuth has not been changed since TPM2_Clear().
    lockoutAuthSet = 0x4
    
    # SET (1): TPM2_Clear() is disabled. CLEAR (0): TPM2_Clear() is enabled. NOTE See TPM2_ClearControl in TPM 2.0 Part 3 for details on changing this attribute.
    disableClear = 0x100
    
    # SET (1): The TPM is in lockout, when failedTries is equal to maxTries.
    inLockout = 0x200
    
    # SET (1): The EPS was created by the TPM. CLEAR (0): The EPS was created outside of the TPM using a manufacturer-specific process.
    tpmGeneratedEPS = 0x400
    
# bitfield TPMA_PERMANENT

# This structure may be read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_STARTUP_CLEAR).
class TPMA_STARTUP_CLEAR(TpmEnum): # UINT32
    # SET (1): The platform hierarchy is enabled and platformAuth or platformPolicy may be used for authorization. CLEAR (0): platformAuth and platformPolicy may not be used for authorizations, and objects in the platform hierarchy, including persistent objects, cannot be used. NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    phEnable = 0x1
    
    # SET (1): The Storage hierarchy is enabled and ownerAuth or ownerPolicy may be used for authorization. NV indices defined using owner authorization are accessible. CLEAR (0): ownerAuth and ownerPolicy may not be used for authorizations, and objects in the Storage hierarchy, persistent objects, and NV indices defined using owner authorization cannot be used. NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    shEnable = 0x2
    
    # SET (1): The EPS hierarchy is enabled and Endorsement Authorization may be used to authorize commands. CLEAR (0): Endorsement Authorization may not be used for authorizations, and objects in the endorsement hierarchy, including persistent objects, cannot be used. NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    ehEnable = 0x4
    
    # SET (1): NV indices that have TPMA_NV_PLATFORMCREATE SET may be read or written. The platform can create define and undefine indices. CLEAR (0): NV indices that have TPMA_NV_PLATFORMCREATE SET may not be read or written (TPM_RC_HANDLE). The platform cannot define (TPM_RC_HIERARCHY) or undefined (TPM_RC_HANDLE) indices. NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute. NOTE read refers to these commands: TPM2_NV_Read, TPM2_NV_ReadPublic, TPM_NV_Certify, TPM2_PolicyNV write refers to these commands: TPM2_NV_Write, TPM2_NV_Increment, TPM2_NV_Extend, TPM2_NV_SetBits NOTE The TPM must query the index TPMA_NV_PLATFORMCREATE attribute to determine whether phEnableNV is applicable. Since the TPM will return TPM_RC_HANDLE if the index does not exist, it also returns this error code if the index is disabled. Otherwise, the TPM would leak the existence of an index even when disabled.
    phEnableNV = 0x8
    
    # SET (1): The TPM received a TPM2_Shutdown() and a matching TPM2_Startup(). CLEAR (0): TPM2_Startup(TPM_SU_CLEAR) was not preceded by a TPM2_Shutdown() of any type. NOTE A shutdown is orderly if the TPM receives a TPM2_Shutdown() of any type followed by a TPM2_Startup() of any type. However, the TPM will return an error if TPM2_Startup(TPM_SU_STATE) was not preceded by TPM2_Shutdown(TPM_SU_STATE).
    orderly = 0x80000000
    
# bitfield TPMA_STARTUP_CLEAR

# This structure of this attribute is used to report the memory management method used by the TPM for transient objects and authorization sessions. This structure may be read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_MEMORY).
class TPMA_MEMORY(TpmEnum): # UINT32
    # SET (1): indicates that the RAM memory used for authorization session contexts is shared with the memory used for transient objects CLEAR (0): indicates that the memory used for authorization sessions is not shared with memory used for transient objects
    sharedRAM = 0x1
    
    # SET (1): indicates that the NV memory used for persistent objects is shared with the NV memory used for NV Index values CLEAR (0): indicates that the persistent objects and NV Index values are allocated from separate sections of NV
    sharedNV = 0x2
    
    # SET (1): indicates that the TPM copies persistent objects to a transient-object slot in RAM when the persistent object is referenced in a command. The TRM is required to make sure that an object slot is available. CLEAR (0): indicates that the TPM does not use transient-object slots when persistent objects are referenced
    objectCopiedToRam = 0x4
    
# bitfield TPMA_MEMORY

# This structure defines the attributes of a command from a context management perspective. The fields of the structure indicate to the TPM Resource Manager (TRM) the number of resources required by a command and how the command affects the TPMs resources.
class TPMA_CC(TpmEnum): # TPM_CC
    # indicates the command being selected
    commandIndex_BIT_0 = 0x1
    
    commandIndex_BIT_1 = 0x2
    
    commandIndex_BIT_2 = 0x4
    
    commandIndex_BIT_3 = 0x8
    
    commandIndex_BIT_4 = 0x10
    
    commandIndex_BIT_5 = 0x20
    
    commandIndex_BIT_6 = 0x40
    
    commandIndex_BIT_7 = 0x80
    
    commandIndex_BIT_8 = 0x100
    
    commandIndex_BIT_9 = 0x200
    
    commandIndex_BIT_10 = 0x400
    
    commandIndex_BIT_11 = 0x800
    
    commandIndex_BIT_12 = 0x1000
    
    commandIndex_BIT_13 = 0x2000
    
    commandIndex_BIT_14 = 0x4000
    
    commandIndex_BIT_15 = 0x8000
    
    # SET (1): indicates that the command may write to NV CLEAR (0): indicates that the command does not write to NV
    nv = 0x400000
    
    # SET (1): This command could flush any number of loaded contexts. CLEAR (0): no additional changes other than indicated by the flushed attribute
    extensive = 0x800000
    
    # SET (1): The context associated with any transient handle in the command will be flushed when this command completes. CLEAR (0): No context is flushed as a side effect of this command.
    flushed = 0x1000000
    
    # indicates the number of the handles in the handle area for this command
    cHandles_BIT_0 = 0x2000000
    
    cHandles_BIT_1 = 0x4000000
    
    cHandles_BIT_2 = 0x8000000
    
    # SET (1): indicates the presence of the handle area in the response
    rHandle = 0x10000000
    
    # SET (1): indicates that the command is vendor-specific CLEAR (0): indicates that the command is defined in a version of this specification
    V = 0x20000000
    
    # allocated for software; shall be zero
    Res_BIT_0 = 0x40000000
    
    Res_BIT_1 = 0x80000000
    
# bitfield TPMA_CC

# This structure of this attribute is used to report that the TPM is designed for these modes. This structure may be read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_MODES).
class TPMA_MODES(TpmEnum): # UINT32
    # SET (1): indicates that the TPM is designed to comply with all of the FIPS 140-2 requirements at Level 1 or higher.
    FIPS_140_2 = 0x1
    
# bitfield TPMA_MODES

# A TPM_NV_INDEX is used to reference a defined location in NV memory. The format of the Index is changed from TPM 1.2 in order to include the Index in the reserved handle space. Handles in this range use the digest of the public area of the Index as the Name of the entity in authorization computations
class TPM_NV_INDEX(TpmEnum): # UINT32
    # The Index of the NV location
    index_BIT_0 = 0x1
    
    index_BIT_1 = 0x2
    
    index_BIT_2 = 0x4
    
    index_BIT_3 = 0x8
    
    index_BIT_4 = 0x10
    
    index_BIT_5 = 0x20
    
    index_BIT_6 = 0x40
    
    index_BIT_7 = 0x80
    
    index_BIT_8 = 0x100
    
    index_BIT_9 = 0x200
    
    index_BIT_10 = 0x400
    
    index_BIT_11 = 0x800
    
    index_BIT_12 = 0x1000
    
    index_BIT_13 = 0x2000
    
    index_BIT_14 = 0x4000
    
    index_BIT_15 = 0x8000
    
    index_BIT_16 = 0x10000
    
    index_BIT_17 = 0x20000
    
    index_BIT_18 = 0x40000
    
    index_BIT_19 = 0x80000
    
    index_BIT_20 = 0x100000
    
    index_BIT_21 = 0x200000
    
    index_BIT_22 = 0x400000
    
    index_BIT_23 = 0x800000
    
    # constant value of TPM_HT_NV_INDEX indicating the NV Index range
    RhNv_BIT_0 = 0x1000000
    
    RhNv_BIT_1 = 0x2000000
    
    RhNv_BIT_2 = 0x4000000
    
    RhNv_BIT_3 = 0x8000000
    
    RhNv_BIT_4 = 0x10000000
    
    RhNv_BIT_5 = 0x20000000
    
    RhNv_BIT_6 = 0x40000000
    
    RhNv_BIT_7 = 0x80000000
    
# bitfield TPM_NV_INDEX

# This structure allows the TPM to keep track of the data and permissions to manipulate an NV Index.
class TPMA_NV(TpmEnum): # UINT32
    # SET (1): The Index data can be written if Platform Authorization is provided. CLEAR (0): Writing of the Index data cannot be authorized with Platform Authorization.
    PPWRITE = 0x1
    
    # SET (1): The Index data can be written if Owner Authorization is provided. CLEAR (0): Writing of the Index data cannot be authorized with Owner Authorization.
    OWNERWRITE = 0x2
    
    # SET (1): Authorizations to change the Index contents that require USER role may be provided with an HMAC session or password. CLEAR (0): Authorizations to change the Index contents that require USER role may not be provided with an HMAC session or password.
    AUTHWRITE = 0x4
    
    # SET (1): Authorizations to change the Index contents that require USER role may be provided with a policy session. CLEAR (0): Authorizations to change the Index contents that require USER role may not be provided with a policy session. NOTE TPM2_NV_ChangeAuth() always requires that authorization be provided in a policy session.
    POLICYWRITE = 0x8
    
    # Ordinary contains data that is opaque to the TPM that can only be modified using TPM2_NV_Write().
    ORDINARY = 0x0
    
    # Counter contains an 8-octet value that is to be used as a counter and can only be modified with TPM2_NV_Increment()
    COUNTER = 0x10
    
    # Bit Field contains an 8-octet value to be used as a bit field and can only be modified with TPM2_NV_SetBits().
    BITS = 0x20
    
    # Extend contains a digest-sized value used like a PCR. The Index can only be modified using TPM2_NV_Extend(). The extend will use the nameAlg of the Index.
    EXTEND = 0x40
    
    # PIN Fail - contains pinCount that increments on a PIN authorization failure and a pinLimit
    PIN_FAIL = 0x80
    
    # PIN Pass - contains pinCount that increments on a PIN authorization success and a pinLimit
    PIN_PASS = 0x90
    
    # The type of the index. NOTE A TPM is not required to support all TPM_NT values
    TpmNt_BIT_0 = 0x10
    
    TpmNt_BIT_1 = 0x20
    
    TpmNt_BIT_2 = 0x40
    
    TpmNt_BIT_3 = 0x80
    
    # SET (1): Index may not be deleted unless the authPolicy is satisfied using TPM2_NV_UndefineSpaceSpecial(). CLEAR (0): Index may be deleted with proper platform or owner authorization using TPM2_NV_UndefineSpace(). NOTE An Index with this attribute and a policy that cannot be satisfied (e.g., an Empty Policy) cannot be deleted.
    POLICY_DELETE = 0x400
    
    # SET (1): Index cannot be written. CLEAR (0): Index can be written.
    WRITELOCKED = 0x800
    
    # SET (1): A partial write of the Index data is not allowed. The write size shall match the defined space size. CLEAR (0): Partial writes are allowed. This setting is required if the .dataSize of the Index is larger than NV_MAX_BUFFER_SIZE for the implementation.
    WRITEALL = 0x1000
    
    # SET (1): TPM2_NV_WriteLock() may be used to prevent further writes to this location. CLEAR (0): TPM2_NV_WriteLock() does not block subsequent writes if TPMA_NV_WRITE_STCLEAR is also CLEAR.
    WRITEDEFINE = 0x2000
    
    # SET (1): TPM2_NV_WriteLock() may be used to prevent further writes to this location until the next TPM Reset or TPM Restart. CLEAR (0): TPM2_NV_WriteLock() does not block subsequent writes if TPMA_NV_WRITEDEFINE is also CLEAR.
    WRITE_STCLEAR = 0x4000
    
    # SET (1): If TPM2_NV_GlobalWriteLock() is successful, then further writes to this location are not permitted until the next TPM Reset or TPM Restart. CLEAR (0): TPM2_NV_GlobalWriteLock() has no effect on the writing of the data at this Index.
    GLOBALLOCK = 0x8000
    
    # SET (1): The Index data can be read if Platform Authorization is provided. CLEAR (0): Reading of the Index data cannot be authorized with Platform Authorization.
    PPREAD = 0x10000
    
    # SET (1): The Index data can be read if Owner Authorization is provided. CLEAR (0): Reading of the Index data cannot be authorized with Owner Authorization.
    OWNERREAD = 0x20000
    
    # SET (1): The Index data may be read if the authValue is provided. CLEAR (0): Reading of the Index data cannot be authorized with the Index authValue.
    AUTHREAD = 0x40000
    
    # SET (1): The Index data may be read if the authPolicy is satisfied. CLEAR (0): Reading of the Index data cannot be authorized with the Index authPolicy.
    POLICYREAD = 0x80000
    
    # SET (1): Authorization failures of the Index do not affect the DA logic and authorization of the Index is not blocked when the TPM is in Lockout mode. CLEAR (0): Authorization failures of the Index will increment the authorization failure counter and authorizations of this Index are not allowed when the TPM is in Lockout mode.
    NO_DA = 0x2000000
    
    # SET (1): NV Index state is only required to be saved when the TPM performs an orderly shutdown (TPM2_Shutdown()). CLEAR (0): NV Index state is required to be persistent after the command to update the Index completes successfully (that is, the NV update is synchronous with the update command). NOTE If TPMA_NV_ORDERLY is SET, TPMA_NV_WRITTEN will be CLEAR by TPM Reset.
    ORDERLY = 0x4000000
    
    # SET (1): TPMA_NV_WRITTEN for the Index is CLEAR by TPM Reset or TPM Restart. CLEAR (0): TPMA_NV_WRITTEN is not changed by TPM Restart. NOTE This attribute may only be SET if TPM_NT is not TPM_NT_COUNTER.
    CLEAR_STCLEAR = 0x8000000
    
    # SET (1): Reads of the Index are blocked until the next TPM Reset or TPM Restart. CLEAR (0): Reads of the Index are allowed if proper authorization is provided.
    READLOCKED = 0x10000000
    
    # SET (1): Index has been written. CLEAR (0): Index has not been written.
    WRITTEN = 0x20000000
    
    # SET (1): This Index may be undefined with Platform Authorization but not with Owner Authorization. CLEAR (0): This Index may be undefined using Owner Authorization but not with Platform Authorization. The TPM will validate that this attribute is SET when the Index is defined using Platform Authorization and will validate that this attribute is CLEAR when the Index is defined using Owner Authorization.
    PLATFORMCREATE = 0x40000000
    
    # SET (1): TPM2_NV_ReadLock() may be used to SET TPMA_NV_READLOCKED for this Index. CLEAR (0): TPM2_NV_ReadLock() has no effect on this Index.
    READ_STCLEAR = 0x80000000
    
# bitfield TPMA_NV

from .Crypt import *

# TPM union interface
class TpmUnion(TpmMarshaller):
    @abc.abstractmethod
    def GetUnionSelector(self): # returns TPM_ALG_ID | TPM_CAP | TPM_ST
        pass


# Table 84 Definition of TPMU_NAME Union ()
class TPMU_NAME(TpmUnion):
    pass

# Table 110 Definition of TPMU_CAPABILITIES Union (OUT)
class TPMU_CAPABILITIES(TpmUnion):
    pass

# Table 122 Definition of TPMU_ATTEST Union (OUT)
class TPMU_ATTEST(TpmUnion):
    pass

# This union is used to collect the symmetric encryption key sizes.
class TPMU_SYM_KEY_BITS(TpmUnion):
    pass

# This is the union of all modes for all symmetric algorithms.
class TPMU_SYM_MODE(TpmUnion):
    pass

# This union allows additional parameters to be added for a symmetric cipher. Currently, no additional parameters are required for any of the symmetric algorithms.
class TPMU_SYM_DETAILS(TpmUnion):
    pass

# This structure allows a TPM2B_SENSITIVE_CREATE structure to carry either a TPM2B_SENSITVE_DATA or a TPM2B_DERIVE structure. The contents of the union are determined by context. When an object is being derived, the derivation values are present.
class TPMU_SENSITIVE_CREATE(TpmUnion):
    pass

# Table 147 Definition of TPMU_SCHEME_KEYEDHASH Union (IN/OUT, S)
class TPMU_SCHEME_KEYEDHASH(TpmUnion):
    pass

# This is the union of all of the signature schemes.
class TPMU_SIG_SCHEME(TpmUnion):
    pass

# Table 156 Definition of TPMU_KDF_SCHEME Union (IN/OUT, S)
class TPMU_KDF_SCHEME(TpmUnion):
    pass

# This union of all asymmetric schemes is used in each of the asymmetric scheme structures. The actual scheme structure is defined by the interface type used for the selector (TPMI_ALG_ASYM_SCHEME).
class TPMU_ASYM_SCHEME(TpmUnion):
    pass

# A TPMU_SIGNATURE_COMPOSITE is a union of the various signatures that are supported by a particular TPM implementation. The union allows substitution of any signature algorithm wherever a signature is required in a structure.
class TPMU_SIGNATURE(TpmUnion):
    pass

# This structure is used to hold either an ephemeral public point for ECDH, an OAEP-encrypted block for RSA, or a symmetrically encrypted value. This structure is defined for the limited purpose of determining the size of a TPM2B_ENCRYPTED_SECRET.
class TPMU_ENCRYPTED_SECRET(TpmUnion):
    pass

# This is the union of all values allowed in in the unique field of a TPMT_PUBLIC.
class TPMU_PUBLIC_ID(TpmUnion):
    pass

# Table 189 defines the possible parameter definition structures that may be contained in the public portion of a key. If the Object can be a parent, the first field must be a TPMT_SYM_DEF_OBJECT. See 11.1.7.
class TPMU_PUBLIC_PARMS(TpmUnion):
    pass

# Table 195 Definition of TPMU_SENSITIVE_COMPOSITE Union (IN/OUT, S)
class TPMU_SENSITIVE_COMPOSITE(TpmUnion):
    pass

# selector: TPM_ALG_ID | TPM_CAP | TPM_ST
def createUnion(unionType, selector):
    if unionType == 'TPMU_CAPABILITIES':
        if selector == TPM_CAP.ALGS: return TPML_ALG_PROPERTY()
        elif selector == TPM_CAP.HANDLES: return TPML_HANDLE()
        elif selector == TPM_CAP.COMMANDS: return TPML_CCA()
        elif selector == TPM_CAP.PP_COMMANDS: return TPML_CC()
        elif selector == TPM_CAP.AUDIT_COMMANDS: return TPML_CC()
        elif selector == TPM_CAP.PCRS: return TPML_PCR_SELECTION()
        elif selector == TPM_CAP.TPM_PROPERTIES: return TPML_TAGGED_TPM_PROPERTY()
        elif selector == TPM_CAP.PCR_PROPERTIES: return TPML_TAGGED_PCR_PROPERTY()
        elif selector == TPM_CAP.ECC_CURVES: return TPML_ECC_CURVE()
        elif selector == TPM_CAP.AUTH_POLICIES: return TPML_TAGGED_POLICY()
    elif unionType == 'TPMU_ATTEST':
        if selector == TPM_ST.ATTEST_CERTIFY: return TPMS_CERTIFY_INFO()
        elif selector == TPM_ST.ATTEST_CREATION: return TPMS_CREATION_INFO()
        elif selector == TPM_ST.ATTEST_QUOTE: return TPMS_QUOTE_INFO()
        elif selector == TPM_ST.ATTEST_COMMAND_AUDIT: return TPMS_COMMAND_AUDIT_INFO()
        elif selector == TPM_ST.ATTEST_SESSION_AUDIT: return TPMS_SESSION_AUDIT_INFO()
        elif selector == TPM_ST.ATTEST_TIME: return TPMS_TIME_ATTEST_INFO()
        elif selector == TPM_ST.ATTEST_NV: return TPMS_NV_CERTIFY_INFO()
    elif unionType == 'TPMU_SYM_DETAILS':
        if selector == TPM_ALG_ID.TDES: return TPMS_TDES_SYM_DETAILS()
        elif selector == TPM_ALG_ID.AES: return TPMS_AES_SYM_DETAILS()
        elif selector == TPM_ALG_ID.SM4: return TPMS_SM4_SYM_DETAILS()
        elif selector == TPM_ALG_ID.CAMELLIA: return TPMS_CAMELLIA_SYM_DETAILS()
        elif selector == TPM_ALG_ID.ANY: return TPMS_ANY_SYM_DETAILS()
        elif selector == TPM_ALG_ID.XOR: return TPMS_XOR_SYM_DETAILS()
        elif selector == TPM_ALG_ID.NULL: return TPMS_NULL_SYM_DETAILS()
    elif unionType == 'TPMU_SENSITIVE_CREATE':
        if selector == TPM_ALG_ID.ANY: return None
        elif selector == TPM_ALG_ID.ANY2: return TPMS_DERIVE()
    elif unionType == 'TPMU_SCHEME_KEYEDHASH':
        if selector == TPM_ALG_ID.HMAC: return TPMS_SCHEME_HMAC()
        elif selector == TPM_ALG_ID.XOR: return TPMS_SCHEME_XOR()
        elif selector == TPM_ALG_ID.NULL: return TPMS_NULL_SCHEME_KEYEDHASH()
    elif unionType == 'TPMU_SIG_SCHEME':
        if selector == TPM_ALG_ID.RSASSA: return TPMS_SIG_SCHEME_RSASSA()
        elif selector == TPM_ALG_ID.RSAPSS: return TPMS_SIG_SCHEME_RSAPSS()
        elif selector == TPM_ALG_ID.ECDSA: return TPMS_SIG_SCHEME_ECDSA()
        elif selector == TPM_ALG_ID.ECDAA: return TPMS_SIG_SCHEME_ECDAA()
        elif selector == TPM_ALG_ID.SM2: return TPMS_SIG_SCHEME_SM2()
        elif selector == TPM_ALG_ID.ECSCHNORR: return TPMS_SIG_SCHEME_ECSCHNORR()
        elif selector == TPM_ALG_ID.HMAC: return TPMS_SCHEME_HMAC()
        elif selector == TPM_ALG_ID.ANY: return TPMS_SCHEME_HASH()
        elif selector == TPM_ALG_ID.NULL: return TPMS_NULL_SIG_SCHEME()
    elif unionType == 'TPMU_KDF_SCHEME':
        if selector == TPM_ALG_ID.MGF1: return TPMS_SCHEME_MGF1()
        elif selector == TPM_ALG_ID.KDF1_SP800_56A: return TPMS_SCHEME_KDF1_SP800_56A()
        elif selector == TPM_ALG_ID.KDF2: return TPMS_SCHEME_KDF2()
        elif selector == TPM_ALG_ID.KDF1_SP800_108: return TPMS_SCHEME_KDF1_SP800_108()
        elif selector == TPM_ALG_ID.NULL: return TPMS_NULL_KDF_SCHEME()
    elif unionType == 'TPMU_ASYM_SCHEME':
        if selector == TPM_ALG_ID.ECDH: return TPMS_KEY_SCHEME_ECDH()
        elif selector == TPM_ALG_ID.ECMQV: return TPMS_KEY_SCHEME_ECMQV()
        elif selector == TPM_ALG_ID.RSASSA: return TPMS_SIG_SCHEME_RSASSA()
        elif selector == TPM_ALG_ID.RSAPSS: return TPMS_SIG_SCHEME_RSAPSS()
        elif selector == TPM_ALG_ID.ECDSA: return TPMS_SIG_SCHEME_ECDSA()
        elif selector == TPM_ALG_ID.ECDAA: return TPMS_SIG_SCHEME_ECDAA()
        elif selector == TPM_ALG_ID.SM2: return TPMS_SIG_SCHEME_SM2()
        elif selector == TPM_ALG_ID.ECSCHNORR: return TPMS_SIG_SCHEME_ECSCHNORR()
        elif selector == TPM_ALG_ID.RSAES: return TPMS_ENC_SCHEME_RSAES()
        elif selector == TPM_ALG_ID.OAEP: return TPMS_ENC_SCHEME_OAEP()
        elif selector == TPM_ALG_ID.ANY: return TPMS_SCHEME_HASH()
        elif selector == TPM_ALG_ID.NULL: return TPMS_NULL_ASYM_SCHEME()
    elif unionType == 'TPMU_SIGNATURE':
        if selector == TPM_ALG_ID.RSASSA: return TPMS_SIGNATURE_RSASSA()
        elif selector == TPM_ALG_ID.RSAPSS: return TPMS_SIGNATURE_RSAPSS()
        elif selector == TPM_ALG_ID.ECDSA: return TPMS_SIGNATURE_ECDSA()
        elif selector == TPM_ALG_ID.ECDAA: return TPMS_SIGNATURE_ECDAA()
        elif selector == TPM_ALG_ID.SM2: return TPMS_SIGNATURE_SM2()
        elif selector == TPM_ALG_ID.ECSCHNORR: return TPMS_SIGNATURE_ECSCHNORR()
        elif selector == TPM_ALG_ID.HMAC: return TPMT_HA()
        elif selector == TPM_ALG_ID.ANY: return TPMS_SCHEME_HASH()
        elif selector == TPM_ALG_ID.NULL: return TPMS_NULL_SIGNATURE()
    elif unionType == 'TPMU_PUBLIC_ID':
        if selector == TPM_ALG_ID.KEYEDHASH: return TPM2B_DIGEST_Keyedhash()
        elif selector == TPM_ALG_ID.SYMCIPHER: return TPM2B_DIGEST_Symcipher()
        elif selector == TPM_ALG_ID.RSA: return TPM2B_PUBLIC_KEY_RSA()
        elif selector == TPM_ALG_ID.ECC: return TPMS_ECC_POINT()
        elif selector == TPM_ALG_ID.ANY: return TPMS_DERIVE()
    elif unionType == 'TPMU_PUBLIC_PARMS':
        if selector == TPM_ALG_ID.KEYEDHASH: return TPMS_KEYEDHASH_PARMS()
        elif selector == TPM_ALG_ID.SYMCIPHER: return TPMS_SYMCIPHER_PARMS()
        elif selector == TPM_ALG_ID.RSA: return TPMS_RSA_PARMS()
        elif selector == TPM_ALG_ID.ECC: return TPMS_ECC_PARMS()
        elif selector == TPM_ALG_ID.ANY: return TPMS_ASYM_PARMS()
    elif unionType == 'TPMU_SENSITIVE_COMPOSITE':
        if selector == TPM_ALG_ID.RSA: return TPM2B_PRIVATE_KEY_RSA()
        elif selector == TPM_ALG_ID.ECC: return TPM2B_ECC_PARAMETER()
        elif selector == TPM_ALG_ID.KEYEDHASH: return TPM2B_SENSITIVE_DATA()
        elif selector == TPM_ALG_ID.SYMCIPHER: return TPM2B_SYM_KEY()
        elif selector == TPM_ALG_ID.ANY: return TPM2B_PRIVATE_VENDOR_SPECIFIC()
    else:
        raise(Exception('CreateUnion(' + unionType + ', ' + str(selector) + '): Unrecognized union type'))
    raise(Exception('Unknown selector value' + str(selector) + ' for ' + unionType +  ' union'))
# createUnion()

# Base class for empty union elements. An empty union element does not contain any data to marshal. This data structure can be used in place of any other union initialized with its own empty element.
class TPMS_NULL_UNION(TpmStructure, TPMU_SYM_KEY_BITS, TPMU_SYM_MODE, TPMU_SYM_DETAILS, TPMU_SCHEME_KEYEDHASH, TPMU_SIG_SCHEME, TPMU_KDF_SCHEME, TPMU_ASYM_SCHEME, TPMU_SIGNATURE ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.NULL
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# TPMS_NULL_UNION

# TPM Hash structure
class TPMT_HA(TpmStructure, TPMU_SIGNATURE):
    def __init__(self,
        # Algorithm
        hashAlg = 0,
        # Hash value
        digest = None
    ): 
        self.init()
        self.hashAlg = hashAlg
        self.digest = digest
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.HMAC
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.hashAlg, 2)
        buf.toTpm2B(this.digest)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.hashAlg = buf.fromTpm(2)
        this.digest = buf.bufferFromTpm(Crypto.digestSize(this.hashAlg))
    
    
# TPMT_HA

# TPM object handle (and related data)
class TPM_HANDLE(TpmStructure):
    def __init__(self,
        # TPM key handle
        handle = 0
    ): 
        self.init()
        self.handle = handle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.handle, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.fromTpm(4)
    
    
    
    # The following static members represent TPM_RH constants
    NULL = None
    OWNER = None
    PLATFORM = None
    ENDORSEMENT = None
    
    def init(self):
        # Authorization value associated with this handle object.
        self.authValue = None
    
        # Name of the TPM entity represented by this handle object.
        self.name = None
        
    # Creates a TPM handle from an arbitrary int value
    # @param val An int value to be used as a TPM handle
    # @return New TPM_HANDLE object
    @staticmethod
    def fromValue(val):
        return TPM_HANDLE(val)
    
    # Creates a TPM_HANDLE from an offset into the reserved handle space
    # @param handleOffset The reserved handle offset
    # @return The new TPM_HANDLE 
    @staticmethod
    def persistent(handleOffset):
        return TPM_HANDLE((TPM_HT.PERSISTENT << 24) + handleOffset)
    
    # Creates a TPM_HANDLE object for a PCR
    # @param PcrIndex The PCR index
    # @return The new TPM_HANDLE 
    @staticmethod
    def pcr(pcrIndex):
        return TPM_HANDLE(pcrIndex);
    
    # Creates a TPM_HANDLE for an NV slot
    # @param NvSlot The NV index
    # @return The new TPM_HANDLE 
    @staticmethod
    def nv(nvIndex):
        return TPM_HANDLE((TPM_HT.NV_INDEX << 24) + nvIndex)
    
    # Creates a password session handle with the associated authorization value
    # @param authValue The authorization value
    # @return The new TPM_HANDLE 
    @staticmethod
    def pwSession(authValue):
        pwapHandle = TPM_HANDLE(TPM_RH.RS_PW)
        pwapHandle.authValue = authValue
        return pwapHandle
    
    # @return The handle type
    def getType():
        return TPM_HT(this.handle >> 24)
    
    # Gets the TPM-name associated with this handle
    # @return The name
    def getName(self):
        t = self.getType()
        if t == 0 or t == 2 or t == 3 or t == 0x40:
            self.name = this.asTpm()
            return self.name
        elif t == 1 or t == 0x80 or t == 0x81:
            return self.name
        else:
            raise(Exception("TPM_HANDLE.getName(): Unknown handle type"))
    
# TPM_HANDLE

# This structure is used as a placeholder. In some cases, a union will have a selector value with no data to unmarshal when that type is selected. Rather than leave the entry empty, TPMS_EMPTY may be selected.
class TPMS_EMPTY(TpmStructure, TPMU_ASYM_SCHEME ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.RSAES
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# TPMS_EMPTY

# This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms.
class TPMS_ALGORITHM_DESCRIPTION(TpmStructure):
    def __init__(self,
        # an algorithm
        alg = 0,
        # the attributes of the algorithm
        attributes = 0
    ): 
        self.init()
        self.alg = alg
        self.attributes = attributes
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.alg, 2)
        buf.toTpm(this.attributes, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.alg = buf.fromTpm(2)
        this.attributes = buf.fromTpm(4)
    
    
# TPMS_ALGORITHM_DESCRIPTION

# This structure is used for a sized buffer that cannot be larger than the largest digest produced by any hash algorithm implemented on the TPM.
class TPM2B_DIGEST(TpmStructure, TPMU_PUBLIC_ID ):
    def __init__(self,
        # the buffer area that can be no larger than a digest
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.KEYEDHASH
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_DIGEST

# This structure is used for a data buffer that is required to be no larger than the size of the Name of an object.
class TPM2B_DATA(TpmStructure):
    def __init__(self,
        # -
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_DATA

# Table 76 Definition of Types for TPM2B_NONCE
class TPM2B_NONCE(TPM2B_DIGEST):
    def __init__(self,
        # the buffer area that can be no larger than a digest
        buffer = None
    ): 
        super(TPM2B_NONCE, self).__init__(buffer)
        self.init()
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPM2B_NONCE, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPM2B_NONCE, self).fromTpm(buf)
    
    
# TPM2B_NONCE

# This structure is used for an authorization value and limits an authValue to being no larger than the largest digest produced by a TPM. In order to ensure consistency within an object, the authValue may be no larger than the size of the digest produced by the objects nameAlg. This ensures that any TPM that can load the object will be able to handle the authValue of the object.
class TPM2B_AUTH(TPM2B_DIGEST):
    def __init__(self,
        # the buffer area that can be no larger than a digest
        buffer = None
    ): 
        super(TPM2B_AUTH, self).__init__(buffer)
        self.init()
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPM2B_AUTH, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPM2B_AUTH, self).fromTpm(buf)
    
    
# TPM2B_AUTH

# This type is a sized buffer that can hold an operand for a comparison with an NV Index location. The maximum size of the operand is implementation dependent but a TPM is required to support an operand size that is at least as big as the digest produced by any of the hash algorithms implemented on the TPM.
class TPM2B_OPERAND(TPM2B_DIGEST):
    def __init__(self,
        # the buffer area that can be no larger than a digest
        buffer = None
    ): 
        super(TPM2B_OPERAND, self).__init__(buffer)
        self.init()
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPM2B_OPERAND, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPM2B_OPERAND, self).fromTpm(buf)
    
    
# TPM2B_OPERAND

# This type is a sized buffer that can hold event data.
class TPM2B_EVENT(TpmStructure):
    def __init__(self,
        # the operand
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_EVENT

# This type is a sized buffer that can hold a maximally sized buffer for commands that use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData().
class TPM2B_MAX_BUFFER(TpmStructure):
    def __init__(self,
        # the operand
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_MAX_BUFFER

# This type is a sized buffer that can hold a maximally sized buffer for NV data commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify().
class TPM2B_MAX_NV_BUFFER(TpmStructure):
    def __init__(self,
        # the operand NOTE MAX_NV_BUFFER_SIZE is TPM-dependent
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_MAX_NV_BUFFER

# This TPM-dependent structure is used to provide the timeout value for an authorization. The size shall be 8 or less.
class TPM2B_TIMEOUT(TpmStructure):
    def __init__(self,
        # the timeout value
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_TIMEOUT

# This structure is used for passing an initial value for a symmetric block cipher to or from the TPM. The size is set to be the largest block size of any implemented symmetric cipher implemented on the TPM.
class TPM2B_IV(TpmStructure):
    def __init__(self,
        # the IV value
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_IV

# This buffer holds a Name for any entity type.
class TPM2B_NAME(TpmStructure):
    def __init__(self,
        # the Name structure
        name = None
    ): 
        self.init()
        self.name = name
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.name)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.name = buf.fromTpm2B(2)
    
    
# TPM2B_NAME

# This structure provides a standard method of specifying a list of PCR.
class TPMS_PCR_SELECT(TpmStructure):
    def __init__(self,
        # the bit map of selected PCR
        pcrSelect = None
    ): 
        self.init()
        self.pcrSelect = pcrSelect
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.pcrSelect)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.pcrSelect = buf.fromTpm2B(1)
    
    
# TPMS_PCR_SELECT

# Table 87 Definition of TPMS_PCR_SELECTION Structure
class TPMS_PCR_SELECTION(TpmStructure):
    def __init__(self,
        # the hash algorithm associated with the selection
        hash = 0,
        # the bit map of selected PCR
        pcrSelect = None
    ): 
        self.init()
        self.hash = hash
        self.pcrSelect = pcrSelect
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.hash, 2)
        buf.toTpm2B(this.pcrSelect)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.hash = buf.fromTpm(2)
        this.pcrSelect = buf.fromTpm2B(1)
    
    
# TPMS_PCR_SELECTION

# This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind the creation data to the object to which it applies. The ticket is computed by
class TPMT_TK_CREATION(TpmStructure):
    def __init__(self,
        # ticket structure tag
        tag = 0,
        # the hierarchy containing name
        hierarchy = None,
        # This shall be the HMAC produced using a proof value of hierarchy.
        digest = None
    ): 
        self.init()
        self.tag = tag
        self.hierarchy = hierarchy
        self.digest = digest
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.tag, 2)
        this.hierarchy.toTpm(buf)
        buf.toTpm2B(this.digest)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.hierarchy = buf.createFromTpm(TPM_HANDLE)
        this.digest = buf.fromTpm2B(2)
    
    
# TPMT_TK_CREATION

# This ticket is produced by TPM2_VerifySignature(). This formulation is used for multiple ticket uses. The ticket provides evidence that the TPM has validated that a digest was signed by a key with the Name of keyName. The ticket is computed by
class TPMT_TK_VERIFIED(TpmStructure):
    def __init__(self,
        # ticket structure tag
        tag = 0,
        # the hierarchy containing keyName
        hierarchy = None,
        # This shall be the HMAC produced using a proof value of hierarchy.
        digest = None
    ): 
        self.init()
        self.tag = tag
        self.hierarchy = hierarchy
        self.digest = digest
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.tag, 2)
        this.hierarchy.toTpm(buf)
        buf.toTpm2B(this.digest)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.hierarchy = buf.createFromTpm(TPM_HANDLE)
        this.digest = buf.fromTpm2B(2)
    
    
# TPMT_TK_VERIFIED

# This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the authorization has an expiration time. If nonceTPM was provided in the policy command, the ticket is computed by
class TPMT_TK_AUTH(TpmStructure):
    def __init__(self,
        # ticket structure tag
        tag = 0,
        # the hierarchy of the object used to produce the ticket
        hierarchy = None,
        # This shall be the HMAC produced using a proof value of hierarchy.
        digest = None
    ): 
        self.init()
        self.tag = tag
        self.hierarchy = hierarchy
        self.digest = digest
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.tag, 2)
        this.hierarchy.toTpm(buf)
        buf.toTpm2B(this.digest)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.tag = buf.fromTpm(2)
        this.hierarchy = buf.createFromTpm(TPM_HANDLE)
        this.digest = buf.fromTpm2B(2)
    
    
# TPMT_TK_AUTH

# This ticket is produced by TPM2_SequenceComplete() when the message that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by
class TPMT_TK_HASHCHECK(TpmStructure):
    def __init__(self,
        # ticket structure tag
        tag = 0,
        # the hierarchy
        hierarchy = None,
        # This shall be the HMAC produced using a proof value of hierarchy.
        digest = None
    ): 
        self.init()
        self.tag = tag
        self.hierarchy = hierarchy
        self.digest = digest
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.tag, 2)
        this.hierarchy.toTpm(buf)
        buf.toTpm2B(this.digest)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.hierarchy = buf.createFromTpm(TPM_HANDLE)
        this.digest = buf.fromTpm2B(2)
    
    
    
    # Create a NULL ticket (e.g. used for signing data with non-restricted keys)
    # @return The null ticket
    @staticmethod
    def nullTicket():
        tk = TPMT_TK_HASHCHECK()
        tk.tag = TPM_ST.HASHCHECK
        tk.hierarchy = TPM_HANDLE.fromValue(TPM_RH.OWNER)
        return tk
    
# TPMT_TK_HASHCHECK

# This structure is used to report the properties of an algorithm identifier. It is returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG.
class TPMS_ALG_PROPERTY(TpmStructure):
    def __init__(self,
        # an algorithm identifier
        alg = 0,
        # the attributes of the algorithm
        algProperties = 0
    ): 
        self.init()
        self.alg = alg
        self.algProperties = algProperties
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.alg, 2)
        buf.toTpm(this.algProperties, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.alg = buf.fromTpm(2)
        this.algProperties = buf.fromTpm(4)
    
    
# TPMS_ALG_PROPERTY

# This structure is used to report the properties that are UINT32 values. It is returned in response to a TPM2_GetCapability().
class TPMS_TAGGED_PROPERTY(TpmStructure):
    def __init__(self,
        # a property identifier
        property = 0,
        # the value of the property
        value = 0
    ): 
        self.init()
        self.property = property
        self.value = value
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.property, 4)
        buf.toTpm(this.value, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.property = buf.fromTpm(4)
        this.value = buf.fromTpm(4)
    
    
# TPMS_TAGGED_PROPERTY

# This structure is used in TPM2_GetCapability() to return the attributes of the PCR.
class TPMS_TAGGED_PCR_SELECT(TpmStructure):
    def __init__(self,
        # the property identifier
        tag = 0,
        # the bit map of PCR with the identified property
        pcrSelect = None
    ): 
        self.init()
        self.tag = tag
        self.pcrSelect = pcrSelect
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.tag, 4)
        buf.toTpm2B(this.pcrSelect)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.tag = buf.fromTpm(4)
        this.pcrSelect = buf.fromTpm2B(1)
    
    
# TPMS_TAGGED_PCR_SELECT

# This structure is used in TPM2_GetCapability() to return the policy associated with a permanent handle.
class TPMS_TAGGED_POLICY(TpmStructure):
    def __init__(self,
        # a permanent handle
        handle = None,
        # the policy algorithm and hash
        policyHash = None
    ): 
        self.init()
        self.handle = handle
        self.policyHash = policyHash
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.handle.toTpm(buf)
        this.policyHash.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.createFromTpm(TPM_HANDLE)
        this.policyHash = buf.createFromTpm(TPMT_HA)
    
    
# TPMS_TAGGED_POLICY

# A list of command codes may be input to the TPM or returned by the TPM depending on the command.
class TPML_CC(TpmStructure, TPMU_CAPABILITIES ):
    def __init__(self,
        # a list of command codes The maximum only applies to a command code list in a command. The response size is limited only by the size of the parameter buffer.
        commandCodes = None
    ): 
        self.init()
        self.commandCodes = commandCodes
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_CAP.PP_COMMANDS
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.valArrToTpm(this.commandCodes, 4, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.commandCodes = buf.valArrFromTpm(4, 4)
    
    
# TPML_CC

# This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS).
class TPML_CCA(TpmStructure, TPMU_CAPABILITIES ):
    def __init__(self,
        # a list of command codes attributes
        commandAttributes = None
    ): 
        self.init()
        self.commandAttributes = commandAttributes
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_CAP.COMMANDS
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.valArrToTpm(this.commandAttributes, 4, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.commandAttributes = buf.valArrFromTpm(4, 4)
    
    
# TPML_CCA

# This list is returned by TPM2_IncrementalSelfTest().
class TPML_ALG(TpmStructure):
    def __init__(self,
        # a list of algorithm IDs The maximum only applies to an algorithm list in a command. The response size is limited only by the size of the parameter buffer.
        algorithms = None
    ): 
        self.init()
        self.algorithms = algorithms
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.valArrToTpm(this.algorithms, 2, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.algorithms = buf.valArrFromTpm(2, 4)
    
    
# TPML_ALG

# This structure is used when the TPM returns a list of loaded handles when the capability in TPM2_GetCapability() is TPM_CAP_HANDLE.
class TPML_HANDLE(TpmStructure, TPMU_CAPABILITIES ):
    def __init__(self,
        # an array of handles
        handle = None
    ): 
        self.init()
        self.handle = handle
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_CAP.HANDLES
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.handle, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.arrayFromTpm(TPM_HANDLE, 4)
    
    
# TPML_HANDLE

# This list is used to convey a list of digest values. This type is used in TPM2_PolicyOR() and in TPM2_PCR_Read().
class TPML_DIGEST(TpmStructure):
    def __init__(self,
        # a list of digests For TPM2_PolicyOR(), all digests will have been computed using the digest of the policy session. For TPM2_PCR_Read(), each digest will be the size of the digest for the bank containing the PCR.
        digests = None
    ): 
        self.init()
        self.digests = digests
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.digests, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.digests = buf.arrayFromTpm(TPM2B_DIGEST, 4)
    
    
# TPML_DIGEST

# This list is used to convey a list of digest values. This type is returned by TPM2_Event() and TPM2_SequenceComplete() and is an input for TPM2_PCR_Extend().
class TPML_DIGEST_VALUES(TpmStructure):
    def __init__(self,
        # a list of tagged digests
        digests = None
    ): 
        self.init()
        self.digests = digests
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.digests, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.digests = buf.arrayFromTpm(TPMT_HA, 4)
    
    
# TPML_DIGEST_VALUES

# This list is used to indicate the PCR that are included in a selection when more than one PCR value may be selected.
class TPML_PCR_SELECTION(TpmStructure, TPMU_CAPABILITIES ):
    def __init__(self,
        # list of selections
        pcrSelections = None
    ): 
        self.init()
        self.pcrSelections = pcrSelections
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_CAP.PCRS
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.pcrSelections, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.pcrSelections = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4)
    
    
# TPML_PCR_SELECTION

# This list is used to report on a list of algorithm attributes. It is returned in a TPM2_GetCapability().
class TPML_ALG_PROPERTY(TpmStructure, TPMU_CAPABILITIES ):
    def __init__(self,
        # list of properties
        algProperties = None
    ): 
        self.init()
        self.algProperties = algProperties
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_CAP.ALGS
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.algProperties, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.algProperties = buf.arrayFromTpm(TPMS_ALG_PROPERTY, 4)
    
    
# TPML_ALG_PROPERTY

# This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY values. It is returned by a TPM2_GetCapability().
class TPML_TAGGED_TPM_PROPERTY(TpmStructure, TPMU_CAPABILITIES ):
    def __init__(self,
        # an array of tagged properties
        tpmProperty = None
    ): 
        self.init()
        self.tpmProperty = tpmProperty
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_CAP.TPM_PROPERTIES
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.tpmProperty, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.tpmProperty = buf.arrayFromTpm(TPMS_TAGGED_PROPERTY, 4)
    
    
# TPML_TAGGED_TPM_PROPERTY

# This list is used to report on a list of properties that are TPMS_PCR_SELECT values. It is returned by a TPM2_GetCapability().
class TPML_TAGGED_PCR_PROPERTY(TpmStructure, TPMU_CAPABILITIES ):
    def __init__(self,
        # a tagged PCR selection
        pcrProperty = None
    ): 
        self.init()
        self.pcrProperty = pcrProperty
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_CAP.PCR_PROPERTIES
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.pcrProperty, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.pcrProperty = buf.arrayFromTpm(TPMS_TAGGED_PCR_SELECT, 4)
    
    
# TPML_TAGGED_PCR_PROPERTY

# This list is used to report the ECC curve ID values supported by the TPM. It is returned by a TPM2_GetCapability().
class TPML_ECC_CURVE(TpmStructure, TPMU_CAPABILITIES ):
    def __init__(self,
        # array of ECC curve identifiers
        eccCurves = None
    ): 
        self.init()
        self.eccCurves = eccCurves
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_CAP.ECC_CURVES
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.valArrToTpm(this.eccCurves, 2, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.eccCurves = buf.valArrFromTpm(2, 4)
    
    
# TPML_ECC_CURVE

# This list is used to report the authorization policy values for permanent handles. This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot have a policy is not included in the list.
class TPML_TAGGED_POLICY(TpmStructure, TPMU_CAPABILITIES ):
    def __init__(self,
        # array of tagged policies
        policies = None
    ): 
        self.init()
        self.policies = policies
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_CAP.AUTH_POLICIES
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.policies, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policies = buf.arrayFromTpm(TPMS_TAGGED_POLICY, 4)
    
    
# TPML_TAGGED_POLICY

# This data area is returned in response to a TPM2_GetCapability().
class TPMS_CAPABILITY_DATA(TpmStructure):
    def __init__(self,
        # the capability data (One of TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_CC, TPML_PCR_SELECTION, TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE, TPML_TAGGED_POLICY)
        data = None
    ): 
        self.init()
        self.data = data
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.data.GetUnionSelector(), 4)
        this.data.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        capability = buf.fromTpm(4)
        this.data = createUnion('TPMU_CAPABILITIES', capability)
        this.data.fromTpm(buf)
    
    
# TPMS_CAPABILITY_DATA

# This structure is used in each of the attestation commands.
class TPMS_CLOCK_INFO(TpmStructure):
    def __init__(self,
        # time value in milliseconds that advances while the TPM is powered NOTE The interpretation of the time-origin (clock=0) is out of the scope of this specification, although Coordinated Universal Time (UTC) is expected to be a common convention. This structure element is used to report on the TPM's Clock value. This value is reset to zero when the Storage Primary Seed is changed (TPM2_Clear()). This value may be advanced by TPM2_ClockSet().
        clock = 0,
        # number of occurrences of TPM Reset since the last TPM2_Clear()
        resetCount = 0,
        # number of times that TPM2_Shutdown() or _TPM_Hash_Start have occurred since the last TPM Reset or TPM2_Clear().
        restartCount = 0,
        # no value of Clock greater than the current value of Clock has been previously reported by the TPM. Set to YES on TPM2_Clear().
        safe = 0
    ): 
        self.init()
        self.clock = clock
        self.resetCount = resetCount
        self.restartCount = restartCount
        self.safe = safe
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.clock, 8)
        buf.toTpm(this.resetCount, 4)
        buf.toTpm(this.restartCount, 4)
        buf.toTpm(this.safe, 1)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.clock = buf.fromTpm(8)
        this.resetCount = buf.fromTpm(4)
        this.restartCount = buf.fromTpm(4)
        this.safe = buf.fromTpm(1)
    
    
# TPMS_CLOCK_INFO

# This structure is used in the TPM2_GetTime() attestation.
class TPMS_TIME_INFO(TpmStructure):
    def __init__(self,
        # time in milliseconds since the last _TPM_Init() or TPM2_Startup() This structure element is used to report on the TPM's Time value.
        time = 0,
        # a structure containing the clock information
        clockInfo = None
    ): 
        self.init()
        self.time = time
        self.clockInfo = clockInfo
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.time, 8)
        this.clockInfo.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.time = buf.fromTpm(8)
        this.clockInfo = buf.createFromTpm(TPMS_CLOCK_INFO)
    
    
# TPMS_TIME_INFO

# This structure is used when the TPM performs TPM2_GetTime.
class TPMS_TIME_ATTEST_INFO(TpmStructure, TPMU_ATTEST ):
    def __init__(self,
        # the Time, Clock, resetCount, restartCount, and Safe indicator
        time = None,
        # a TPM vendor-specific value indicating the version number of the firmware
        firmwareVersion = 0
    ): 
        self.init()
        self.time = time
        self.firmwareVersion = firmwareVersion
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ST.ATTEST_TIME
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.time.toTpm(buf)
        buf.toTpm(this.firmwareVersion, 8)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.time = buf.createFromTpm(TPMS_TIME_INFO)
        this.firmwareVersion = buf.fromTpm(8)
    
    
# TPMS_TIME_ATTEST_INFO

# This is the attested data for TPM2_Certify().
class TPMS_CERTIFY_INFO(TpmStructure, TPMU_ATTEST ):
    def __init__(self,
        # Name of the certified object
        name = None,
        # Qualified Name of the certified object
        qualifiedName = None
    ): 
        self.init()
        self.name = name
        self.qualifiedName = qualifiedName
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ST.ATTEST_CERTIFY
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.name)
        buf.toTpm2B(this.qualifiedName)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.name = buf.fromTpm2B(2)
        this.qualifiedName = buf.fromTpm2B(2)
    
    
# TPMS_CERTIFY_INFO

# This is the attested data for TPM2_Quote().
class TPMS_QUOTE_INFO(TpmStructure, TPMU_ATTEST ):
    def __init__(self,
        # information on algID, PCR selected and digest
        pcrSelect = None,
        # digest of the selected PCR using the hash of the signing key
        pcrDigest = None
    ): 
        self.init()
        self.pcrSelect = pcrSelect
        self.pcrDigest = pcrDigest
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ST.ATTEST_QUOTE
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.pcrSelect, 4)
        buf.toTpm2B(this.pcrDigest)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.pcrSelect = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4)
        this.pcrDigest = buf.fromTpm2B(2)
    
    
# TPMS_QUOTE_INFO

# This is the attested data for TPM2_GetCommandAuditDigest().
class TPMS_COMMAND_AUDIT_INFO(TpmStructure, TPMU_ATTEST ):
    def __init__(self,
        # the monotonic audit counter
        auditCounter = 0,
        # hash algorithm used for the command audit
        digestAlg = 0,
        # the current value of the audit digest
        auditDigest = None,
        # digest of the command codes being audited using digestAlg
        commandDigest = None
    ): 
        self.init()
        self.auditCounter = auditCounter
        self.digestAlg = digestAlg
        self.auditDigest = auditDigest
        self.commandDigest = commandDigest
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ST.ATTEST_COMMAND_AUDIT
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.auditCounter, 8)
        buf.toTpm(this.digestAlg, 2)
        buf.toTpm2B(this.auditDigest)
        buf.toTpm2B(this.commandDigest)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.auditCounter = buf.fromTpm(8)
        this.digestAlg = buf.fromTpm(2)
        this.auditDigest = buf.fromTpm2B(2)
        this.commandDigest = buf.fromTpm2B(2)
    
    
# TPMS_COMMAND_AUDIT_INFO

# This is the attested data for TPM2_GetSessionAuditDigest().
class TPMS_SESSION_AUDIT_INFO(TpmStructure, TPMU_ATTEST ):
    def __init__(self,
        # current exclusive status of the session TRUE if all of the commands recorded in the sessionDigest were executed without any intervening TPM command that did not use this audit session
        exclusiveSession = 0,
        # the current value of the session audit digest
        sessionDigest = None
    ): 
        self.init()
        self.exclusiveSession = exclusiveSession
        self.sessionDigest = sessionDigest
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ST.ATTEST_SESSION_AUDIT
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.exclusiveSession, 1)
        buf.toTpm2B(this.sessionDigest)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.exclusiveSession = buf.fromTpm(1)
        this.sessionDigest = buf.fromTpm2B(2)
    
    
# TPMS_SESSION_AUDIT_INFO

# This is the attested data for TPM2_CertifyCreation().
class TPMS_CREATION_INFO(TpmStructure, TPMU_ATTEST ):
    def __init__(self,
        # Name of the object
        objectName = None,
        # creationHash
        creationHash = None
    ): 
        self.init()
        self.objectName = objectName
        self.creationHash = creationHash
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ST.ATTEST_CREATION
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.objectName)
        buf.toTpm2B(this.creationHash)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.objectName = buf.fromTpm2B(2)
        this.creationHash = buf.fromTpm2B(2)
    
    
# TPMS_CREATION_INFO

# This structure contains the Name and contents of the selected NV Index that is certified by TPM2_NV_Certify().
class TPMS_NV_CERTIFY_INFO(TpmStructure, TPMU_ATTEST ):
    def __init__(self,
        # Name of the NV Index
        indexName = None,
        # the offset parameter of TPM2_NV_Certify()
        offset = 0,
        # contents of the NV Index
        nvContents = None
    ): 
        self.init()
        self.indexName = indexName
        self.offset = offset
        self.nvContents = nvContents
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ST.ATTEST_NV
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.indexName)
        buf.toTpm(this.offset, 2)
        buf.toTpm2B(this.nvContents)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.indexName = buf.fromTpm2B(2)
        this.offset = buf.fromTpm(2)
        this.nvContents = buf.fromTpm2B(2)
    
    
# TPMS_NV_CERTIFY_INFO

# This structure is used on each TPM-generated signed structure. The signature is over this structure.
class TPMS_ATTEST(TpmStructure):
    def __init__(self,
        # the indication that this structure was created by a TPM (always TPM_GENERATED_VALUE)
        magic = 0,
        # Qualified Name of the signing key
        qualifiedSigner = None,
        # external information supplied by caller NOTE A TPM2B_DATA structure provides room for a digest and a method indicator to indicate the components of the digest. The definition of this method indicator is outside the scope of this specification.
        extraData = None,
        # Clock, resetCount, restartCount, and Safe
        clockInfo = None,
        # TPM-vendor-specific value identifying the version number of the firmware
        firmwareVersion = 0,
        # the type-specific attestation information (One of TPMS_CERTIFY_INFO, TPMS_CREATION_INFO, TPMS_QUOTE_INFO, TPMS_COMMAND_AUDIT_INFO, TPMS_SESSION_AUDIT_INFO, TPMS_TIME_ATTEST_INFO, TPMS_NV_CERTIFY_INFO)
        attested = None
    ): 
        self.init()
        self.magic = magic
        self.qualifiedSigner = qualifiedSigner
        self.extraData = extraData
        self.clockInfo = clockInfo
        self.firmwareVersion = firmwareVersion
        self.attested = attested
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.magic, 4)
        buf.toTpm(this.attested.GetUnionSelector(), 2)
        buf.toTpm2B(this.qualifiedSigner)
        buf.toTpm2B(this.extraData)
        this.clockInfo.toTpm(buf)
        buf.toTpm(this.firmwareVersion, 8)
        this.attested.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.magic = buf.fromTpm(4)
        type = buf.fromTpm(2)
        this.qualifiedSigner = buf.fromTpm2B(2)
        this.extraData = buf.fromTpm2B(2)
        this.clockInfo = buf.createFromTpm(TPMS_CLOCK_INFO)
        this.firmwareVersion = buf.fromTpm(8)
        this.attested = createUnion('TPMU_ATTEST', type)
        this.attested.fromTpm(buf)
    
    
# TPMS_ATTEST

# This sized buffer to contain the signed structure. The attestationData is the signed portion of the structure. The size parameter is not signed.
class TPM2B_ATTEST(TpmStructure):
    def __init__(self,
        # the signed structure
        attestationData = None
    ): 
        self.init()
        self.attestationData = attestationData
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.attestationData, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.attestationData = buf.sizedFromTpm(TPMS_ATTEST, 2)
    
    
# TPM2B_ATTEST

# This is the format used for each of the authorizations in the session area of a command.
class TPMS_AUTH_COMMAND(TpmStructure):
    def __init__(self,
        # the session handle
        sessionHandle = None,
        # the session nonce, may be the Empty Buffer
        nonce = None,
        # the session attributes
        sessionAttributes = 0,
        # either an HMAC, a password, or an EmptyAuth
        hmac = None
    ): 
        self.init()
        self.sessionHandle = sessionHandle
        self.nonce = nonce
        self.sessionAttributes = sessionAttributes
        self.hmac = hmac
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.sessionHandle.toTpm(buf)
        buf.toTpm2B(this.nonce)
        buf.toTpm(this.sessionAttributes, 1)
        buf.toTpm2B(this.hmac)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.sessionHandle = buf.createFromTpm(TPM_HANDLE)
        this.nonce = buf.fromTpm2B(2)
        this.sessionAttributes = buf.fromTpm(1)
        this.hmac = buf.fromTpm2B(2)
    
    
# TPMS_AUTH_COMMAND

# This is the format for each of the authorizations in the session area of the response. If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the same number of authorizations as the command and the authorizations are in the same order.
class TPMS_AUTH_RESPONSE(TpmStructure):
    def __init__(self,
        # the session nonce, may be the Empty Buffer
        nonce = None,
        # the session attributes
        sessionAttributes = 0,
        # either an HMAC or an EmptyAuth
        hmac = None
    ): 
        self.init()
        self.nonce = nonce
        self.sessionAttributes = sessionAttributes
        self.hmac = hmac
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.nonce)
        buf.toTpm(this.sessionAttributes, 1)
        buf.toTpm2B(this.hmac)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.nonce = buf.fromTpm2B(2)
        this.sessionAttributes = buf.fromTpm(1)
        this.hmac = buf.fromTpm2B(2)
    
    
# TPMS_AUTH_RESPONSE

# Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymKeyBits
class TPMS_NULL_SYM_KEY_BITS(TPMS_NULL_UNION, TPMU_SYM_KEY_BITS ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.NULL
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_NULL_SYM_KEY_BITS

# Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymMode
class TPMS_XOR_SYM_MODE(TPMS_NULL_UNION, TPMU_SYM_MODE ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.XOR
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_XOR_SYM_MODE

# Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymMode
class TPMS_NULL_SYM_MODE(TPMS_NULL_UNION, TPMU_SYM_MODE ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.NULL
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_NULL_SYM_MODE

# Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_TDES for the union TpmuSymDetails
class TPMS_TDES_SYM_DETAILS(TPMS_NULL_UNION, TPMU_SYM_DETAILS ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.TDES
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_TDES_SYM_DETAILS

# Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_AES for the union TpmuSymDetails
class TPMS_AES_SYM_DETAILS(TPMS_NULL_UNION, TPMU_SYM_DETAILS ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.AES
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_AES_SYM_DETAILS

# Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TpmuSymDetails
class TPMS_SM4_SYM_DETAILS(TPMS_NULL_UNION, TPMU_SYM_DETAILS ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.SM4
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_SM4_SYM_DETAILS

# Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TpmuSymDetails
class TPMS_CAMELLIA_SYM_DETAILS(TPMS_NULL_UNION, TPMU_SYM_DETAILS ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.CAMELLIA
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_CAMELLIA_SYM_DETAILS

# Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_ANY for the union TpmuSymDetails
class TPMS_ANY_SYM_DETAILS(TPMS_NULL_UNION, TPMU_SYM_DETAILS ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ANY
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_ANY_SYM_DETAILS

# Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymDetails
class TPMS_XOR_SYM_DETAILS(TPMS_NULL_UNION, TPMU_SYM_DETAILS ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.XOR
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_XOR_SYM_DETAILS

# Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymDetails
class TPMS_NULL_SYM_DETAILS(TPMS_NULL_UNION, TPMU_SYM_DETAILS ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.NULL
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_NULL_SYM_DETAILS

# The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter encryption in those cases when different symmetric algorithms may be selected.
class TPMT_SYM_DEF(TpmStructure):
    def __init__(self,
        # symmetric algorithm
        algorithm = 0,
        # key size in bits
        keyBits = 0,
        # encryption mode
        mode = 0
    ): 
        self.init()
        self.algorithm = algorithm
        self.keyBits = keyBits
        self.mode = mode
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.nonStandardToTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.nonStandardFromTpm(buf)
    
    
    
    # Create a NULL TPMT_SYM_DEF object
    # @return The null object
    @staticmethod
    def nullObject():
        return TPMT_SYM_DEF(TPM_ALG_ID.NULL, 0, TPM_ALG_ID.NULL)
    
    def nonStandardToTpm(self, buf):
        buf.toTpm(self.algorithm, 2);
        if (self.algorithm != TPM_ALG_ID.NULL):
            buf.toTpm(self.keyBits, 2);
            buf.toTpm(self.mode, 2);
    
    def nonStandardFromTpm(self, buf):
        self.algorithm = buf.fromTpm(2);
        if (self.algorithm != TPM_ALG_ID.NULL):
            self.keyBits = buf.fromTpm(2);
            self.mode = buf.fromTpm(2);
    
# TPMT_SYM_DEF

# This structure is used when different symmetric block cipher (not XOR) algorithms may be selected. If the Object can be an ordinary parent (not a derivation parent), this must be the first field in the Object's parameter (see 12.2.3.7) field.
class TPMT_SYM_DEF_OBJECT(TpmStructure):
    def __init__(self,
        # symmetric algorithm
        algorithm = 0,
        # key size in bits
        keyBits = 0,
        # encryption mode
        mode = 0
    ): 
        self.init()
        self.algorithm = algorithm
        self.keyBits = keyBits
        self.mode = mode
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.nonStandardToTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.nonStandardFromTpm(buf)
    
    
    
    # Create a NULL TPMT_SYM_DEF_OBJECT object
    # @return The null object
    @staticmethod
    def nullObject():
        return TPMT_SYM_DEF_OBJECT(TPM_ALG_ID.NULL, 0, TPM_ALG_ID.NULL)
    
    def nonStandardToTpm(self, buf):
        buf.toTpm(self.algorithm, 2);
        if (self.algorithm != TPM_ALG_ID.NULL):
            buf.toTpm(self.keyBits, 2);
            buf.toTpm(self.mode, 2);
    
    def nonStandardFromTpm(self, buf):
        self.algorithm = buf.fromTpm(2);
        if (self.algorithm != TPM_ALG_ID.NULL):
            self.keyBits = buf.fromTpm(2);
            self.mode = buf.fromTpm(2);
    
# TPMT_SYM_DEF_OBJECT

# This structure is used to hold a symmetric key in the sensitive area of an asymmetric object.
class TPM2B_SYM_KEY(TpmStructure, TPMU_SENSITIVE_COMPOSITE ):
    def __init__(self,
        # the key
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.SYMCIPHER
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_SYM_KEY

# This structure contains the parameters for a symmetric block cipher object.
class TPMS_SYMCIPHER_PARMS(TpmStructure, TPMU_PUBLIC_PARMS ):
    def __init__(self,
        # a symmetric block cipher
        sym = None
    ): 
        self.init()
        self.sym = sym
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.SYMCIPHER
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.sym.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.sym = buf.createFromTpm(TPMT_SYM_DEF_OBJECT)
    
    
# TPMS_SYMCIPHER_PARMS

# This buffer holds a label or context value. For interoperability and backwards compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes.
class TPM2B_LABEL(TpmStructure):
    def __init__(self,
        # symmetic data for a created object or the label and context for a derived object
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_LABEL

# This structure contains the label and context fields for a derived object. These values are used in the derivation KDF. The values in the unique field of inPublic area template take precedence over the values in the inSensitive parameter.
class TPMS_DERIVE(TpmStructure, TPMU_SENSITIVE_CREATE, TPMU_PUBLIC_ID ):
    def __init__(self,
        # -
        label = None,
        # -
        context = None
    ): 
        self.init()
        self.label = label
        self.context = context
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ANY2
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.label)
        buf.toTpm2B(this.context)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.label = buf.fromTpm2B(2)
        this.context = buf.fromTpm2B(2)
    
    
# TPMS_DERIVE

# Table 137 Definition of TPM2B_DERIVE Structure
class TPM2B_DERIVE(TpmStructure):
    def __init__(self,
        # symmetic data for a created object or the label and context for a derived object
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.buffer, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.sizedFromTpm(TPMS_DERIVE, 2)
    
    
# TPM2B_DERIVE

# This buffer wraps the TPMU_SENSITIVE_CREATE structure.
class TPM2B_SENSITIVE_DATA(TpmStructure, TPMU_SENSITIVE_COMPOSITE ):
    def __init__(self,
        # symmetic data for a created object or the label and context for a derived object
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.KEYEDHASH
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_SENSITIVE_DATA

# This structure defines the values to be placed in the sensitive area of a created object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure.
class TPMS_SENSITIVE_CREATE(TpmStructure):
    def __init__(self,
        # the USER auth secret value
        userAuth = None,
        # data to be sealed, a key, or derivation values
        data = None
    ): 
        self.init()
        self.userAuth = userAuth
        self.data = data
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.userAuth)
        buf.toTpm2B(this.data)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.userAuth = buf.fromTpm2B(2)
        this.data = buf.fromTpm2B(2)
    
    
# TPMS_SENSITIVE_CREATE

# This structure contains the sensitive creation data in a sized buffer. This structure is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may be passed as a single parameter for parameter encryption purposes.
class TPM2B_SENSITIVE_CREATE(TpmStructure):
    def __init__(self,
        # data to be sealed or a symmetric key value.
        sensitive = None
    ): 
        self.init()
        self.sensitive = sensitive
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.sensitive, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.sensitive = buf.sizedFromTpm(TPMS_SENSITIVE_CREATE, 2)
    
    
# TPM2B_SENSITIVE_CREATE

# This structure is the scheme data for schemes that only require a hash to complete their definition.
class TPMS_SCHEME_HASH(TpmStructure, TPMU_SCHEME_KEYEDHASH, TPMU_SIG_SCHEME, TPMU_KDF_SCHEME, TPMU_ASYM_SCHEME, TPMU_SIGNATURE ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        self.init()
        self.hashAlg = hashAlg
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.HMAC
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.hashAlg, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.hashAlg = buf.fromTpm(2)
    
    
# TPMS_SCHEME_HASH

# This definition is for split signing schemes that require a commit count.
class TPMS_SCHEME_ECDAA(TpmStructure, TPMU_SIG_SCHEME, TPMU_ASYM_SCHEME ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0,
        # the counter value that is used between TPM2_Commit() and the sign operation
        count = 0
    ): 
        self.init()
        self.hashAlg = hashAlg
        self.count = count
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ECDAA
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.hashAlg, 2)
        buf.toTpm(this.count, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.hashAlg = buf.fromTpm(2)
        this.count = buf.fromTpm(2)
    
    
# TPMS_SCHEME_ECDAA

# Table 145 Definition of Types for HMAC_SIG_SCHEME
class TPMS_SCHEME_HMAC(TPMS_SCHEME_HASH, TPMU_SCHEME_KEYEDHASH, TPMU_SIG_SCHEME ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SCHEME_HMAC, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.HMAC
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SCHEME_HMAC, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SCHEME_HMAC, self).fromTpm(buf)
    
    
# TPMS_SCHEME_HMAC

# This structure is for the XOR encryption scheme.
class TPMS_SCHEME_XOR(TpmStructure, TPMU_SCHEME_KEYEDHASH ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0,
        # the key derivation function
        kdf = 0
    ): 
        self.init()
        self.hashAlg = hashAlg
        self.kdf = kdf
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.XOR
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.hashAlg, 2)
        buf.toTpm(this.kdf, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.hashAlg = buf.fromTpm(2)
        this.kdf = buf.fromTpm(2)
    
    
# TPMS_SCHEME_XOR

# Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSchemeKeyedhash
class TPMS_NULL_SCHEME_KEYEDHASH(TPMS_NULL_UNION, TPMU_SCHEME_KEYEDHASH ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.NULL
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_NULL_SCHEME_KEYEDHASH

# This structure is used for a hash signing object.
class TPMT_KEYEDHASH_SCHEME(TpmStructure):
    def __init__(self,
        # the scheme parameters (One of TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH)
        details = None
    ): 
        self.init()
        self.details = details
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.details.GetUnionSelector(), 2)
        this.details.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        scheme = buf.fromTpm(2)
        this.details = createUnion('TPMU_SCHEME_KEYEDHASH', scheme)
        this.details.fromTpm(buf)
    
    
# TPMT_KEYEDHASH_SCHEME

# These are the RSA schemes that only need a hash algorithm as a scheme parameter.
class TPMS_SIG_SCHEME_RSASSA(TPMS_SCHEME_HASH, TPMU_SIG_SCHEME, TPMU_ASYM_SCHEME ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SIG_SCHEME_RSASSA, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.RSASSA
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SIG_SCHEME_RSASSA, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SIG_SCHEME_RSASSA, self).fromTpm(buf)
    
    
# TPMS_SIG_SCHEME_RSASSA

# These are the RSA schemes that only need a hash algorithm as a scheme parameter.
class TPMS_SIG_SCHEME_RSAPSS(TPMS_SCHEME_HASH, TPMU_SIG_SCHEME, TPMU_ASYM_SCHEME ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SIG_SCHEME_RSAPSS, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.RSAPSS
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SIG_SCHEME_RSAPSS, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SIG_SCHEME_RSAPSS, self).fromTpm(buf)
    
    
# TPMS_SIG_SCHEME_RSAPSS

# Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
class TPMS_SIG_SCHEME_ECDSA(TPMS_SCHEME_HASH, TPMU_SIG_SCHEME, TPMU_ASYM_SCHEME ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SIG_SCHEME_ECDSA, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ECDSA
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SIG_SCHEME_ECDSA, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SIG_SCHEME_ECDSA, self).fromTpm(buf)
    
    
# TPMS_SIG_SCHEME_ECDSA

# Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
class TPMS_SIG_SCHEME_SM2(TPMS_SCHEME_HASH, TPMU_SIG_SCHEME, TPMU_ASYM_SCHEME ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SIG_SCHEME_SM2, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.SM2
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SIG_SCHEME_SM2, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SIG_SCHEME_SM2, self).fromTpm(buf)
    
    
# TPMS_SIG_SCHEME_SM2

# Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
class TPMS_SIG_SCHEME_ECSCHNORR(TPMS_SCHEME_HASH, TPMU_SIG_SCHEME, TPMU_ASYM_SCHEME ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SIG_SCHEME_ECSCHNORR, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ECSCHNORR
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SIG_SCHEME_ECSCHNORR, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SIG_SCHEME_ECSCHNORR, self).fromTpm(buf)
    
    
# TPMS_SIG_SCHEME_ECSCHNORR

# Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
class TPMS_SIG_SCHEME_ECDAA(TPMS_SCHEME_ECDAA, TPMU_SIG_SCHEME, TPMU_ASYM_SCHEME ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0,
        # the counter value that is used between TPM2_Commit() and the sign operation
        count = 0
    ): 
        super(TPMS_SIG_SCHEME_ECDAA, self).__init__(hashAlg,count)
        self.init()
        self.hashAlg = hashAlg
        self.count = count
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ECDAA
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SIG_SCHEME_ECDAA, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SIG_SCHEME_ECDAA, self).fromTpm(buf)
    
    
# TPMS_SIG_SCHEME_ECDAA

# Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSigScheme
class TPMS_NULL_SIG_SCHEME(TPMS_NULL_UNION, TPMU_SIG_SCHEME ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.NULL
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_NULL_SIG_SCHEME

# Table 152 Definition of TPMT_SIG_SCHEME Structure
class TPMT_SIG_SCHEME(TpmStructure):
    def __init__(self,
        # scheme parameters (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        details = None
    ): 
        self.init()
        self.details = details
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.details.GetUnionSelector(), 2)
        this.details.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        scheme = buf.fromTpm(2)
        this.details = createUnion('TPMU_SIG_SCHEME', scheme)
        this.details.fromTpm(buf)
    
    
# TPMT_SIG_SCHEME

# These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
class TPMS_ENC_SCHEME_OAEP(TPMS_SCHEME_HASH, TPMU_ASYM_SCHEME ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_ENC_SCHEME_OAEP, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.OAEP
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_ENC_SCHEME_OAEP, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_ENC_SCHEME_OAEP, self).fromTpm(buf)
    
    
# TPMS_ENC_SCHEME_OAEP

# These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
class TPMS_ENC_SCHEME_RSAES(TPMS_EMPTY, TPMU_ASYM_SCHEME ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.RSAES
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_ENC_SCHEME_RSAES

# These are the ECC schemes that only need a hash algorithm as a controlling parameter.
class TPMS_KEY_SCHEME_ECDH(TPMS_SCHEME_HASH, TPMU_ASYM_SCHEME ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_KEY_SCHEME_ECDH, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ECDH
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_KEY_SCHEME_ECDH, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_KEY_SCHEME_ECDH, self).fromTpm(buf)
    
    
# TPMS_KEY_SCHEME_ECDH

# These are the ECC schemes that only need a hash algorithm as a controlling parameter.
class TPMS_KEY_SCHEME_ECMQV(TPMS_SCHEME_HASH, TPMU_ASYM_SCHEME ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_KEY_SCHEME_ECMQV, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ECMQV
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_KEY_SCHEME_ECMQV, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_KEY_SCHEME_ECMQV, self).fromTpm(buf)
    
    
# TPMS_KEY_SCHEME_ECMQV

# These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
class TPMS_SCHEME_MGF1(TPMS_SCHEME_HASH, TPMU_KDF_SCHEME ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SCHEME_MGF1, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.MGF1
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SCHEME_MGF1, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SCHEME_MGF1, self).fromTpm(buf)
    
    
# TPMS_SCHEME_MGF1

# These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
class TPMS_SCHEME_KDF1_SP800_56A(TPMS_SCHEME_HASH, TPMU_KDF_SCHEME ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SCHEME_KDF1_SP800_56A, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.KDF1_SP800_56A
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SCHEME_KDF1_SP800_56A, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SCHEME_KDF1_SP800_56A, self).fromTpm(buf)
    
    
# TPMS_SCHEME_KDF1_SP800_56A

# These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
class TPMS_SCHEME_KDF2(TPMS_SCHEME_HASH, TPMU_KDF_SCHEME ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SCHEME_KDF2, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.KDF2
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SCHEME_KDF2, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SCHEME_KDF2, self).fromTpm(buf)
    
    
# TPMS_SCHEME_KDF2

# These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
class TPMS_SCHEME_KDF1_SP800_108(TPMS_SCHEME_HASH, TPMU_KDF_SCHEME ):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SCHEME_KDF1_SP800_108, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.KDF1_SP800_108
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SCHEME_KDF1_SP800_108, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SCHEME_KDF1_SP800_108, self).fromTpm(buf)
    
    
# TPMS_SCHEME_KDF1_SP800_108

# Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuKdfScheme
class TPMS_NULL_KDF_SCHEME(TPMS_NULL_UNION, TPMU_KDF_SCHEME ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.NULL
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_NULL_KDF_SCHEME

# Table 157 Definition of TPMT_KDF_SCHEME Structure
class TPMT_KDF_SCHEME(TpmStructure):
    def __init__(self,
        # scheme parameters (One of TPMS_SCHEME_MGF1, TPMS_SCHEME_KDF1_SP800_56A, TPMS_SCHEME_KDF2, TPMS_SCHEME_KDF1_SP800_108, TPMS_NULL_KDF_SCHEME)
        details = None
    ): 
        self.init()
        self.details = details
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.details.GetUnionSelector(), 2)
        this.details.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        scheme = buf.fromTpm(2)
        this.details = createUnion('TPMU_KDF_SCHEME', scheme)
        this.details.fromTpm(buf)
    
    
# TPMT_KDF_SCHEME

# Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuAsymScheme
class TPMS_NULL_ASYM_SCHEME(TPMS_NULL_UNION, TPMU_ASYM_SCHEME ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.NULL
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_NULL_ASYM_SCHEME

# This structure is defined to allow overlay of all of the schemes for any asymmetric object. This structure is not sent on the interface. It is defined so that common functions may operate on any similar scheme structure.
class TPMT_ASYM_SCHEME(TpmStructure):
    def __init__(self,
        # scheme parameters (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        details = None
    ): 
        self.init()
        self.details = details
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.details.GetUnionSelector(), 2)
        this.details.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        scheme = buf.fromTpm(2)
        this.details = createUnion('TPMU_ASYM_SCHEME', scheme)
        this.details.fromTpm(buf)
    
    
# TPMT_ASYM_SCHEME

# Table 162 Definition of {RSA} TPMT_RSA_SCHEME Structure
class TPMT_RSA_SCHEME(TpmStructure):
    def __init__(self,
        # scheme parameters (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        details = None
    ): 
        self.init()
        self.details = details
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.details.GetUnionSelector(), 2)
        this.details.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        scheme = buf.fromTpm(2)
        this.details = createUnion('TPMU_ASYM_SCHEME', scheme)
        this.details.fromTpm(buf)
    
    
# TPMT_RSA_SCHEME

# Table 164 Definition of {RSA} TPMT_RSA_DECRYPT Structure
class TPMT_RSA_DECRYPT(TpmStructure):
    def __init__(self,
        # scheme parameters (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        details = None
    ): 
        self.init()
        self.details = details
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.details.GetUnionSelector(), 2)
        this.details.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        scheme = buf.fromTpm(2)
        this.details = createUnion('TPMU_ASYM_SCHEME', scheme)
        this.details.fromTpm(buf)
    
    
# TPMT_RSA_DECRYPT

# This sized buffer holds the largest RSA public key supported by the TPM.
class TPM2B_PUBLIC_KEY_RSA(TpmStructure, TPMU_PUBLIC_ID ):
    def __init__(self,
        # Value
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.RSA
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_PUBLIC_KEY_RSA

# This sized buffer holds the largest RSA prime number supported by the TPM.
class TPM2B_PRIVATE_KEY_RSA(TpmStructure, TPMU_SENSITIVE_COMPOSITE ):
    def __init__(self,
        # -
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.RSA
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_PRIVATE_KEY_RSA

# This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM.
class TPM2B_ECC_PARAMETER(TpmStructure, TPMU_SENSITIVE_COMPOSITE ):
    def __init__(self,
        # the parameter data
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ECC
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_ECC_PARAMETER

# This structure holds two ECC coordinates that, together, make up an ECC point.
class TPMS_ECC_POINT(TpmStructure, TPMU_PUBLIC_ID ):
    def __init__(self,
        # X coordinate
        x = None,
        # Y coordinate
        y = None
    ): 
        self.init()
        self.x = x
        self.y = y
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ECC
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.x)
        buf.toTpm2B(this.y)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.x = buf.fromTpm2B(2)
        this.y = buf.fromTpm2B(2)
    
    
# TPMS_ECC_POINT

# This structure is defined to allow a point to be a single sized parameter so that it may be encrypted.
class TPM2B_ECC_POINT(TpmStructure):
    def __init__(self,
        # coordinates
        point = None
    ): 
        self.init()
        self.point = point
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.point, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.point = buf.sizedFromTpm(TPMS_ECC_POINT, 2)
    
    
# TPM2B_ECC_POINT

# Table 173 Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure
class TPMT_ECC_SCHEME(TpmStructure):
    def __init__(self,
        # scheme parameters (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        details = None
    ): 
        self.init()
        self.details = details
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.details.GetUnionSelector(), 2)
        this.details.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        scheme = buf.fromTpm(2)
        this.details = createUnion('TPMU_ASYM_SCHEME', scheme)
        this.details.fromTpm(buf)
    
    
# TPMT_ECC_SCHEME

# This structure is used to report on the curve parameters of an ECC curve. It is returned by TPM2_ECC_Parameters().
class TPMS_ALGORITHM_DETAIL_ECC(TpmStructure):
    def __init__(self,
        # identifier for the curve
        curveID = 0,
        # Size in bits of the key
        keySize = 0,
        # if not TPM_ALG_NULL, the required KDF and hash algorithm used in secret sharing operations (One of TPMS_SCHEME_MGF1, TPMS_SCHEME_KDF1_SP800_56A, TPMS_SCHEME_KDF2, TPMS_SCHEME_KDF1_SP800_108, TPMS_NULL_KDF_SCHEME)
        kdf = None,
        # If not TPM_ALG_NULL, this is the mandatory signature scheme that is required to be used with this curve. (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        sign = None,
        # Fp (the modulus)
        p = None,
        # coefficient of the linear term in the curve equation
        a = None,
        # constant term for curve equation
        b = None,
        # x coordinate of base point G
        gX = None,
        # y coordinate of base point G
        gY = None,
        # order of G
        n = None,
        # cofactor (a size of zero indicates a cofactor of 1)
        h = None
    ): 
        self.init()
        self.curveID = curveID
        self.keySize = keySize
        self.kdf = kdf
        self.sign = sign
        self.p = p
        self.a = a
        self.b = b
        self.gX = gX
        self.gY = gY
        self.n = n
        self.h = h
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.curveID, 2)
        buf.toTpm(this.keySize, 2)
        buf.toTpm(this.kdf.GetUnionSelector(), 2)
        this.kdf.toTpm(buf)
        buf.toTpm(this.sign.GetUnionSelector(), 2)
        this.sign.toTpm(buf)
        buf.toTpm2B(this.p)
        buf.toTpm2B(this.a)
        buf.toTpm2B(this.b)
        buf.toTpm2B(this.gX)
        buf.toTpm2B(this.gY)
        buf.toTpm2B(this.n)
        buf.toTpm2B(this.h)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.curveID = buf.fromTpm(2)
        this.keySize = buf.fromTpm(2)
        kdfScheme = buf.fromTpm(2)
        this.kdf = createUnion('TPMU_KDF_SCHEME', kdfScheme)
        this.kdf.fromTpm(buf)
        signScheme = buf.fromTpm(2)
        this.sign = createUnion('TPMU_ASYM_SCHEME', signScheme)
        this.sign.fromTpm(buf)
        this.p = buf.fromTpm2B(2)
        this.a = buf.fromTpm2B(2)
        this.b = buf.fromTpm2B(2)
        this.gX = buf.fromTpm2B(2)
        this.gY = buf.fromTpm2B(2)
        this.n = buf.fromTpm2B(2)
        this.h = buf.fromTpm2B(2)
    
    
# TPMS_ALGORITHM_DETAIL_ECC

# Table 175 Definition of {RSA} TPMS_SIGNATURE_RSA Structure
class TPMS_SIGNATURE_RSA(TpmStructure, TPMU_SIGNATURE ):
    def __init__(self,
        # the hash algorithm used to digest the message TPM_ALG_NULL is not allowed.
        hash = 0,
        # The signature is the size of a public key.
        sig = None
    ): 
        self.init()
        self.hash = hash
        self.sig = sig
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.RSASSA
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.hash, 2)
        buf.toTpm2B(this.sig)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.hash = buf.fromTpm(2)
        this.sig = buf.fromTpm2B(2)
    
    
# TPMS_SIGNATURE_RSA

# Table 175 Definition of {RSA} TPMS_SIGNATURE_RSA Structure
class TPMS_SIGNATURE_RSASSA(TPMS_SIGNATURE_RSA, TPMU_SIGNATURE ):
    def __init__(self,
        # the hash algorithm used to digest the message TPM_ALG_NULL is not allowed.
        hash = 0,
        # The signature is the size of a public key.
        sig = None
    ): 
        super(TPMS_SIGNATURE_RSASSA, self).__init__(hash,sig)
        self.init()
        self.hash = hash
        self.sig = sig
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.RSASSA
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SIGNATURE_RSASSA, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SIGNATURE_RSASSA, self).fromTpm(buf)
    
    
# TPMS_SIGNATURE_RSASSA

# Table 175 Definition of {RSA} TPMS_SIGNATURE_RSA Structure
class TPMS_SIGNATURE_RSAPSS(TPMS_SIGNATURE_RSA, TPMU_SIGNATURE ):
    def __init__(self,
        # the hash algorithm used to digest the message TPM_ALG_NULL is not allowed.
        hash = 0,
        # The signature is the size of a public key.
        sig = None
    ): 
        super(TPMS_SIGNATURE_RSAPSS, self).__init__(hash,sig)
        self.init()
        self.hash = hash
        self.sig = sig
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.RSAPSS
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SIGNATURE_RSAPSS, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SIGNATURE_RSAPSS, self).fromTpm(buf)
    
    
# TPMS_SIGNATURE_RSAPSS

# Table 177 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
class TPMS_SIGNATURE_ECC(TpmStructure, TPMU_SIGNATURE ):
    def __init__(self,
        # the hash algorithm used in the signature process TPM_ALG_NULL is not allowed.
        hash = 0,
        # -
        signatureR = None,
        # -
        signatureS = None
    ): 
        self.init()
        self.hash = hash
        self.signatureR = signatureR
        self.signatureS = signatureS
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ECDSA
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.hash, 2)
        buf.toTpm2B(this.signatureR)
        buf.toTpm2B(this.signatureS)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.hash = buf.fromTpm(2)
        this.signatureR = buf.fromTpm2B(2)
        this.signatureS = buf.fromTpm2B(2)
    
    
# TPMS_SIGNATURE_ECC

# Table 177 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
class TPMS_SIGNATURE_ECDSA(TPMS_SIGNATURE_ECC, TPMU_SIGNATURE ):
    def __init__(self,
        # the hash algorithm used in the signature process TPM_ALG_NULL is not allowed.
        hash = 0,
        # -
        signatureR = None,
        # -
        signatureS = None
    ): 
        super(TPMS_SIGNATURE_ECDSA, self).__init__(hash,signatureR,signatureS)
        self.init()
        self.hash = hash
        self.signatureR = signatureR
        self.signatureS = signatureS
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ECDSA
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SIGNATURE_ECDSA, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SIGNATURE_ECDSA, self).fromTpm(buf)
    
    
# TPMS_SIGNATURE_ECDSA

# Table 177 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
class TPMS_SIGNATURE_ECDAA(TPMS_SIGNATURE_ECC, TPMU_SIGNATURE ):
    def __init__(self,
        # the hash algorithm used in the signature process TPM_ALG_NULL is not allowed.
        hash = 0,
        # -
        signatureR = None,
        # -
        signatureS = None
    ): 
        super(TPMS_SIGNATURE_ECDAA, self).__init__(hash,signatureR,signatureS)
        self.init()
        self.hash = hash
        self.signatureR = signatureR
        self.signatureS = signatureS
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ECDAA
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SIGNATURE_ECDAA, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SIGNATURE_ECDAA, self).fromTpm(buf)
    
    
# TPMS_SIGNATURE_ECDAA

# Table 177 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
class TPMS_SIGNATURE_SM2(TPMS_SIGNATURE_ECC, TPMU_SIGNATURE ):
    def __init__(self,
        # the hash algorithm used in the signature process TPM_ALG_NULL is not allowed.
        hash = 0,
        # -
        signatureR = None,
        # -
        signatureS = None
    ): 
        super(TPMS_SIGNATURE_SM2, self).__init__(hash,signatureR,signatureS)
        self.init()
        self.hash = hash
        self.signatureR = signatureR
        self.signatureS = signatureS
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.SM2
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SIGNATURE_SM2, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SIGNATURE_SM2, self).fromTpm(buf)
    
    
# TPMS_SIGNATURE_SM2

# Table 177 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
class TPMS_SIGNATURE_ECSCHNORR(TPMS_SIGNATURE_ECC, TPMU_SIGNATURE ):
    def __init__(self,
        # the hash algorithm used in the signature process TPM_ALG_NULL is not allowed.
        hash = 0,
        # -
        signatureR = None,
        # -
        signatureS = None
    ): 
        super(TPMS_SIGNATURE_ECSCHNORR, self).__init__(hash,signatureR,signatureS)
        self.init()
        self.hash = hash
        self.signatureR = signatureR
        self.signatureS = signatureS
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ECSCHNORR
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SIGNATURE_ECSCHNORR, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SIGNATURE_ECSCHNORR, self).fromTpm(buf)
    
    
# TPMS_SIGNATURE_ECSCHNORR

# Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSignature
class TPMS_NULL_SIGNATURE(TPMS_NULL_UNION, TPMU_SIGNATURE ):
    def __init__(self
    ): 
        self.init()
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.NULL
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_NULL_SIGNATURE

# Table 180 shows the basic algorithm-agile structure when a symmetric or asymmetric signature is indicated. The sigAlg parameter indicates the algorithm used for the signature. This structure is output from commands such as the attestation commands and TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(), TPM2_PolicySigned(), and TPM2_FieldUpgradeStart().
class TPMT_SIGNATURE(TpmStructure):
    def __init__(self,
        # This shall be the actual signature information. (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        signature = None
    ): 
        self.init()
        self.signature = signature
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.signature.GetUnionSelector(), 2)
        this.signature.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        sigAlg = buf.fromTpm(2)
        this.signature = createUnion('TPMU_SIGNATURE', sigAlg)
        this.signature.fromTpm(buf)
    
    
# TPMT_SIGNATURE

# Table 182 Definition of TPM2B_ENCRYPTED_SECRET Structure
class TPM2B_ENCRYPTED_SECRET(TpmStructure):
    def __init__(self,
        # secret
        secret = None
    ): 
        self.init()
        self.secret = secret
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.secret)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.secret = buf.fromTpm2B(2)
    
    
# TPM2B_ENCRYPTED_SECRET

# This structure describes the parameters that would appear in the public area of a KEYEDHASH object.
class TPMS_KEYEDHASH_PARMS(TpmStructure, TPMU_PUBLIC_PARMS ):
    def __init__(self,
        # Indicates the signing method used for a keyedHash signing object. This field also determines the size of the data field for a data object created with TPM2_Create() or TPM2_CreatePrimary(). (One of TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH)
        scheme = None
    ): 
        self.init()
        self.scheme = scheme
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.KEYEDHASH
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.scheme.GetUnionSelector(), 2)
        this.scheme.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        schemeScheme = buf.fromTpm(2)
        this.scheme = createUnion('TPMU_SCHEME_KEYEDHASH', schemeScheme)
        this.scheme.fromTpm(buf)
    
    
# TPMS_KEYEDHASH_PARMS

# This structure contains the common public area parameters for an asymmetric key. The first two parameters of the parameter definition structures of an asymmetric key shall have the same two first components.
class TPMS_ASYM_PARMS(TpmStructure, TPMU_PUBLIC_PARMS ):
    def __init__(self,
        # the companion symmetric algorithm for a restricted decryption key and shall be set to a supported symmetric algorithm This field is optional for keys that are not decryption keys and shall be set to TPM_ALG_NULL if not used.
        symmetric = None,
        # for a key with the sign attribute SET, a valid signing scheme for the key type for a key with the decrypt attribute SET, a valid key exchange protocol for a key with sign and decrypt attributes, shall be TPM_ALG_NULL (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        scheme = None
    ): 
        self.init()
        self.symmetric = symmetric
        self.scheme = scheme
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ANY
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.symmetric.toTpm(buf)
        buf.toTpm(this.scheme.GetUnionSelector(), 2)
        this.scheme.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.symmetric = buf.createFromTpm(TPMT_SYM_DEF_OBJECT)
        schemeScheme = buf.fromTpm(2)
        this.scheme = createUnion('TPMU_ASYM_SCHEME', schemeScheme)
        this.scheme.fromTpm(buf)
    
    
# TPMS_ASYM_PARMS

# A TPM compatible with this specification and supporting RSA shall support two primes and an exponent of zero. An exponent of zero indicates that the exponent is the default of 216 + 1. Support for other values is optional. Use of other exponents in duplicated keys is not recommended because the resulting keys would not be interoperable with other TPMs.
class TPMS_RSA_PARMS(TpmStructure, TPMU_PUBLIC_PARMS ):
    def __init__(self,
        # for a restricted decryption key, shall be set to a supported symmetric algorithm, key size, and mode. if the key is not a restricted decryption key, this field shall be set to TPM_ALG_NULL.
        symmetric = None,
        # scheme.scheme shall be: for an unrestricted signing key, either TPM_ALG_RSAPSS TPM_ALG_RSASSA or TPM_ALG_NULL for a restricted signing key, either TPM_ALG_RSAPSS or TPM_ALG_RSASSA for an unrestricted decryption key, TPM_ALG_RSAES, TPM_ALG_OAEP, or TPM_ALG_NULL unless the object also has the sign attribute for a restricted decryption key, TPM_ALG_NULL NOTE When both sign and decrypt are SET, restricted shall be CLEAR and scheme shall be TPM_ALG_NULL. (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        scheme = None,
        # number of bits in the public modulus
        keyBits = 0,
        # the public exponent A prime number greater than 2.
        exponent = 0
    ): 
        self.init()
        self.symmetric = symmetric
        self.scheme = scheme
        self.keyBits = keyBits
        self.exponent = exponent
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.RSA
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.symmetric.toTpm(buf)
        buf.toTpm(this.scheme.GetUnionSelector(), 2)
        this.scheme.toTpm(buf)
        buf.toTpm(this.keyBits, 2)
        buf.toTpm(this.exponent, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.symmetric = buf.createFromTpm(TPMT_SYM_DEF_OBJECT)
        schemeScheme = buf.fromTpm(2)
        this.scheme = createUnion('TPMU_ASYM_SCHEME', schemeScheme)
        this.scheme.fromTpm(buf)
        this.keyBits = buf.fromTpm(2)
        this.exponent = buf.fromTpm(4)
    
    
# TPMS_RSA_PARMS

# This structure contains the parameters for prime modulus ECC.
class TPMS_ECC_PARMS(TpmStructure, TPMU_PUBLIC_PARMS ):
    def __init__(self,
        # for a restricted decryption key, shall be set to a supported symmetric algorithm, key size. and mode. if the key is not a restricted decryption key, this field shall be set to TPM_ALG_NULL.
        symmetric = None,
        # If the sign attribute of the key is SET, then this shall be a valid signing scheme. NOTE If the sign parameter in curveID indicates a mandatory scheme, then this field shall have the same value. If the decrypt attribute of the key is SET, then this shall be a valid key exchange scheme or TPM_ALG_NULL. If the key is a Storage Key, then this field shall be TPM_ALG_NULL. (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        scheme = None,
        # ECC curve ID
        curveID = 0,
        # an optional key derivation scheme for generating a symmetric key from a Z value If the kdf parameter associated with curveID is not TPM_ALG_NULL then this is required to be NULL. NOTE There are currently no commands where this parameter has effect and, in the reference code, this field needs to be set to TPM_ALG_NULL. (One of TPMS_SCHEME_MGF1, TPMS_SCHEME_KDF1_SP800_56A, TPMS_SCHEME_KDF2, TPMS_SCHEME_KDF1_SP800_108, TPMS_NULL_KDF_SCHEME)
        kdf = None
    ): 
        self.init()
        self.symmetric = symmetric
        self.scheme = scheme
        self.curveID = curveID
        self.kdf = kdf
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ECC
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.symmetric.toTpm(buf)
        buf.toTpm(this.scheme.GetUnionSelector(), 2)
        this.scheme.toTpm(buf)
        buf.toTpm(this.curveID, 2)
        buf.toTpm(this.kdf.GetUnionSelector(), 2)
        this.kdf.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.symmetric = buf.createFromTpm(TPMT_SYM_DEF_OBJECT)
        schemeScheme = buf.fromTpm(2)
        this.scheme = createUnion('TPMU_ASYM_SCHEME', schemeScheme)
        this.scheme.fromTpm(buf)
        this.curveID = buf.fromTpm(2)
        kdfScheme = buf.fromTpm(2)
        this.kdf = createUnion('TPMU_KDF_SCHEME', kdfScheme)
        this.kdf.fromTpm(buf)
    
    
# TPMS_ECC_PARMS

# This structure is used in TPM2_TestParms() to validate that a set of algorithm parameters is supported by the TPM.
class TPMT_PUBLIC_PARMS(TpmStructure):
    def __init__(self,
        # the algorithm details (One of TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS, TPMS_ASYM_PARMS)
        parameters = None
    ): 
        self.init()
        self.parameters = parameters
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.parameters.GetUnionSelector(), 2)
        this.parameters.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        type = buf.fromTpm(2)
        this.parameters = createUnion('TPMU_PUBLIC_PARMS', type)
        this.parameters.fromTpm(buf)
    
    
# TPMT_PUBLIC_PARMS

# Table 191 defines the public area structure. The Name of the object is nameAlg concatenated with the digest of this structure using nameAlg.
class TPMT_PUBLIC(TpmStructure):
    def __init__(self,
        # algorithm used for computing the Name of the object NOTE The "+" indicates that the instance of a TPMT_PUBLIC may have a "+" to indicate that the nameAlg may be TPM_ALG_NULL.
        nameAlg = 0,
        # attributes that, along with type, determine the manipulations of this object
        objectAttributes = 0,
        # optional policy for using this key The policy is computed using the nameAlg of the object. NOTE Shall be the Empty Policy if no authorization policy is present.
        authPolicy = None,
        # the algorithm or structure details (One of TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS, TPMS_ASYM_PARMS)
        parameters = None,
        # the unique identifier of the structure For an asymmetric key, this would be the public key. (One of TPM2B_DIGEST_Keyedhash, TPM2B_DIGEST_Symcipher, TPM2B_PUBLIC_KEY_RSA, TPMS_ECC_POINT, TPMS_DERIVE)
        unique = None
    ): 
        self.init()
        self.nameAlg = nameAlg
        self.objectAttributes = objectAttributes
        self.authPolicy = authPolicy
        self.parameters = parameters
        self.unique = unique
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.parameters.GetUnionSelector(), 2)
        buf.toTpm(this.nameAlg, 2)
        buf.toTpm(this.objectAttributes, 4)
        buf.toTpm2B(this.authPolicy)
        this.parameters.toTpm(buf)
        this.unique.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        type = buf.fromTpm(2)
        this.nameAlg = buf.fromTpm(2)
        this.objectAttributes = buf.fromTpm(4)
        this.authPolicy = buf.fromTpm2B(2)
        this.parameters = createUnion('TPMU_PUBLIC_PARMS', type)
        this.parameters.fromTpm(buf)
        this.unique = createUnion('TPMU_PUBLIC_ID', type)
        this.unique.fromTpm(buf)
    
    
    
    # Returns the TPM name of this object.  The name is the alg-prepended hash of the public area.
    # @return The TPM object name
    def getName(self):
        pub = self.asTpm()
        pubHash = Crypto.hash(self.nameAlg, pub)
        algBuf = intToTpm(self.nameAlg, 2)
        return algBuf + bytes(pubHash)
    
# TPMT_PUBLIC

# This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response that returns a public area.
class TPM2B_PUBLIC(TpmStructure):
    def __init__(self,
        # the public area NOTE The + indicates that the caller may specify that use of TPM_ALG_NULL is allowed for nameAlg.
        publicArea = None
    ): 
        self.init()
        self.publicArea = publicArea
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.publicArea, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.publicArea = buf.sizedFromTpm(TPMT_PUBLIC, 2)
    
    
# TPM2B_PUBLIC

# This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded().
class TPM2B_TEMPLATE(TpmStructure):
    def __init__(self,
        # the public area
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_TEMPLATE

# This structure is defined for coding purposes. For IO to the TPM, the sensitive portion of the key will be in a canonical form. For an RSA key, this will be one of the prime factors of the public modulus. After loading, it is typical that other values will be computed so that computations using the private key will not need to start with just one prime factor. This structure can be used to store the results of such vendor-specific calculations.
class TPM2B_PRIVATE_VENDOR_SPECIFIC(TpmStructure, TPMU_SENSITIVE_COMPOSITE ):
    def __init__(self,
        # -
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.ANY
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_PRIVATE_VENDOR_SPECIFIC

# authValue shall not be larger than the size of the digest produced by the nameAlg of the object. seedValue shall be the size of the digest produced by the nameAlg of the object.
class TPMT_SENSITIVE(TpmStructure):
    def __init__(self,
        # user authorization data The authValue may be a zero-length string.
        authValue = None,
        # for a parent object, the optional protection seed; for other objects, the obfuscation value
        seedValue = None,
        # the type-specific private data (One of TPM2B_PRIVATE_KEY_RSA, TPM2B_ECC_PARAMETER, TPM2B_SENSITIVE_DATA, TPM2B_SYM_KEY, TPM2B_PRIVATE_VENDOR_SPECIFIC)
        sensitive = None
    ): 
        self.init()
        self.authValue = authValue
        self.seedValue = seedValue
        self.sensitive = sensitive
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.sensitive.GetUnionSelector(), 2)
        buf.toTpm2B(this.authValue)
        buf.toTpm2B(this.seedValue)
        this.sensitive.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        sensitiveType = buf.fromTpm(2)
        this.authValue = buf.fromTpm2B(2)
        this.seedValue = buf.fromTpm2B(2)
        this.sensitive = createUnion('TPMU_SENSITIVE_COMPOSITE', sensitiveType)
        this.sensitive.fromTpm(buf)
    
    
# TPMT_SENSITIVE

# The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an unencrypted sensitive area but it may be encrypted using parameter encryption.
class TPM2B_SENSITIVE(TpmStructure):
    def __init__(self,
        # an unencrypted sensitive area
        sensitiveArea = None
    ): 
        self.init()
        self.sensitiveArea = sensitiveArea
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.sensitiveArea, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.sensitiveArea = buf.sizedFromTpm(TPMT_SENSITIVE, 2)
    
    
# TPM2B_SENSITIVE

# This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is not directly marshaled or unmarshaled.
class _PRIVATE(TpmStructure):
    def __init__(self,
        # -
        integrityOuter = None,
        # could also be a TPM2B_IV
        integrityInner = None,
        # the sensitive area
        sensitive = None
    ): 
        self.init()
        self.integrityOuter = integrityOuter
        self.integrityInner = integrityInner
        self.sensitive = sensitive
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.integrityOuter)
        buf.toTpm2B(this.integrityInner)
        buf.sizedToTpm(this.sensitive, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.integrityOuter = buf.fromTpm2B(2)
        this.integrityInner = buf.fromTpm2B(2)
        this.sensitive = buf.sizedFromTpm(TPMT_SENSITIVE, 2)
    
    
# _PRIVATE

# The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create, load, and modify the sensitive area of an object.
class TPM2B_PRIVATE(TpmStructure):
    def __init__(self,
        # an encrypted private area
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_PRIVATE

# This structure is used for sizing the TPM2B_ID_OBJECT.
class TPMS_ID_OBJECT(TpmStructure):
    def __init__(self,
        # HMAC using the nameAlg of the storage key on the target TPM
        integrityHMAC = None,
        # credential protector information returned if name matches the referenced object All of the encIdentity is encrypted, including the size field. NOTE The TPM is not required to check that the size is not larger than the digest of the nameAlg. However, if the size is larger, the ID object may not be usable on a TPM that has no digest larger than produced by nameAlg.
        encIdentity = None
    ): 
        self.init()
        self.integrityHMAC = integrityHMAC
        self.encIdentity = encIdentity
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.integrityHMAC)
        buf.bufferToTpm(this.encIdentity)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.integrityHMAC = buf.fromTpm2B(2)
        this.encIdentity = buf.bufferFromTpm(buf.getCurStuctRemainingSize())
    
    
# TPMS_ID_OBJECT

# This structure is an output from TPM2_MakeCredential() and is an input to TPM2_ActivateCredential().
class TPM2B_ID_OBJECT(TpmStructure):
    def __init__(self,
        # an encrypted credential area
        credential = None
    ): 
        self.init()
        self.credential = credential
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.credential, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.credential = buf.sizedFromTpm(TPMS_ID_OBJECT, 2)
    
    
# TPM2B_ID_OBJECT

# This is the data that can be written to and read from a TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit is the least significant octets.
class TPMS_NV_PIN_COUNTER_PARAMETERS(TpmStructure):
    def __init__(self,
        # This counter shows the current number of successful authValue authorization attempts to access a TPM_NT_PIN_PASS index or the current number of unsuccessful authValue authorization attempts to access a TPM_NT_PIN_FAIL index.
        pinCount = 0,
        # This threshold is the value of pinCount at which the authValue authorization of the host TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL index is locked out.
        pinLimit = 0
    ): 
        self.init()
        self.pinCount = pinCount
        self.pinLimit = pinLimit
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.pinCount, 4)
        buf.toTpm(this.pinLimit, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.pinCount = buf.fromTpm(4)
        this.pinLimit = buf.fromTpm(4)
    
    
# TPMS_NV_PIN_COUNTER_PARAMETERS

# This structure describes an NV Index.
class TPMS_NV_PUBLIC(TpmStructure):
    def __init__(self,
        # the handle of the data area
        nvIndex = None,
        # hash algorithm used to compute the name of the Index and used for the authPolicy. For an extend index, the hash algorithm used for the extend.
        nameAlg = 0,
        # the Index attributes
        attributes = 0,
        # optional access policy for the Index The policy is computed using the nameAlg NOTE Shall be the Empty Policy if no authorization policy is present.
        authPolicy = None,
        # the size of the data area The maximum size is implementation-dependent. The minimum maximum size is platform-specific.
        dataSize = 0
    ): 
        self.init()
        self.nvIndex = nvIndex
        self.nameAlg = nameAlg
        self.attributes = attributes
        self.authPolicy = authPolicy
        self.dataSize = dataSize
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.nvIndex.toTpm(buf)
        buf.toTpm(this.nameAlg, 2)
        buf.toTpm(this.attributes, 4)
        buf.toTpm2B(this.authPolicy)
        buf.toTpm(this.dataSize, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.nvIndex = buf.createFromTpm(TPM_HANDLE)
        this.nameAlg = buf.fromTpm(2)
        this.attributes = buf.fromTpm(4)
        this.authPolicy = buf.fromTpm2B(2)
        this.dataSize = buf.fromTpm(2)
    
    
# TPMS_NV_PUBLIC

# This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface.
class TPM2B_NV_PUBLIC(TpmStructure):
    def __init__(self,
        # the public area
        nvPublic = None
    ): 
        self.init()
        self.nvPublic = nvPublic
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.nvPublic, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.nvPublic = buf.sizedFromTpm(TPMS_NV_PUBLIC, 2)
    
    
# TPM2B_NV_PUBLIC

# This structure holds the object or session context data. When saved, the full structure is encrypted.
class TPM2B_CONTEXT_SENSITIVE(TpmStructure):
    def __init__(self,
        # the sensitive data
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2B_CONTEXT_SENSITIVE

# This structure holds the integrity value and the encrypted data for a context.
class TPMS_CONTEXT_DATA(TpmStructure):
    def __init__(self,
        # the integrity value
        integrity = None,
        # the sensitive area
        encrypted = None
    ): 
        self.init()
        self.integrity = integrity
        self.encrypted = encrypted
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.integrity)
        buf.bufferToTpm(this.encrypted)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.integrity = buf.fromTpm2B(2)
        this.encrypted = buf.bufferFromTpm(buf.getCurStuctRemainingSize())
    
    
# TPMS_CONTEXT_DATA

# This structure is used in a TPMS_CONTEXT.
class TPM2B_CONTEXT_DATA(TpmStructure):
    def __init__(self,
        # -
        buffer = None
    ): 
        self.init()
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.buffer, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.buffer = buf.sizedFromTpm(TPMS_CONTEXT_DATA, 2)
    
    
# TPM2B_CONTEXT_DATA

# This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when the context was saved (TPM2_ContextSave()), then the TPM shall not load the context.
class TPMS_CONTEXT(TpmStructure):
    def __init__(self,
        # the sequence number of the context NOTE Transient object contexts and session contexts used different counters.
        sequence = 0,
        # a handle indicating if the context is a session, object, or sequence object (see Table 212)
        savedHandle = None,
        # the hierarchy of the context
        hierarchy = None,
        # the context data and integrity HMAC
        contextBlob = None
    ): 
        self.init()
        self.sequence = sequence
        self.savedHandle = savedHandle
        self.hierarchy = hierarchy
        self.contextBlob = contextBlob
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.sequence, 8)
        this.savedHandle.toTpm(buf)
        this.hierarchy.toTpm(buf)
        buf.sizedToTpm(this.contextBlob, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.sequence = buf.fromTpm(8)
        this.savedHandle = buf.createFromTpm(TPM_HANDLE)
        this.hierarchy = buf.createFromTpm(TPM_HANDLE)
        this.contextBlob = buf.sizedFromTpm(TPMS_CONTEXT_DATA, 2)
    
    
# TPMS_CONTEXT

# This structure provides information relating to the creation environment for the object. The creation data includes the parent Name, parent Qualified Name, and the digest of selected PCR. These values represent the environment in which the object was created. Creation data allows a relying party to determine if an object was created when some appropriate protections were present.
class TPMS_CREATION_DATA(TpmStructure):
    def __init__(self,
        # list indicating the PCR included in pcrDigest
        pcrSelect = None,
        # digest of the selected PCR using nameAlg of the object for which this structure is being created pcrDigest.size shall be zero if the pcrSelect list is empty.
        pcrDigest = None,
        # the locality at which the object was created
        locality = 0,
        # nameAlg of the parent
        parentNameAlg = 0,
        # Name of the parent at time of creation The size will match digest size associated with parentNameAlg unless it is TPM_ALG_NULL, in which case the size will be 4 and parentName will be the hierarchy handle.
        parentName = None,
        # Qualified Name of the parent at the time of creation Size is the same as parentName.
        parentQualifiedName = None,
        # association with additional information added by the key creator This will be the contents of the outsideInfo parameter in TPM2_Create() or TPM2_CreatePrimary().
        outsideInfo = None
    ): 
        self.init()
        self.pcrSelect = pcrSelect
        self.pcrDigest = pcrDigest
        self.locality = locality
        self.parentNameAlg = parentNameAlg
        self.parentName = parentName
        self.parentQualifiedName = parentQualifiedName
        self.outsideInfo = outsideInfo
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.pcrSelect, 4)
        buf.toTpm2B(this.pcrDigest)
        buf.toTpm(this.locality, 1)
        buf.toTpm(this.parentNameAlg, 2)
        buf.toTpm2B(this.parentName)
        buf.toTpm2B(this.parentQualifiedName)
        buf.toTpm2B(this.outsideInfo)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.pcrSelect = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4)
        this.pcrDigest = buf.fromTpm2B(2)
        this.locality = buf.fromTpm(1)
        this.parentNameAlg = buf.fromTpm(2)
        this.parentName = buf.fromTpm2B(2)
        this.parentQualifiedName = buf.fromTpm2B(2)
        this.outsideInfo = buf.fromTpm2B(2)
    
    
# TPMS_CREATION_DATA

# This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never entered into the TPM and never has a size of zero.
class TPM2B_CREATION_DATA(TpmStructure):
    def __init__(self,
        # -
        creationData = None
    ): 
        self.init()
        self.creationData = creationData
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.creationData, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.creationData = buf.sizedFromTpm(TPMS_CREATION_DATA, 2)
    
    
# TPM2B_CREATION_DATA

# TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter indicates the type of the data value.
class TPMS_AC_OUTPUT(TpmStructure):
    def __init__(self,
        # tag indicating the contents of data
        tag = 0,
        # the data returned from the AC
        data = 0
    ): 
        self.init()
        self.tag = tag
        self.data = data
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.tag, 4)
        buf.toTpm(this.data, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.tag = buf.fromTpm(4)
        this.data = buf.fromTpm(4)
    
    
# TPMS_AC_OUTPUT

# This list is only used in TPM2_AC_GetCapability().
class TPML_AC_CAPABILITIES(TpmStructure):
    def __init__(self,
        # a list of AC values
        acCapabilities = None
    ): 
        self.init()
        self.acCapabilities = acCapabilities
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.acCapabilities, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.acCapabilities = buf.arrayFromTpm(TPMS_AC_OUTPUT, 4)
    
    
# TPML_AC_CAPABILITIES

# TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
class TPM2_Startup_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_SU_CLEAR or TPM_SU_STATE
        startupType = 0
    ): 
        self.init()
        self.startupType = startupType
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.startupType, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.startupType = buf.fromTpm(2)
    
    
# TPM2_Startup_REQUEST

# TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
class StartupResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# StartupResponse

# This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
class TPM2_Shutdown_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_SU_CLEAR or TPM_SU_STATE
        shutdownType = 0
    ): 
        self.init()
        self.shutdownType = shutdownType
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.shutdownType, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.shutdownType = buf.fromTpm(2)
    
    
# TPM2_Shutdown_REQUEST

# This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
class ShutdownResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# ShutdownResponse

# This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
class TPM2_SelfTest_REQUEST(TpmStructure):
    def __init__(self,
        # YES if full test to be performed NO if only test of untested functions required
        fullTest = 0
    ): 
        self.init()
        self.fullTest = fullTest
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.fullTest, 1)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.fullTest = buf.fromTpm(1)
    
    
# TPM2_SelfTest_REQUEST

# This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
class SelfTestResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# SelfTestResponse

# This command causes the TPM to perform a test of the selected algorithms.
class TPM2_IncrementalSelfTest_REQUEST(TpmStructure):
    def __init__(self,
        # list of algorithms that should be tested
        toTest = None
    ): 
        self.init()
        self.toTest = toTest
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.valArrToTpm(this.toTest, 2, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.toTest = buf.valArrFromTpm(2, 4)
    
    
# TPM2_IncrementalSelfTest_REQUEST

# This command causes the TPM to perform a test of the selected algorithms.
class IncrementalSelfTestResponse(TpmStructure):
    def __init__(self,
        # list of algorithms that need testing
        toDoList = None
    ): 
        self.init()
        self.toDoList = toDoList
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.valArrToTpm(this.toDoList, 2, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.toDoList = buf.valArrFromTpm(2, 4)
    
    
# IncrementalSelfTestResponse

# This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
class TPM2_GetTestResult_REQUEST(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# TPM2_GetTestResult_REQUEST

# This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
class GetTestResultResponse(TpmStructure):
    def __init__(self,
        # test result data contains manufacturer-specific information
        outData = None,
        # -
        testResult = 0
    ): 
        self.init()
        self.outData = outData
        self.testResult = testResult
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.outData)
        buf.toTpm(this.testResult, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.outData = buf.fromTpm2B(2)
        this.testResult = buf.fromTpm(4)
    
    
# GetTestResultResponse

# This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
class TPM2_StartAuthSession_REQUEST(TpmStructure):
    def __init__(self,
        # handle of a loaded decrypt key used to encrypt salt may be TPM_RH_NULL Auth Index: None
        tpmKey = None,
        # entity providing the authValue may be TPM_RH_NULL Auth Index: None
        bind = None,
        # initial nonceCaller, sets nonceTPM size for the session shall be at least 16 octets
        nonceCaller = None,
        # value encrypted according to the type of tpmKey If tpmKey is TPM_RH_NULL, this shall be the Empty Buffer.
        encryptedSalt = None,
        # indicates the type of the session; simple HMAC or policy (including a trial policy)
        sessionType = 0,
        # the algorithm and key size for parameter encryption may select TPM_ALG_NULL
        symmetric = None,
        # hash algorithm to use for the session Shall be a hash algorithm supported by the TPM and not TPM_ALG_NULL
        authHash = 0
    ): 
        self.init()
        self.tpmKey = tpmKey
        self.bind = bind
        self.nonceCaller = nonceCaller
        self.encryptedSalt = encryptedSalt
        self.sessionType = sessionType
        self.symmetric = symmetric
        self.authHash = authHash
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.nonceCaller)
        buf.toTpm2B(this.encryptedSalt)
        buf.toTpm(this.sessionType, 1)
        this.symmetric.toTpm(buf)
        buf.toTpm(this.authHash, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.tpmKey = buf.createFromTpm(TPM_HANDLE)
        this.bind = buf.createFromTpm(TPM_HANDLE)
        this.nonceCaller = buf.fromTpm2B(2)
        this.encryptedSalt = buf.fromTpm2B(2)
        this.sessionType = buf.fromTpm(1)
        this.symmetric = buf.createFromTpm(TPMT_SYM_DEF)
        this.authHash = buf.fromTpm(2)
    
    
# TPM2_StartAuthSession_REQUEST

# This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
class StartAuthSessionResponse(TpmStructure):
    def __init__(self,
        # handle for the newly created session
        handle = None,
        # the initial nonce from the TPM, used in the computation of the sessionKey
        nonceTPM = None
    ): 
        self.init()
        self.handle = handle
        self.nonceTPM = nonceTPM
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.handle.toTpm(buf)
        buf.toTpm2B(this.nonceTPM)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.createFromTpm(TPM_HANDLE)
        this.nonceTPM = buf.fromTpm2B(2)
    
    
# StartAuthSessionResponse

# This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
class TPM2_PolicyRestart_REQUEST(TpmStructure):
    def __init__(self,
        # the handle for the policy session
        sessionHandle = None
    ): 
        self.init()
        self.sessionHandle = sessionHandle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.sessionHandle = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_PolicyRestart_REQUEST

# This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
class PolicyRestartResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyRestartResponse

# This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
class TPM2_Create_REQUEST(TpmStructure):
    def __init__(self,
        # handle of parent for new object Auth Index: 1 Auth Role: USER
        parentHandle = None,
        # the sensitive data
        inSensitive = None,
        # the public template
        inPublic = None,
        # data that will be included in the creation data for this object to provide permanent, verifiable linkage between this object and some object owner data
        outsideInfo = None,
        # PCR that will be used in creation data
        creationPCR = None
    ): 
        self.init()
        self.parentHandle = parentHandle
        self.inSensitive = inSensitive
        self.inPublic = inPublic
        self.outsideInfo = outsideInfo
        self.creationPCR = creationPCR
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.inSensitive, 2)
        buf.sizedToTpm(this.inPublic, 2)
        buf.toTpm2B(this.outsideInfo)
        buf.arrayToTpm(this.creationPCR, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.parentHandle = buf.createFromTpm(TPM_HANDLE)
        this.inSensitive = buf.sizedFromTpm(TPMS_SENSITIVE_CREATE, 2)
        this.inPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2)
        this.outsideInfo = buf.fromTpm2B(2)
        this.creationPCR = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4)
    
    
# TPM2_Create_REQUEST

# This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
class CreateResponse(TpmStructure):
    def __init__(self,
        # the private portion of the object
        outPrivate = None,
        # the public portion of the created object
        outPublic = None,
        # contains a TPMS_CREATION_DATA
        creationData = None,
        # digest of creationData using nameAlg of outPublic
        creationHash = None,
        # ticket used by TPM2_CertifyCreation() to validate that the creation data was produced by the TPM
        creationTicket = None
    ): 
        self.init()
        self.outPrivate = outPrivate
        self.outPublic = outPublic
        self.creationData = creationData
        self.creationHash = creationHash
        self.creationTicket = creationTicket
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.outPrivate.toTpm(buf)
        buf.sizedToTpm(this.outPublic, 2)
        buf.sizedToTpm(this.creationData, 2)
        buf.toTpm2B(this.creationHash)
        this.creationTicket.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.outPrivate = buf.createFromTpm(TPM2B_PRIVATE)
        this.outPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2)
        this.creationData = buf.sizedFromTpm(TPMS_CREATION_DATA, 2)
        this.creationHash = buf.fromTpm2B(2)
        this.creationTicket = buf.createFromTpm(TPMT_TK_CREATION)
    
    
# CreateResponse

# This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
class TPM2_Load_REQUEST(TpmStructure):
    def __init__(self,
        # TPM handle of parent key; shall not be a reserved handle Auth Index: 1 Auth Role: USER
        parentHandle = None,
        # the private portion of the object
        inPrivate = None,
        # the public portion of the object
        inPublic = None
    ): 
        self.init()
        self.parentHandle = parentHandle
        self.inPrivate = inPrivate
        self.inPublic = inPublic
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.inPrivate.toTpm(buf)
        buf.sizedToTpm(this.inPublic, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.parentHandle = buf.createFromTpm(TPM_HANDLE)
        this.inPrivate = buf.createFromTpm(TPM2B_PRIVATE)
        this.inPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2)
    
    
# TPM2_Load_REQUEST

# This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
class LoadResponse(TpmStructure):
    def __init__(self,
        # handle of type TPM_HT_TRANSIENT for the loaded object
        handle = None,
        # Name of the loaded object
        name = None
    ): 
        self.init()
        self.handle = handle
        self.name = name
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.handle.toTpm(buf)
        buf.toTpm2B(this.name)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.createFromTpm(TPM_HANDLE)
        this.name = buf.fromTpm2B(2)
    
    
# LoadResponse

# This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
class TPM2_LoadExternal_REQUEST(TpmStructure):
    def __init__(self,
        # the sensitive portion of the object (optional)
        inPrivate = None,
        # the public portion of the object
        inPublic = None,
        # hierarchy with which the object area is associated
        hierarchy = None
    ): 
        self.init()
        self.inPrivate = inPrivate
        self.inPublic = inPublic
        self.hierarchy = hierarchy
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.inPrivate, 2)
        buf.sizedToTpm(this.inPublic, 2)
        this.hierarchy.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.inPrivate = buf.sizedFromTpm(TPMT_SENSITIVE, 2)
        this.inPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2)
        this.hierarchy = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_LoadExternal_REQUEST

# This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
class LoadExternalResponse(TpmStructure):
    def __init__(self,
        # handle of type TPM_HT_TRANSIENT for the loaded object
        handle = None,
        # name of the loaded object
        name = None
    ): 
        self.init()
        self.handle = handle
        self.name = name
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.handle.toTpm(buf)
        buf.toTpm2B(this.name)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.createFromTpm(TPM_HANDLE)
        this.name = buf.fromTpm2B(2)
    
    
# LoadExternalResponse

# This command allows access to the public area of a loaded object.
class TPM2_ReadPublic_REQUEST(TpmStructure):
    def __init__(self,
        # TPM handle of an object Auth Index: None
        objectHandle = None
    ): 
        self.init()
        self.objectHandle = objectHandle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.objectHandle = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_ReadPublic_REQUEST

# This command allows access to the public area of a loaded object.
class ReadPublicResponse(TpmStructure):
    def __init__(self,
        # structure containing the public area of an object
        outPublic = None,
        # name of the object
        name = None,
        # the Qualified Name of the object
        qualifiedName = None
    ): 
        self.init()
        self.outPublic = outPublic
        self.name = name
        self.qualifiedName = qualifiedName
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.outPublic, 2)
        buf.toTpm2B(this.name)
        buf.toTpm2B(this.qualifiedName)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.outPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2)
        this.name = buf.fromTpm2B(2)
        this.qualifiedName = buf.fromTpm2B(2)
    
    
# ReadPublicResponse

# This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
class TPM2_ActivateCredential_REQUEST(TpmStructure):
    def __init__(self,
        # handle of the object associated with certificate in credentialBlob Auth Index: 1 Auth Role: ADMIN
        activateHandle = None,
        # loaded key used to decrypt the TPMS_SENSITIVE in credentialBlob Auth Index: 2 Auth Role: USER
        keyHandle = None,
        # the credential
        credentialBlob = None,
        # keyHandle algorithm-dependent encrypted seed that protects credentialBlob
        secret = None
    ): 
        self.init()
        self.activateHandle = activateHandle
        self.keyHandle = keyHandle
        self.credentialBlob = credentialBlob
        self.secret = secret
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.credentialBlob, 2)
        buf.toTpm2B(this.secret)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.activateHandle = buf.createFromTpm(TPM_HANDLE)
        this.keyHandle = buf.createFromTpm(TPM_HANDLE)
        this.credentialBlob = buf.sizedFromTpm(TPMS_ID_OBJECT, 2)
        this.secret = buf.fromTpm2B(2)
    
    
# TPM2_ActivateCredential_REQUEST

# This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
class ActivateCredentialResponse(TpmStructure):
    def __init__(self,
        # the decrypted certificate information the data should be no larger than the size of the digest of the nameAlg associated with keyHandle
        certInfo = None
    ): 
        self.init()
        self.certInfo = certInfo
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.certInfo)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.certInfo = buf.fromTpm2B(2)
    
    
# ActivateCredentialResponse

# This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
class TPM2_MakeCredential_REQUEST(TpmStructure):
    def __init__(self,
        # loaded public area, used to encrypt the sensitive area containing the credential key Auth Index: None
        handle = None,
        # the credential information
        credential = None,
        # Name of the object to which the credential applies
        objectName = None
    ): 
        self.init()
        self.handle = handle
        self.credential = credential
        self.objectName = objectName
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.credential)
        buf.toTpm2B(this.objectName)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.createFromTpm(TPM_HANDLE)
        this.credential = buf.fromTpm2B(2)
        this.objectName = buf.fromTpm2B(2)
    
    
# TPM2_MakeCredential_REQUEST

# This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
class MakeCredentialResponse(TpmStructure):
    def __init__(self,
        # the credential
        credentialBlob = None,
        # handle algorithm-dependent data that wraps the key that encrypts credentialBlob
        secret = None
    ): 
        self.init()
        self.credentialBlob = credentialBlob
        self.secret = secret
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.credentialBlob, 2)
        buf.toTpm2B(this.secret)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.credentialBlob = buf.sizedFromTpm(TPMS_ID_OBJECT, 2)
        this.secret = buf.fromTpm2B(2)
    
    
# MakeCredentialResponse

# This command returns the data in a loaded Sealed Data Object.
class TPM2_Unseal_REQUEST(TpmStructure):
    def __init__(self,
        # handle of a loaded data object Auth Index: 1 Auth Role: USER
        itemHandle = None
    ): 
        self.init()
        self.itemHandle = itemHandle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.itemHandle = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_Unseal_REQUEST

# This command returns the data in a loaded Sealed Data Object.
class UnsealResponse(TpmStructure):
    def __init__(self,
        # unsealed data Size of outData is limited to be no more than 128 octets.
        outData = None
    ): 
        self.init()
        self.outData = outData
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.outData)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.outData = buf.fromTpm2B(2)
    
    
# UnsealResponse

# This command is used to change the authorization secret for a TPM-resident object.
class TPM2_ObjectChangeAuth_REQUEST(TpmStructure):
    def __init__(self,
        # handle of the object Auth Index: 1 Auth Role: ADMIN
        objectHandle = None,
        # handle of the parent Auth Index: None
        parentHandle = None,
        # new authorization value
        newAuth = None
    ): 
        self.init()
        self.objectHandle = objectHandle
        self.parentHandle = parentHandle
        self.newAuth = newAuth
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.newAuth)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.objectHandle = buf.createFromTpm(TPM_HANDLE)
        this.parentHandle = buf.createFromTpm(TPM_HANDLE)
        this.newAuth = buf.fromTpm2B(2)
    
    
# TPM2_ObjectChangeAuth_REQUEST

# This command is used to change the authorization secret for a TPM-resident object.
class ObjectChangeAuthResponse(TpmStructure):
    def __init__(self,
        # private area containing the new authorization value
        outPrivate = None
    ): 
        self.init()
        self.outPrivate = outPrivate
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.outPrivate.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.outPrivate = buf.createFromTpm(TPM2B_PRIVATE)
    
    
# ObjectChangeAuthResponse

# This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
class TPM2_CreateLoaded_REQUEST(TpmStructure):
    def __init__(self,
        # Handle of a transient storage key, a persistent storage key, TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL Auth Index: 1 Auth Role: USER
        parentHandle = None,
        # the sensitive data, see TPM 2.0 Part 1 Sensitive Values
        inSensitive = None,
        # the public template
        inPublic = None
    ): 
        self.init()
        self.parentHandle = parentHandle
        self.inSensitive = inSensitive
        self.inPublic = inPublic
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.inSensitive, 2)
        buf.toTpm2B(this.inPublic)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.parentHandle = buf.createFromTpm(TPM_HANDLE)
        this.inSensitive = buf.sizedFromTpm(TPMS_SENSITIVE_CREATE, 2)
        this.inPublic = buf.fromTpm2B(2)
    
    
# TPM2_CreateLoaded_REQUEST

# This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
class CreateLoadedResponse(TpmStructure):
    def __init__(self,
        # handle of type TPM_HT_TRANSIENT for created object
        handle = None,
        # the sensitive area of the object (optional)
        outPrivate = None,
        # the public portion of the created object
        outPublic = None,
        # the name of the created object
        name = None
    ): 
        self.init()
        self.handle = handle
        self.outPrivate = outPrivate
        self.outPublic = outPublic
        self.name = name
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.handle.toTpm(buf)
        this.outPrivate.toTpm(buf)
        buf.sizedToTpm(this.outPublic, 2)
        buf.toTpm2B(this.name)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.createFromTpm(TPM_HANDLE)
        this.outPrivate = buf.createFromTpm(TPM2B_PRIVATE)
        this.outPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2)
        this.name = buf.fromTpm2B(2)
    
    
# CreateLoadedResponse

# This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
class TPM2_Duplicate_REQUEST(TpmStructure):
    def __init__(self,
        # loaded object to duplicate Auth Index: 1 Auth Role: DUP
        objectHandle = None,
        # shall reference the public area of an asymmetric key Auth Index: None
        newParentHandle = None,
        # optional symmetric encryption key The size for this key is set to zero when the TPM is to generate the key. This parameter may be encrypted.
        encryptionKeyIn = None,
        # definition for the symmetric algorithm to be used for the inner wrapper may be TPM_ALG_NULL if no inner wrapper is applied
        symmetricAlg = None
    ): 
        self.init()
        self.objectHandle = objectHandle
        self.newParentHandle = newParentHandle
        self.encryptionKeyIn = encryptionKeyIn
        self.symmetricAlg = symmetricAlg
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.encryptionKeyIn)
        this.symmetricAlg.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.objectHandle = buf.createFromTpm(TPM_HANDLE)
        this.newParentHandle = buf.createFromTpm(TPM_HANDLE)
        this.encryptionKeyIn = buf.fromTpm2B(2)
        this.symmetricAlg = buf.createFromTpm(TPMT_SYM_DEF_OBJECT)
    
    
# TPM2_Duplicate_REQUEST

# This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
class DuplicateResponse(TpmStructure):
    def __init__(self,
        # If the caller provided an encryption key or if symmetricAlg was TPM_ALG_NULL, then this will be the Empty Buffer; otherwise, it shall contain the TPM-generated, symmetric encryption key for the inner wrapper.
        encryptionKeyOut = None,
        # private area that may be encrypted by encryptionKeyIn; and may be doubly encrypted
        duplicate = None,
        # seed protected by the asymmetric algorithms of new parent (NP)
        outSymSeed = None
    ): 
        self.init()
        self.encryptionKeyOut = encryptionKeyOut
        self.duplicate = duplicate
        self.outSymSeed = outSymSeed
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.encryptionKeyOut)
        this.duplicate.toTpm(buf)
        buf.toTpm2B(this.outSymSeed)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.encryptionKeyOut = buf.fromTpm2B(2)
        this.duplicate = buf.createFromTpm(TPM2B_PRIVATE)
        this.outSymSeed = buf.fromTpm2B(2)
    
    
# DuplicateResponse

# This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
class TPM2_Rewrap_REQUEST(TpmStructure):
    def __init__(self,
        # parent of object Auth Index: 1 Auth Role: User
        oldParent = None,
        # new parent of the object Auth Index: None
        newParent = None,
        # an object encrypted using symmetric key derived from inSymSeed
        inDuplicate = None,
        # the Name of the object being rewrapped
        name = None,
        # the seed for the symmetric key and HMAC key needs oldParent private key to recover the seed and generate the symmetric key
        inSymSeed = None
    ): 
        self.init()
        self.oldParent = oldParent
        self.newParent = newParent
        self.inDuplicate = inDuplicate
        self.name = name
        self.inSymSeed = inSymSeed
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.inDuplicate.toTpm(buf)
        buf.toTpm2B(this.name)
        buf.toTpm2B(this.inSymSeed)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.oldParent = buf.createFromTpm(TPM_HANDLE)
        this.newParent = buf.createFromTpm(TPM_HANDLE)
        this.inDuplicate = buf.createFromTpm(TPM2B_PRIVATE)
        this.name = buf.fromTpm2B(2)
        this.inSymSeed = buf.fromTpm2B(2)
    
    
# TPM2_Rewrap_REQUEST

# This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
class RewrapResponse(TpmStructure):
    def __init__(self,
        # an object encrypted using symmetric key derived from outSymSeed
        outDuplicate = None,
        # seed for a symmetric key protected by newParent asymmetric key
        outSymSeed = None
    ): 
        self.init()
        self.outDuplicate = outDuplicate
        self.outSymSeed = outSymSeed
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.outDuplicate.toTpm(buf)
        buf.toTpm2B(this.outSymSeed)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.outDuplicate = buf.createFromTpm(TPM2B_PRIVATE)
        this.outSymSeed = buf.fromTpm2B(2)
    
    
# RewrapResponse

# This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
class TPM2_Import_REQUEST(TpmStructure):
    def __init__(self,
        # the handle of the new parent for the object Auth Index: 1 Auth Role: USER
        parentHandle = None,
        # the optional symmetric encryption key used as the inner wrapper for duplicate If symmetricAlg is TPM_ALG_NULL, then this parameter shall be the Empty Buffer.
        encryptionKey = None,
        # the public area of the object to be imported This is provided so that the integrity value for duplicate and the object attributes can be checked. NOTE Even if the integrity value of the object is not checked on input, the object Name is required to create the integrity value for the imported object.
        objectPublic = None,
        # the symmetrically encrypted duplicate object that may contain an inner symmetric wrapper
        duplicate = None,
        # the seed for the symmetric key and HMAC key inSymSeed is encrypted/encoded using the algorithms of newParent.
        inSymSeed = None,
        # definition for the symmetric algorithm to use for the inner wrapper If this algorithm is TPM_ALG_NULL, no inner wrapper is present and encryptionKey shall be the Empty Buffer.
        symmetricAlg = None
    ): 
        self.init()
        self.parentHandle = parentHandle
        self.encryptionKey = encryptionKey
        self.objectPublic = objectPublic
        self.duplicate = duplicate
        self.inSymSeed = inSymSeed
        self.symmetricAlg = symmetricAlg
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.encryptionKey)
        buf.sizedToTpm(this.objectPublic, 2)
        this.duplicate.toTpm(buf)
        buf.toTpm2B(this.inSymSeed)
        this.symmetricAlg.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.parentHandle = buf.createFromTpm(TPM_HANDLE)
        this.encryptionKey = buf.fromTpm2B(2)
        this.objectPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2)
        this.duplicate = buf.createFromTpm(TPM2B_PRIVATE)
        this.inSymSeed = buf.fromTpm2B(2)
        this.symmetricAlg = buf.createFromTpm(TPMT_SYM_DEF_OBJECT)
    
    
# TPM2_Import_REQUEST

# This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
class ImportResponse(TpmStructure):
    def __init__(self,
        # the sensitive area encrypted with the symmetric key of parentHandle
        outPrivate = None
    ): 
        self.init()
        self.outPrivate = outPrivate
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.outPrivate.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.outPrivate = buf.createFromTpm(TPM2B_PRIVATE)
    
    
# ImportResponse

# This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
class TPM2_RSA_Encrypt_REQUEST(TpmStructure):
    def __init__(self,
        # reference to public portion of RSA key to use for encryption Auth Index: None
        keyHandle = None,
        # message to be encrypted NOTE 1 The data type was chosen because it limits the overall size of the input to no greater than the size of the largest RSA public key. This may be larger than allowed for keyHandle.
        message = None,
        # the padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        inScheme = None,
        # optional label L to be associated with the message Size of the buffer is zero if no label is present NOTE 2 See description of label above.
        label = None
    ): 
        self.init()
        self.keyHandle = keyHandle
        self.message = message
        self.inScheme = inScheme
        self.label = label
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.message)
        buf.toTpm(this.inScheme.GetUnionSelector(), 2)
        this.inScheme.toTpm(buf)
        buf.toTpm2B(this.label)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.keyHandle = buf.createFromTpm(TPM_HANDLE)
        this.message = buf.fromTpm2B(2)
        inSchemeScheme = buf.fromTpm(2)
        this.inScheme = createUnion('TPMU_ASYM_SCHEME', inSchemeScheme)
        this.inScheme.fromTpm(buf)
        this.label = buf.fromTpm2B(2)
    
    
# TPM2_RSA_Encrypt_REQUEST

# This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
class RSA_EncryptResponse(TpmStructure):
    def __init__(self,
        # encrypted output
        outData = None
    ): 
        self.init()
        self.outData = outData
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.outData)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.outData = buf.fromTpm2B(2)
    
    
# RSA_EncryptResponse

# This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
class TPM2_RSA_Decrypt_REQUEST(TpmStructure):
    def __init__(self,
        # RSA key to use for decryption Auth Index: 1 Auth Role: USER
        keyHandle = None,
        # cipher text to be decrypted NOTE An encrypted RSA data block is the size of the public modulus.
        cipherText = None,
        # the padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        inScheme = None,
        # label whose association with the message is to be verified
        label = None
    ): 
        self.init()
        self.keyHandle = keyHandle
        self.cipherText = cipherText
        self.inScheme = inScheme
        self.label = label
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.cipherText)
        buf.toTpm(this.inScheme.GetUnionSelector(), 2)
        this.inScheme.toTpm(buf)
        buf.toTpm2B(this.label)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.keyHandle = buf.createFromTpm(TPM_HANDLE)
        this.cipherText = buf.fromTpm2B(2)
        inSchemeScheme = buf.fromTpm(2)
        this.inScheme = createUnion('TPMU_ASYM_SCHEME', inSchemeScheme)
        this.inScheme.fromTpm(buf)
        this.label = buf.fromTpm2B(2)
    
    
# TPM2_RSA_Decrypt_REQUEST

# This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
class RSA_DecryptResponse(TpmStructure):
    def __init__(self,
        # decrypted output
        message = None
    ): 
        self.init()
        self.message = message
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.message)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.message = buf.fromTpm2B(2)
    
    
# RSA_DecryptResponse

# This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P [hde]QS).
class TPM2_ECDH_KeyGen_REQUEST(TpmStructure):
    def __init__(self,
        # Handle of a loaded ECC key public area. Auth Index: None
        keyHandle = None
    ): 
        self.init()
        self.keyHandle = keyHandle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.keyHandle = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_ECDH_KeyGen_REQUEST

# This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P [hde]QS).
class ECDH_KeyGenResponse(TpmStructure):
    def __init__(self,
        # results of P h[de]Qs
        zPoint = None,
        # generated ephemeral public point (Qe)
        pubPoint = None
    ): 
        self.init()
        self.zPoint = zPoint
        self.pubPoint = pubPoint
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.zPoint, 2)
        buf.sizedToTpm(this.pubPoint, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.zPoint = buf.sizedFromTpm(TPMS_ECC_POINT, 2)
        this.pubPoint = buf.sizedFromTpm(TPMS_ECC_POINT, 2)
    
    
# ECDH_KeyGenResponse

# This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ) [hds]QB; where h is the cofactor of the curve).
class TPM2_ECDH_ZGen_REQUEST(TpmStructure):
    def __init__(self,
        # handle of a loaded ECC key Auth Index: 1 Auth Role: USER
        keyHandle = None,
        # a public key
        inPoint = None
    ): 
        self.init()
        self.keyHandle = keyHandle
        self.inPoint = inPoint
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.inPoint, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.keyHandle = buf.createFromTpm(TPM_HANDLE)
        this.inPoint = buf.sizedFromTpm(TPMS_ECC_POINT, 2)
    
    
# TPM2_ECDH_ZGen_REQUEST

# This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ) [hds]QB; where h is the cofactor of the curve).
class ECDH_ZGenResponse(TpmStructure):
    def __init__(self,
        # X and Y coordinates of the product of the multiplication Z = (xZ , yZ) [hdS]QB
        outPoint = None
    ): 
        self.init()
        self.outPoint = outPoint
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.outPoint, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.outPoint = buf.sizedFromTpm(TPMS_ECC_POINT, 2)
    
    
# ECDH_ZGenResponse

# This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
class TPM2_ECC_Parameters_REQUEST(TpmStructure):
    def __init__(self,
        # parameter set selector
        curveID = 0
    ): 
        self.init()
        self.curveID = curveID
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.curveID, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.curveID = buf.fromTpm(2)
    
    
# TPM2_ECC_Parameters_REQUEST

# This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
class ECC_ParametersResponse(TpmStructure):
    def __init__(self,
        # ECC parameters for the selected curve
        parameters = None
    ): 
        self.init()
        self.parameters = parameters
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.parameters.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.parameters = buf.createFromTpm(TPMS_ALGORITHM_DETAIL_ECC)
    
    
# ECC_ParametersResponse

# This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
class TPM2_ZGen_2Phase_REQUEST(TpmStructure):
    def __init__(self,
        # handle of an unrestricted decryption key ECC The private key referenced by this handle is used as dS,A Auth Index: 1 Auth Role: USER
        keyA = None,
        # other partys static public key (Qs,B = (Xs,B, Ys,B))
        inQsB = None,
        # other party's ephemeral public key (Qe,B = (Xe,B, Ye,B))
        inQeB = None,
        # the key exchange scheme
        inScheme = 0,
        # value returned by TPM2_EC_Ephemeral()
        counter = 0
    ): 
        self.init()
        self.keyA = keyA
        self.inQsB = inQsB
        self.inQeB = inQeB
        self.inScheme = inScheme
        self.counter = counter
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.inQsB, 2)
        buf.sizedToTpm(this.inQeB, 2)
        buf.toTpm(this.inScheme, 2)
        buf.toTpm(this.counter, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.keyA = buf.createFromTpm(TPM_HANDLE)
        this.inQsB = buf.sizedFromTpm(TPMS_ECC_POINT, 2)
        this.inQeB = buf.sizedFromTpm(TPMS_ECC_POINT, 2)
        this.inScheme = buf.fromTpm(2)
        this.counter = buf.fromTpm(2)
    
    
# TPM2_ZGen_2Phase_REQUEST

# This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
class ZGen_2PhaseResponse(TpmStructure):
    def __init__(self,
        # X and Y coordinates of the computed value (scheme dependent)
        outZ1 = None,
        # X and Y coordinates of the second computed value (scheme dependent)
        outZ2 = None
    ): 
        self.init()
        self.outZ1 = outZ1
        self.outZ2 = outZ2
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.outZ1, 2)
        buf.sizedToTpm(this.outZ2, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.outZ1 = buf.sizedFromTpm(TPMS_ECC_POINT, 2)
        this.outZ2 = buf.sizedFromTpm(TPMS_ECC_POINT, 2)
    
    
# ZGen_2PhaseResponse

# NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
class TPM2_EncryptDecrypt_REQUEST(TpmStructure):
    def __init__(self,
        # the symmetric key used for the operation Auth Index: 1 Auth Role: USER
        keyHandle = None,
        # if YES, then the operation is decryption; if NO, the operation is encryption
        decrypt = 0,
        # symmetric encryption/decryption mode this field shall match the default mode of the key or be TPM_ALG_NULL.
        mode = 0,
        # an initial value as required by the algorithm
        ivIn = None,
        # the data to be encrypted/decrypted
        inData = None
    ): 
        self.init()
        self.keyHandle = keyHandle
        self.decrypt = decrypt
        self.mode = mode
        self.ivIn = ivIn
        self.inData = inData
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.decrypt, 1)
        buf.toTpm(this.mode, 2)
        buf.toTpm2B(this.ivIn)
        buf.toTpm2B(this.inData)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.keyHandle = buf.createFromTpm(TPM_HANDLE)
        this.decrypt = buf.fromTpm(1)
        this.mode = buf.fromTpm(2)
        this.ivIn = buf.fromTpm2B(2)
        this.inData = buf.fromTpm2B(2)
    
    
# TPM2_EncryptDecrypt_REQUEST

# NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
class EncryptDecryptResponse(TpmStructure):
    def __init__(self,
        # encrypted or decrypted output
        outData = None,
        # chaining value to use for IV in next round
        ivOut = None
    ): 
        self.init()
        self.outData = outData
        self.ivOut = ivOut
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.outData)
        buf.toTpm2B(this.ivOut)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.outData = buf.fromTpm2B(2)
        this.ivOut = buf.fromTpm2B(2)
    
    
# EncryptDecryptResponse

# This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
class TPM2_EncryptDecrypt2_REQUEST(TpmStructure):
    def __init__(self,
        # the symmetric key used for the operation Auth Index: 1 Auth Role: USER
        keyHandle = None,
        # the data to be encrypted/decrypted
        inData = None,
        # if YES, then the operation is decryption; if NO, the operation is encryption
        decrypt = 0,
        # symmetric mode this field shall match the default mode of the key or be TPM_ALG_NULL.
        mode = 0,
        # an initial value as required by the algorithm
        ivIn = None
    ): 
        self.init()
        self.keyHandle = keyHandle
        self.inData = inData
        self.decrypt = decrypt
        self.mode = mode
        self.ivIn = ivIn
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.inData)
        buf.toTpm(this.decrypt, 1)
        buf.toTpm(this.mode, 2)
        buf.toTpm2B(this.ivIn)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.keyHandle = buf.createFromTpm(TPM_HANDLE)
        this.inData = buf.fromTpm2B(2)
        this.decrypt = buf.fromTpm(1)
        this.mode = buf.fromTpm(2)
        this.ivIn = buf.fromTpm2B(2)
    
    
# TPM2_EncryptDecrypt2_REQUEST

# This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
class EncryptDecrypt2Response(TpmStructure):
    def __init__(self,
        # encrypted or decrypted output
        outData = None,
        # chaining value to use for IV in next round
        ivOut = None
    ): 
        self.init()
        self.outData = outData
        self.ivOut = ivOut
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.outData)
        buf.toTpm2B(this.ivOut)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.outData = buf.fromTpm2B(2)
        this.ivOut = buf.fromTpm2B(2)
    
    
# EncryptDecrypt2Response

# This command performs a hash operation on a data buffer and returns the results.
class TPM2_Hash_REQUEST(TpmStructure):
    def __init__(self,
        # data to be hashed
        data = None,
        # algorithm for the hash being computed shall not be TPM_ALG_NULL
        hashAlg = 0,
        # hierarchy to use for the ticket (TPM_RH_NULL allowed)
        hierarchy = None
    ): 
        self.init()
        self.data = data
        self.hashAlg = hashAlg
        self.hierarchy = hierarchy
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.data)
        buf.toTpm(this.hashAlg, 2)
        this.hierarchy.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.data = buf.fromTpm2B(2)
        this.hashAlg = buf.fromTpm(2)
        this.hierarchy = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_Hash_REQUEST

# This command performs a hash operation on a data buffer and returns the results.
class HashResponse(TpmStructure):
    def __init__(self,
        # results
        outHash = None,
        # ticket indicating that the sequence of octets used to compute outDigest did not start with TPM_GENERATED_VALUE will be a NULL ticket if the digest may not be signed with a restricted key
        validation = None
    ): 
        self.init()
        self.outHash = outHash
        self.validation = validation
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.outHash)
        this.validation.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.outHash = buf.fromTpm2B(2)
        this.validation = buf.createFromTpm(TPMT_TK_HASHCHECK)
    
    
# HashResponse

# This command performs an HMAC on the supplied data using the indicated hash algorithm.
class TPM2_HMAC_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the symmetric signing key providing the HMAC key Auth Index: 1 Auth Role: USER
        handle = None,
        # HMAC data
        buffer = None,
        # algorithm to use for HMAC
        hashAlg = 0
    ): 
        self.init()
        self.handle = handle
        self.buffer = buffer
        self.hashAlg = hashAlg
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
        buf.toTpm(this.hashAlg, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.createFromTpm(TPM_HANDLE)
        this.buffer = buf.fromTpm2B(2)
        this.hashAlg = buf.fromTpm(2)
    
    
# TPM2_HMAC_REQUEST

# This command performs an HMAC on the supplied data using the indicated hash algorithm.
class HMACResponse(TpmStructure):
    def __init__(self,
        # the returned HMAC in a sized buffer
        outHMAC = None
    ): 
        self.init()
        self.outHMAC = outHMAC
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.outHMAC)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.outHMAC = buf.fromTpm2B(2)
    
    
# HMACResponse

# This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
class TPM2_MAC_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the symmetric signing key providing the MAC key Auth Index: 1 Auth Role: USER
        handle = None,
        # MAC data
        buffer = None,
        # algorithm to use for MAC
        inScheme = 0
    ): 
        self.init()
        self.handle = handle
        self.buffer = buffer
        self.inScheme = inScheme
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
        buf.toTpm(this.inScheme, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.createFromTpm(TPM_HANDLE)
        this.buffer = buf.fromTpm2B(2)
        this.inScheme = buf.fromTpm(2)
    
    
# TPM2_MAC_REQUEST

# This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
class MACResponse(TpmStructure):
    def __init__(self,
        # the returned MAC in a sized buffer
        outMAC = None
    ): 
        self.init()
        self.outMAC = outMAC
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.outMAC)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.outMAC = buf.fromTpm2B(2)
    
    
# MACResponse

# This command returns the next bytesRequested octets from the random number generator (RNG).
class TPM2_GetRandom_REQUEST(TpmStructure):
    def __init__(self,
        # number of octets to return
        bytesRequested = 0
    ): 
        self.init()
        self.bytesRequested = bytesRequested
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.bytesRequested, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.bytesRequested = buf.fromTpm(2)
    
    
# TPM2_GetRandom_REQUEST

# This command returns the next bytesRequested octets from the random number generator (RNG).
class GetRandomResponse(TpmStructure):
    def __init__(self,
        # the random octets
        randomBytes = None
    ): 
        self.init()
        self.randomBytes = randomBytes
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.randomBytes)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.randomBytes = buf.fromTpm2B(2)
    
    
# GetRandomResponse

# This command is used to add "additional information" to the RNG state.
class TPM2_StirRandom_REQUEST(TpmStructure):
    def __init__(self,
        # additional information
        inData = None
    ): 
        self.init()
        self.inData = inData
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.inData)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.inData = buf.fromTpm2B(2)
    
    
# TPM2_StirRandom_REQUEST

# This command is used to add "additional information" to the RNG state.
class StirRandomResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# StirRandomResponse

# This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
class TPM2_HMAC_Start_REQUEST(TpmStructure):
    def __init__(self,
        # handle of an HMAC key Auth Index: 1 Auth Role: USER
        handle = None,
        # authorization value for subsequent use of the sequence
        auth = None,
        # the hash algorithm to use for the HMAC
        hashAlg = 0
    ): 
        self.init()
        self.handle = handle
        self.auth = auth
        self.hashAlg = hashAlg
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.auth)
        buf.toTpm(this.hashAlg, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.createFromTpm(TPM_HANDLE)
        this.auth = buf.fromTpm2B(2)
        this.hashAlg = buf.fromTpm(2)
    
    
# TPM2_HMAC_Start_REQUEST

# This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
class HMAC_StartResponse(TpmStructure):
    def __init__(self,
        # a handle to reference the sequence
        handle = None
    ): 
        self.init()
        self.handle = handle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.handle.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.createFromTpm(TPM_HANDLE)
    
    
# HMAC_StartResponse

# This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
class TPM2_MAC_Start_REQUEST(TpmStructure):
    def __init__(self,
        # handle of a MAC key Auth Index: 1 Auth Role: USER
        handle = None,
        # authorization value for subsequent use of the sequence
        auth = None,
        # the algorithm to use for the MAC
        inScheme = 0
    ): 
        self.init()
        self.handle = handle
        self.auth = auth
        self.inScheme = inScheme
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.auth)
        buf.toTpm(this.inScheme, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.createFromTpm(TPM_HANDLE)
        this.auth = buf.fromTpm2B(2)
        this.inScheme = buf.fromTpm(2)
    
    
# TPM2_MAC_Start_REQUEST

# This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
class MAC_StartResponse(TpmStructure):
    def __init__(self,
        # a handle to reference the sequence
        handle = None
    ): 
        self.init()
        self.handle = handle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.handle.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.createFromTpm(TPM_HANDLE)
    
    
# MAC_StartResponse

# This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
class TPM2_HashSequenceStart_REQUEST(TpmStructure):
    def __init__(self,
        # authorization value for subsequent use of the sequence
        auth = None,
        # the hash algorithm to use for the hash sequence An Event Sequence starts if this is TPM_ALG_NULL.
        hashAlg = 0
    ): 
        self.init()
        self.auth = auth
        self.hashAlg = hashAlg
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.auth)
        buf.toTpm(this.hashAlg, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.auth = buf.fromTpm2B(2)
        this.hashAlg = buf.fromTpm(2)
    
    
# TPM2_HashSequenceStart_REQUEST

# This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
class HashSequenceStartResponse(TpmStructure):
    def __init__(self,
        # a handle to reference the sequence
        handle = None
    ): 
        self.init()
        self.handle = handle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.handle.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.createFromTpm(TPM_HANDLE)
    
    
# HashSequenceStartResponse

# This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
class TPM2_SequenceUpdate_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the sequence object Auth Index: 1 Auth Role: USER
        sequenceHandle = None,
        # data to be added to hash
        buffer = None
    ): 
        self.init()
        self.sequenceHandle = sequenceHandle
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.sequenceHandle = buf.createFromTpm(TPM_HANDLE)
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2_SequenceUpdate_REQUEST

# This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
class SequenceUpdateResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# SequenceUpdateResponse

# This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
class TPM2_SequenceComplete_REQUEST(TpmStructure):
    def __init__(self,
        # authorization for the sequence Auth Index: 1 Auth Role: USER
        sequenceHandle = None,
        # data to be added to the hash/HMAC
        buffer = None,
        # hierarchy of the ticket for a hash
        hierarchy = None
    ): 
        self.init()
        self.sequenceHandle = sequenceHandle
        self.buffer = buffer
        self.hierarchy = hierarchy
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
        this.hierarchy.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.sequenceHandle = buf.createFromTpm(TPM_HANDLE)
        this.buffer = buf.fromTpm2B(2)
        this.hierarchy = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_SequenceComplete_REQUEST

# This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
class SequenceCompleteResponse(TpmStructure):
    def __init__(self,
        # the returned HMAC or digest in a sized buffer
        result = None,
        # ticket indicating that the sequence of octets used to compute outDigest did not start with TPM_GENERATED_VALUE This is a NULL Ticket when the sequence is HMAC.
        validation = None
    ): 
        self.init()
        self.result = result
        self.validation = validation
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.result)
        this.validation.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.result = buf.fromTpm2B(2)
        this.validation = buf.createFromTpm(TPMT_TK_HASHCHECK)
    
    
# SequenceCompleteResponse

# This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
class TPM2_EventSequenceComplete_REQUEST(TpmStructure):
    def __init__(self,
        # PCR to be extended with the Event data Auth Index: 1 Auth Role: USER
        pcrHandle = None,
        # authorization for the sequence Auth Index: 2 Auth Role: USER
        sequenceHandle = None,
        # data to be added to the Event
        buffer = None
    ): 
        self.init()
        self.pcrHandle = pcrHandle
        self.sequenceHandle = sequenceHandle
        self.buffer = buffer
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.buffer)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.pcrHandle = buf.createFromTpm(TPM_HANDLE)
        this.sequenceHandle = buf.createFromTpm(TPM_HANDLE)
        this.buffer = buf.fromTpm2B(2)
    
    
# TPM2_EventSequenceComplete_REQUEST

# This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
class EventSequenceCompleteResponse(TpmStructure):
    def __init__(self,
        # list of digests computed for the PCR
        results = None
    ): 
        self.init()
        self.results = results
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.results, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.results = buf.arrayFromTpm(TPMT_HA, 4)
    
    
# EventSequenceCompleteResponse

# The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
class TPM2_Certify_REQUEST(TpmStructure):
    def __init__(self,
        # handle of the object to be certified Auth Index: 1 Auth Role: ADMIN
        objectHandle = None,
        # handle of the key used to sign the attestation structure Auth Index: 2 Auth Role: USER
        signHandle = None,
        # user provided qualifying data
        qualifyingData = None,
        # signing scheme to use if the scheme for signHandle is TPM_ALG_NULL (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        inScheme = None
    ): 
        self.init()
        self.objectHandle = objectHandle
        self.signHandle = signHandle
        self.qualifyingData = qualifyingData
        self.inScheme = inScheme
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.qualifyingData)
        buf.toTpm(this.inScheme.GetUnionSelector(), 2)
        this.inScheme.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.objectHandle = buf.createFromTpm(TPM_HANDLE)
        this.signHandle = buf.createFromTpm(TPM_HANDLE)
        this.qualifyingData = buf.fromTpm2B(2)
        inSchemeScheme = buf.fromTpm(2)
        this.inScheme = createUnion('TPMU_SIG_SCHEME', inSchemeScheme)
        this.inScheme.fromTpm(buf)
    
    
# TPM2_Certify_REQUEST

# The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
class CertifyResponse(TpmStructure):
    def __init__(self,
        # the structure that was signed
        certifyInfo = None,
        # the asymmetric signature over certifyInfo using the key referenced by signHandle (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        signature = None
    ): 
        self.init()
        self.certifyInfo = certifyInfo
        self.signature = signature
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.certifyInfo, 2)
        buf.toTpm(this.signature.GetUnionSelector(), 2)
        this.signature.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.certifyInfo = buf.sizedFromTpm(TPMS_ATTEST, 2)
        signatureSigAlg = buf.fromTpm(2)
        this.signature = createUnion('TPMU_SIGNATURE', signatureSigAlg)
        this.signature.fromTpm(buf)
    
    
# CertifyResponse

# This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
class TPM2_CertifyCreation_REQUEST(TpmStructure):
    def __init__(self,
        # handle of the key that will sign the attestation block Auth Index: 1 Auth Role: USER
        signHandle = None,
        # the object associated with the creation data Auth Index: None
        objectHandle = None,
        # user-provided qualifying data
        qualifyingData = None,
        # hash of the creation data produced by TPM2_Create() or TPM2_CreatePrimary()
        creationHash = None,
        # signing scheme to use if the scheme for signHandle is TPM_ALG_NULL (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        inScheme = None,
        # ticket produced by TPM2_Create() or TPM2_CreatePrimary()
        creationTicket = None
    ): 
        self.init()
        self.signHandle = signHandle
        self.objectHandle = objectHandle
        self.qualifyingData = qualifyingData
        self.creationHash = creationHash
        self.inScheme = inScheme
        self.creationTicket = creationTicket
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.qualifyingData)
        buf.toTpm2B(this.creationHash)
        buf.toTpm(this.inScheme.GetUnionSelector(), 2)
        this.inScheme.toTpm(buf)
        this.creationTicket.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.signHandle = buf.createFromTpm(TPM_HANDLE)
        this.objectHandle = buf.createFromTpm(TPM_HANDLE)
        this.qualifyingData = buf.fromTpm2B(2)
        this.creationHash = buf.fromTpm2B(2)
        inSchemeScheme = buf.fromTpm(2)
        this.inScheme = createUnion('TPMU_SIG_SCHEME', inSchemeScheme)
        this.inScheme.fromTpm(buf)
        this.creationTicket = buf.createFromTpm(TPMT_TK_CREATION)
    
    
# TPM2_CertifyCreation_REQUEST

# This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
class CertifyCreationResponse(TpmStructure):
    def __init__(self,
        # the structure that was signed
        certifyInfo = None,
        # the signature over certifyInfo (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        signature = None
    ): 
        self.init()
        self.certifyInfo = certifyInfo
        self.signature = signature
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.certifyInfo, 2)
        buf.toTpm(this.signature.GetUnionSelector(), 2)
        this.signature.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.certifyInfo = buf.sizedFromTpm(TPMS_ATTEST, 2)
        signatureSigAlg = buf.fromTpm(2)
        this.signature = createUnion('TPMU_SIGNATURE', signatureSigAlg)
        this.signature.fromTpm(buf)
    
    
# CertifyCreationResponse

# This command is used to quote PCR values.
class TPM2_Quote_REQUEST(TpmStructure):
    def __init__(self,
        # handle of key that will perform signature Auth Index: 1 Auth Role: USER
        signHandle = None,
        # data supplied by the caller
        qualifyingData = None,
        # signing scheme to use if the scheme for signHandle is TPM_ALG_NULL (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        inScheme = None,
        # PCR set to quote
        PCRselect = None
    ): 
        self.init()
        self.signHandle = signHandle
        self.qualifyingData = qualifyingData
        self.inScheme = inScheme
        self.PCRselect = PCRselect
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.qualifyingData)
        buf.toTpm(this.inScheme.GetUnionSelector(), 2)
        this.inScheme.toTpm(buf)
        buf.arrayToTpm(this.PCRselect, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.signHandle = buf.createFromTpm(TPM_HANDLE)
        this.qualifyingData = buf.fromTpm2B(2)
        inSchemeScheme = buf.fromTpm(2)
        this.inScheme = createUnion('TPMU_SIG_SCHEME', inSchemeScheme)
        this.inScheme.fromTpm(buf)
        this.PCRselect = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4)
    
    
# TPM2_Quote_REQUEST

# This command is used to quote PCR values.
class QuoteResponse(TpmStructure):
    def __init__(self,
        # the quoted information
        quoted = None,
        # the signature over quoted (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        signature = None
    ): 
        self.init()
        self.quoted = quoted
        self.signature = signature
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.quoted, 2)
        buf.toTpm(this.signature.GetUnionSelector(), 2)
        this.signature.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.quoted = buf.sizedFromTpm(TPMS_ATTEST, 2)
        signatureSigAlg = buf.fromTpm(2)
        this.signature = createUnion('TPMU_SIGNATURE', signatureSigAlg)
        this.signature.fromTpm(buf)
    
    
# QuoteResponse

# This command returns a digital signature of the audit session digest.
class TPM2_GetSessionAuditDigest_REQUEST(TpmStructure):
    def __init__(self,
        # handle of the privacy administrator (TPM_RH_ENDORSEMENT) Auth Index: 1 Auth Role: USER
        privacyAdminHandle = None,
        # handle of the signing key Auth Index: 2 Auth Role: USER
        signHandle = None,
        # handle of the audit session Auth Index: None
        sessionHandle = None,
        # user-provided qualifying data may be zero-length
        qualifyingData = None,
        # signing scheme to use if the scheme for signHandle is TPM_ALG_NULL (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        inScheme = None
    ): 
        self.init()
        self.privacyAdminHandle = privacyAdminHandle
        self.signHandle = signHandle
        self.sessionHandle = sessionHandle
        self.qualifyingData = qualifyingData
        self.inScheme = inScheme
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.qualifyingData)
        buf.toTpm(this.inScheme.GetUnionSelector(), 2)
        this.inScheme.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.privacyAdminHandle = buf.createFromTpm(TPM_HANDLE)
        this.signHandle = buf.createFromTpm(TPM_HANDLE)
        this.sessionHandle = buf.createFromTpm(TPM_HANDLE)
        this.qualifyingData = buf.fromTpm2B(2)
        inSchemeScheme = buf.fromTpm(2)
        this.inScheme = createUnion('TPMU_SIG_SCHEME', inSchemeScheme)
        this.inScheme.fromTpm(buf)
    
    
# TPM2_GetSessionAuditDigest_REQUEST

# This command returns a digital signature of the audit session digest.
class GetSessionAuditDigestResponse(TpmStructure):
    def __init__(self,
        # the audit information that was signed
        auditInfo = None,
        # the signature over auditInfo (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        signature = None
    ): 
        self.init()
        self.auditInfo = auditInfo
        self.signature = signature
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.auditInfo, 2)
        buf.toTpm(this.signature.GetUnionSelector(), 2)
        this.signature.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.auditInfo = buf.sizedFromTpm(TPMS_ATTEST, 2)
        signatureSigAlg = buf.fromTpm(2)
        this.signature = createUnion('TPMU_SIGNATURE', signatureSigAlg)
        this.signature.fromTpm(buf)
    
    
# GetSessionAuditDigestResponse

# This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
class TPM2_GetCommandAuditDigest_REQUEST(TpmStructure):
    def __init__(self,
        # handle of the privacy administrator (TPM_RH_ENDORSEMENT) Auth Index: 1 Auth Role: USER
        privacyHandle = None,
        # the handle of the signing key Auth Index: 2 Auth Role: USER
        signHandle = None,
        # other data to associate with this audit digest
        qualifyingData = None,
        # signing scheme to use if the scheme for signHandle is TPM_ALG_NULL (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        inScheme = None
    ): 
        self.init()
        self.privacyHandle = privacyHandle
        self.signHandle = signHandle
        self.qualifyingData = qualifyingData
        self.inScheme = inScheme
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.qualifyingData)
        buf.toTpm(this.inScheme.GetUnionSelector(), 2)
        this.inScheme.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.privacyHandle = buf.createFromTpm(TPM_HANDLE)
        this.signHandle = buf.createFromTpm(TPM_HANDLE)
        this.qualifyingData = buf.fromTpm2B(2)
        inSchemeScheme = buf.fromTpm(2)
        this.inScheme = createUnion('TPMU_SIG_SCHEME', inSchemeScheme)
        this.inScheme.fromTpm(buf)
    
    
# TPM2_GetCommandAuditDigest_REQUEST

# This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
class GetCommandAuditDigestResponse(TpmStructure):
    def __init__(self,
        # the auditInfo that was signed
        auditInfo = None,
        # the signature over auditInfo (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        signature = None
    ): 
        self.init()
        self.auditInfo = auditInfo
        self.signature = signature
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.auditInfo, 2)
        buf.toTpm(this.signature.GetUnionSelector(), 2)
        this.signature.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.auditInfo = buf.sizedFromTpm(TPMS_ATTEST, 2)
        signatureSigAlg = buf.fromTpm(2)
        this.signature = createUnion('TPMU_SIGNATURE', signatureSigAlg)
        this.signature.fromTpm(buf)
    
    
# GetCommandAuditDigestResponse

# This command returns the current values of Time and Clock.
class TPM2_GetTime_REQUEST(TpmStructure):
    def __init__(self,
        # handle of the privacy administrator (TPM_RH_ENDORSEMENT) Auth Index: 1 Auth Role: USER
        privacyAdminHandle = None,
        # the keyHandle identifier of a loaded key that can perform digital signatures Auth Index: 2 Auth Role: USER
        signHandle = None,
        # data to tick stamp
        qualifyingData = None,
        # signing scheme to use if the scheme for signHandle is TPM_ALG_NULL (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        inScheme = None
    ): 
        self.init()
        self.privacyAdminHandle = privacyAdminHandle
        self.signHandle = signHandle
        self.qualifyingData = qualifyingData
        self.inScheme = inScheme
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.qualifyingData)
        buf.toTpm(this.inScheme.GetUnionSelector(), 2)
        this.inScheme.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.privacyAdminHandle = buf.createFromTpm(TPM_HANDLE)
        this.signHandle = buf.createFromTpm(TPM_HANDLE)
        this.qualifyingData = buf.fromTpm2B(2)
        inSchemeScheme = buf.fromTpm(2)
        this.inScheme = createUnion('TPMU_SIG_SCHEME', inSchemeScheme)
        this.inScheme.fromTpm(buf)
    
    
# TPM2_GetTime_REQUEST

# This command returns the current values of Time and Clock.
class GetTimeResponse(TpmStructure):
    def __init__(self,
        # standard TPM-generated attestation block
        timeInfo = None,
        # the signature over timeInfo (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        signature = None
    ): 
        self.init()
        self.timeInfo = timeInfo
        self.signature = signature
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.timeInfo, 2)
        buf.toTpm(this.signature.GetUnionSelector(), 2)
        this.signature.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.timeInfo = buf.sizedFromTpm(TPMS_ATTEST, 2)
        signatureSigAlg = buf.fromTpm(2)
        this.signature = createUnion('TPMU_SIGNATURE', signatureSigAlg)
        this.signature.fromTpm(buf)
    
    
# GetTimeResponse

# TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
class TPM2_Commit_REQUEST(TpmStructure):
    def __init__(self,
        # handle of the key that will be used in the signing operation Auth Index: 1 Auth Role: USER
        signHandle = None,
        # a point (M) on the curve used by signHandle
        P1 = None,
        # octet array used to derive x-coordinate of a base point
        s2 = None,
        # y coordinate of the point associated with s2
        y2 = None
    ): 
        self.init()
        self.signHandle = signHandle
        self.P1 = P1
        self.s2 = s2
        self.y2 = y2
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.P1, 2)
        buf.toTpm2B(this.s2)
        buf.toTpm2B(this.y2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.signHandle = buf.createFromTpm(TPM_HANDLE)
        this.P1 = buf.sizedFromTpm(TPMS_ECC_POINT, 2)
        this.s2 = buf.fromTpm2B(2)
        this.y2 = buf.fromTpm2B(2)
    
    
# TPM2_Commit_REQUEST

# TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
class CommitResponse(TpmStructure):
    def __init__(self,
        # ECC point K [ds](x2, y2)
        K = None,
        # ECC point L [r](x2, y2)
        L = None,
        # ECC point E [r]P1
        E = None,
        # least-significant 16 bits of commitCount
        counter = 0
    ): 
        self.init()
        self.K = K
        self.L = L
        self.E = E
        self.counter = counter
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.K, 2)
        buf.sizedToTpm(this.L, 2)
        buf.sizedToTpm(this.E, 2)
        buf.toTpm(this.counter, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.K = buf.sizedFromTpm(TPMS_ECC_POINT, 2)
        this.L = buf.sizedFromTpm(TPMS_ECC_POINT, 2)
        this.E = buf.sizedFromTpm(TPMS_ECC_POINT, 2)
        this.counter = buf.fromTpm(2)
    
    
# CommitResponse

# TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
class TPM2_EC_Ephemeral_REQUEST(TpmStructure):
    def __init__(self,
        # The curve for the computed ephemeral point
        curveID = 0
    ): 
        self.init()
        self.curveID = curveID
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.curveID, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.curveID = buf.fromTpm(2)
    
    
# TPM2_EC_Ephemeral_REQUEST

# TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
class EC_EphemeralResponse(TpmStructure):
    def __init__(self,
        # ephemeral public key Q [r]G
        Q = None,
        # least-significant 16 bits of commitCount
        counter = 0
    ): 
        self.init()
        self.Q = Q
        self.counter = counter
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.Q, 2)
        buf.toTpm(this.counter, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.Q = buf.sizedFromTpm(TPMS_ECC_POINT, 2)
        this.counter = buf.fromTpm(2)
    
    
# EC_EphemeralResponse

# This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
class TPM2_VerifySignature_REQUEST(TpmStructure):
    def __init__(self,
        # handle of public key that will be used in the validation Auth Index: None
        keyHandle = None,
        # digest of the signed message
        digest = None,
        # signature to be tested (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        signature = None
    ): 
        self.init()
        self.keyHandle = keyHandle
        self.digest = digest
        self.signature = signature
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.digest)
        buf.toTpm(this.signature.GetUnionSelector(), 2)
        this.signature.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.keyHandle = buf.createFromTpm(TPM_HANDLE)
        this.digest = buf.fromTpm2B(2)
        signatureSigAlg = buf.fromTpm(2)
        this.signature = createUnion('TPMU_SIGNATURE', signatureSigAlg)
        this.signature.fromTpm(buf)
    
    
# TPM2_VerifySignature_REQUEST

# This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
class VerifySignatureResponse(TpmStructure):
    def __init__(self,
        # -
        validation = None
    ): 
        self.init()
        self.validation = validation
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.validation.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.validation = buf.createFromTpm(TPMT_TK_VERIFIED)
    
    
# VerifySignatureResponse

# This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
class TPM2_Sign_REQUEST(TpmStructure):
    def __init__(self,
        # Handle of key that will perform signing Auth Index: 1 Auth Role: USER
        keyHandle = None,
        # digest to be signed
        digest = None,
        # signing scheme to use if the scheme for keyHandle is TPM_ALG_NULL (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        inScheme = None,
        # proof that digest was created by the TPM If keyHandle is not a restricted signing key, then this may be a NULL Ticket with tag = TPM_ST_CHECKHASH.
        validation = None
    ): 
        self.init()
        self.keyHandle = keyHandle
        self.digest = digest
        self.inScheme = inScheme
        self.validation = validation
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.digest)
        buf.toTpm(this.inScheme.GetUnionSelector(), 2)
        this.inScheme.toTpm(buf)
        this.validation.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.keyHandle = buf.createFromTpm(TPM_HANDLE)
        this.digest = buf.fromTpm2B(2)
        inSchemeScheme = buf.fromTpm(2)
        this.inScheme = createUnion('TPMU_SIG_SCHEME', inSchemeScheme)
        this.inScheme.fromTpm(buf)
        this.validation = buf.createFromTpm(TPMT_TK_HASHCHECK)
    
    
# TPM2_Sign_REQUEST

# This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
class SignResponse(TpmStructure):
    def __init__(self,
        # the signature (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        signature = None
    ): 
        self.init()
        self.signature = signature
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.signature.GetUnionSelector(), 2)
        this.signature.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        signatureSigAlg = buf.fromTpm(2)
        this.signature = createUnion('TPMU_SIGNATURE', signatureSigAlg)
        this.signature.fromTpm(buf)
    
    
# SignResponse

# This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
class TPM2_SetCommandCodeAuditStatus_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        auth = None,
        # hash algorithm for the audit digest; if TPM_ALG_NULL, then the hash is not changed
        auditAlg = 0,
        # list of commands that will be added to those that will be audited
        setList = None,
        # list of commands that will no longer be audited
        clearList = None
    ): 
        self.init()
        self.auth = auth
        self.auditAlg = auditAlg
        self.setList = setList
        self.clearList = clearList
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.auditAlg, 2)
        buf.valArrToTpm(this.setList, 4, 4)
        buf.valArrToTpm(this.clearList, 4, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.auth = buf.createFromTpm(TPM_HANDLE)
        this.auditAlg = buf.fromTpm(2)
        this.setList = buf.valArrFromTpm(4, 4)
        this.clearList = buf.valArrFromTpm(4, 4)
    
    
# TPM2_SetCommandCodeAuditStatus_REQUEST

# This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
class SetCommandCodeAuditStatusResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# SetCommandCodeAuditStatusResponse

# This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
class TPM2_PCR_Extend_REQUEST(TpmStructure):
    def __init__(self,
        # handle of the PCR Auth Handle: 1 Auth Role: USER
        pcrHandle = None,
        # list of tagged digest values to be extended
        digests = None
    ): 
        self.init()
        self.pcrHandle = pcrHandle
        self.digests = digests
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.digests, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.pcrHandle = buf.createFromTpm(TPM_HANDLE)
        this.digests = buf.arrayFromTpm(TPMT_HA, 4)
    
    
# TPM2_PCR_Extend_REQUEST

# This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
class PCR_ExtendResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PCR_ExtendResponse

# This command is used to cause an update to the indicated PCR.
class TPM2_PCR_Event_REQUEST(TpmStructure):
    def __init__(self,
        # Handle of the PCR Auth Handle: 1 Auth Role: USER
        pcrHandle = None,
        # Event data in sized buffer
        eventData = None
    ): 
        self.init()
        self.pcrHandle = pcrHandle
        self.eventData = eventData
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.eventData)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.pcrHandle = buf.createFromTpm(TPM_HANDLE)
        this.eventData = buf.fromTpm2B(2)
    
    
# TPM2_PCR_Event_REQUEST

# This command is used to cause an update to the indicated PCR.
class PCR_EventResponse(TpmStructure):
    def __init__(self,
        # -
        digests = None
    ): 
        self.init()
        self.digests = digests
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.digests, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.digests = buf.arrayFromTpm(TPMT_HA, 4)
    
    
# PCR_EventResponse

# This command returns the values of all PCR specified in pcrSelectionIn.
class TPM2_PCR_Read_REQUEST(TpmStructure):
    def __init__(self,
        # The selection of PCR to read
        pcrSelectionIn = None
    ): 
        self.init()
        self.pcrSelectionIn = pcrSelectionIn
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.pcrSelectionIn, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.pcrSelectionIn = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4)
    
    
# TPM2_PCR_Read_REQUEST

# This command returns the values of all PCR specified in pcrSelectionIn.
class PCR_ReadResponse(TpmStructure):
    def __init__(self,
        # the current value of the PCR update counter
        pcrUpdateCounter = 0,
        # the PCR in the returned list
        pcrSelectionOut = None,
        # the contents of the PCR indicated in pcrSelectOut-) pcrSelection[] as tagged digests
        pcrValues = None
    ): 
        self.init()
        self.pcrUpdateCounter = pcrUpdateCounter
        self.pcrSelectionOut = pcrSelectionOut
        self.pcrValues = pcrValues
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.pcrUpdateCounter, 4)
        buf.arrayToTpm(this.pcrSelectionOut, 4)
        buf.arrayToTpm(this.pcrValues, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.pcrUpdateCounter = buf.fromTpm(4)
        this.pcrSelectionOut = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4)
        this.pcrValues = buf.arrayFromTpm(TPM2B_DIGEST, 4)
    
    
# PCR_ReadResponse

# This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
class TPM2_PCR_Allocate_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        authHandle = None,
        # the requested allocation
        pcrAllocation = None
    ): 
        self.init()
        self.authHandle = authHandle
        self.pcrAllocation = pcrAllocation
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.pcrAllocation, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.pcrAllocation = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4)
    
    
# TPM2_PCR_Allocate_REQUEST

# This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
class PCR_AllocateResponse(TpmStructure):
    def __init__(self,
        # YES if the allocation succeeded
        allocationSuccess = 0,
        # maximum number of PCR that may be in a bank
        maxPCR = 0,
        # number of octets required to satisfy the request
        sizeNeeded = 0,
        # Number of octets available. Computed before the allocation.
        sizeAvailable = 0
    ): 
        self.init()
        self.allocationSuccess = allocationSuccess
        self.maxPCR = maxPCR
        self.sizeNeeded = sizeNeeded
        self.sizeAvailable = sizeAvailable
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.allocationSuccess, 1)
        buf.toTpm(this.maxPCR, 4)
        buf.toTpm(this.sizeNeeded, 4)
        buf.toTpm(this.sizeAvailable, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.allocationSuccess = buf.fromTpm(1)
        this.maxPCR = buf.fromTpm(4)
        this.sizeNeeded = buf.fromTpm(4)
        this.sizeAvailable = buf.fromTpm(4)
    
    
# PCR_AllocateResponse

# This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
class TPM2_PCR_SetAuthPolicy_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        authHandle = None,
        # the desired authPolicy
        authPolicy = None,
        # the hash algorithm of the policy
        hashAlg = 0,
        # the PCR for which the policy is to be set
        pcrNum = None
    ): 
        self.init()
        self.authHandle = authHandle
        self.authPolicy = authPolicy
        self.hashAlg = hashAlg
        self.pcrNum = pcrNum
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.authPolicy)
        buf.toTpm(this.hashAlg, 2)
        this.pcrNum.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.authPolicy = buf.fromTpm2B(2)
        this.hashAlg = buf.fromTpm(2)
        this.pcrNum = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_PCR_SetAuthPolicy_REQUEST

# This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
class PCR_SetAuthPolicyResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PCR_SetAuthPolicyResponse

# This command changes the authValue of a PCR or group of PCR.
class TPM2_PCR_SetAuthValue_REQUEST(TpmStructure):
    def __init__(self,
        # handle for a PCR that may have an authorization value set Auth Index: 1 Auth Role: USER
        pcrHandle = None,
        # the desired authorization value
        auth = None
    ): 
        self.init()
        self.pcrHandle = pcrHandle
        self.auth = auth
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.auth)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.pcrHandle = buf.createFromTpm(TPM_HANDLE)
        this.auth = buf.fromTpm2B(2)
    
    
# TPM2_PCR_SetAuthValue_REQUEST

# This command changes the authValue of a PCR or group of PCR.
class PCR_SetAuthValueResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PCR_SetAuthValueResponse

# If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
class TPM2_PCR_Reset_REQUEST(TpmStructure):
    def __init__(self,
        # the PCR to reset Auth Index: 1 Auth Role: USER
        pcrHandle = None
    ): 
        self.init()
        self.pcrHandle = pcrHandle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.pcrHandle = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_PCR_Reset_REQUEST

# If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
class PCR_ResetResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PCR_ResetResponse

# This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
class TPM2_PolicySigned_REQUEST(TpmStructure):
    def __init__(self,
        # handle for a key that will validate the signature Auth Index: None
        authObject = None,
        # handle for the policy session being extended Auth Index: None
        policySession = None,
        # the policy nonce for the session This can be the Empty Buffer.
        nonceTPM = None,
        # digest of the command parameters to which this authorization is limited This is not the cpHash for this command but the cpHash for the command to which this policy session will be applied. If it is not limited, the parameter will be the Empty Buffer.
        cpHashA = None,
        # a reference to a policy relating to the authorization may be the Empty Buffer Size is limited to be no larger than the nonce size supported on the TPM.
        policyRef = None,
        # time when authorization will expire, measured in seconds from the time that nonceTPM was generated If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
        expiration = 0,
        # signed authorization (not optional) (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        auth = None
    ): 
        self.init()
        self.authObject = authObject
        self.policySession = policySession
        self.nonceTPM = nonceTPM
        self.cpHashA = cpHashA
        self.policyRef = policyRef
        self.expiration = expiration
        self.auth = auth
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.nonceTPM)
        buf.toTpm2B(this.cpHashA)
        buf.toTpm2B(this.policyRef)
        buf.toTpm(this.expiration, 4)
        buf.toTpm(this.auth.GetUnionSelector(), 2)
        this.auth.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authObject = buf.createFromTpm(TPM_HANDLE)
        this.policySession = buf.createFromTpm(TPM_HANDLE)
        this.nonceTPM = buf.fromTpm2B(2)
        this.cpHashA = buf.fromTpm2B(2)
        this.policyRef = buf.fromTpm2B(2)
        this.expiration = buf.fromTpm(4)
        authSigAlg = buf.fromTpm(2)
        this.auth = createUnion('TPMU_SIGNATURE', authSigAlg)
        this.auth.fromTpm(buf)
    
    
# TPM2_PolicySigned_REQUEST

# This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
class PolicySignedResponse(TpmStructure):
    def __init__(self,
        # implementation-specific time value, used to indicate to the TPM when the ticket expires NOTE If policyTicket is a NULL Ticket, then this shall be the Empty Buffer.
        timeout = None,
        # produced if the command succeeds and expiration in the command was non-zero; this ticket will use the TPMT_ST_AUTH_SIGNED structure tag. See 23.2.5
        policyTicket = None
    ): 
        self.init()
        self.timeout = timeout
        self.policyTicket = policyTicket
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.timeout)
        this.policyTicket.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.timeout = buf.fromTpm2B(2)
        this.policyTicket = buf.createFromTpm(TPMT_TK_AUTH)
    
    
# PolicySignedResponse

# This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
class TPM2_PolicySecret_REQUEST(TpmStructure):
    def __init__(self,
        # handle for an entity providing the authorization Auth Index: 1 Auth Role: USER
        authHandle = None,
        # handle for the policy session being extended Auth Index: None
        policySession = None,
        # the policy nonce for the session This can be the Empty Buffer.
        nonceTPM = None,
        # digest of the command parameters to which this authorization is limited This not the cpHash for this command but the cpHash for the command to which this policy session will be applied. If it is not limited, the parameter will be the Empty Buffer.
        cpHashA = None,
        # a reference to a policy relating to the authorization may be the Empty Buffer Size is limited to be no larger than the nonce size supported on the TPM.
        policyRef = None,
        # time when authorization will expire, measured in seconds from the time that nonceTPM was generated If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
        expiration = 0
    ): 
        self.init()
        self.authHandle = authHandle
        self.policySession = policySession
        self.nonceTPM = nonceTPM
        self.cpHashA = cpHashA
        self.policyRef = policyRef
        self.expiration = expiration
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.nonceTPM)
        buf.toTpm2B(this.cpHashA)
        buf.toTpm2B(this.policyRef)
        buf.toTpm(this.expiration, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.policySession = buf.createFromTpm(TPM_HANDLE)
        this.nonceTPM = buf.fromTpm2B(2)
        this.cpHashA = buf.fromTpm2B(2)
        this.policyRef = buf.fromTpm2B(2)
        this.expiration = buf.fromTpm(4)
    
    
# TPM2_PolicySecret_REQUEST

# This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
class PolicySecretResponse(TpmStructure):
    def __init__(self,
        # implementation-specific time value used to indicate to the TPM when the ticket expires
        timeout = None,
        # produced if the command succeeds and expiration in the command was non-zero ( See 23.2.5). This ticket will use the TPMT_ST_AUTH_SECRET structure tag
        policyTicket = None
    ): 
        self.init()
        self.timeout = timeout
        self.policyTicket = policyTicket
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.timeout)
        this.policyTicket.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.timeout = buf.fromTpm2B(2)
        this.policyTicket = buf.createFromTpm(TPMT_TK_AUTH)
    
    
# PolicySecretResponse

# This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
class TPM2_PolicyTicket_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session being extended Auth Index: None
        policySession = None,
        # time when authorization will expire The contents are TPM specific. This shall be the value returned when ticket was produced.
        timeout = None,
        # digest of the command parameters to which this authorization is limited If it is not limited, the parameter will be the Empty Buffer.
        cpHashA = None,
        # reference to a qualifier for the policy may be the Empty Buffer
        policyRef = None,
        # name of the object that provided the authorization
        authName = None,
        # an authorization ticket returned by the TPM in response to a TPM2_PolicySigned() or TPM2_PolicySecret()
        ticket = None
    ): 
        self.init()
        self.policySession = policySession
        self.timeout = timeout
        self.cpHashA = cpHashA
        self.policyRef = policyRef
        self.authName = authName
        self.ticket = ticket
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.timeout)
        buf.toTpm2B(this.cpHashA)
        buf.toTpm2B(this.policyRef)
        buf.toTpm2B(this.authName)
        this.ticket.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
        this.timeout = buf.fromTpm2B(2)
        this.cpHashA = buf.fromTpm2B(2)
        this.policyRef = buf.fromTpm2B(2)
        this.authName = buf.fromTpm2B(2)
        this.ticket = buf.createFromTpm(TPMT_TK_AUTH)
    
    
# TPM2_PolicyTicket_REQUEST

# This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
class PolicyTicketResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyTicketResponse

# This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
class TPM2_PolicyOR_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session being extended Auth Index: None
        policySession = None,
        # the list of hashes to check for a match
        pHashList = None
    ): 
        self.init()
        self.policySession = policySession
        self.pHashList = pHashList
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.arrayToTpm(this.pHashList, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
        this.pHashList = buf.arrayFromTpm(TPM2B_DIGEST, 4)
    
    
# TPM2_PolicyOR_REQUEST

# This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
class PolicyORResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyORResponse

# This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
class TPM2_PolicyPCR_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session being extended Auth Index: None
        policySession = None,
        # expected digest value of the selected PCR using the hash algorithm of the session; may be zero length
        pcrDigest = None,
        # the PCR to include in the check digest
        pcrs = None
    ): 
        self.init()
        self.policySession = policySession
        self.pcrDigest = pcrDigest
        self.pcrs = pcrs
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.pcrDigest)
        buf.arrayToTpm(this.pcrs, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
        this.pcrDigest = buf.fromTpm2B(2)
        this.pcrs = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4)
    
    
# TPM2_PolicyPCR_REQUEST

# This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
class PolicyPCRResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyPCRResponse

# This command indicates that the authorization will be limited to a specific locality.
class TPM2_PolicyLocality_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session being extended Auth Index: None
        policySession = None,
        # the allowed localities for the policy
        locality = 0
    ): 
        self.init()
        self.policySession = policySession
        self.locality = locality
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.locality, 1)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
        this.locality = buf.fromTpm(1)
    
    
# TPM2_PolicyLocality_REQUEST

# This command indicates that the authorization will be limited to a specific locality.
class PolicyLocalityResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyLocalityResponse

# This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
class TPM2_PolicyNV_REQUEST(TpmStructure):
    def __init__(self,
        # handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        authHandle = None,
        # the NV Index of the area to read Auth Index: None
        nvIndex = None,
        # handle for the policy session being extended Auth Index: None
        policySession = None,
        # the second operand
        operandB = None,
        # the octet offset in the NV Index for the start of operand A
        offset = 0,
        # the comparison to make
        operation = 0
    ): 
        self.init()
        self.authHandle = authHandle
        self.nvIndex = nvIndex
        self.policySession = policySession
        self.operandB = operandB
        self.offset = offset
        self.operation = operation
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.operandB)
        buf.toTpm(this.offset, 2)
        buf.toTpm(this.operation, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.nvIndex = buf.createFromTpm(TPM_HANDLE)
        this.policySession = buf.createFromTpm(TPM_HANDLE)
        this.operandB = buf.fromTpm2B(2)
        this.offset = buf.fromTpm(2)
        this.operation = buf.fromTpm(2)
    
    
# TPM2_PolicyNV_REQUEST

# This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
class PolicyNVResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyNVResponse

# This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
class TPM2_PolicyCounterTimer_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session being extended Auth Index: None
        policySession = None,
        # the second operand
        operandB = None,
        # the octet offset in the TPMS_TIME_INFO structure for the start of operand A
        offset = 0,
        # the comparison to make
        operation = 0
    ): 
        self.init()
        self.policySession = policySession
        self.operandB = operandB
        self.offset = offset
        self.operation = operation
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.operandB)
        buf.toTpm(this.offset, 2)
        buf.toTpm(this.operation, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
        this.operandB = buf.fromTpm2B(2)
        this.offset = buf.fromTpm(2)
        this.operation = buf.fromTpm(2)
    
    
# TPM2_PolicyCounterTimer_REQUEST

# This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
class PolicyCounterTimerResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyCounterTimerResponse

# This command indicates that the authorization will be limited to a specific command code.
class TPM2_PolicyCommandCode_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session being extended Auth Index: None
        policySession = None,
        # the allowed commandCode
        code = 0
    ): 
        self.init()
        self.policySession = policySession
        self.code = code
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.code, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
        this.code = buf.fromTpm(4)
    
    
# TPM2_PolicyCommandCode_REQUEST

# This command indicates that the authorization will be limited to a specific command code.
class PolicyCommandCodeResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyCommandCodeResponse

# This command indicates that physical presence will need to be asserted at the time the authorization is performed.
class TPM2_PolicyPhysicalPresence_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session being extended Auth Index: None
        policySession = None
    ): 
        self.init()
        self.policySession = policySession
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_PolicyPhysicalPresence_REQUEST

# This command indicates that physical presence will need to be asserted at the time the authorization is performed.
class PolicyPhysicalPresenceResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyPhysicalPresenceResponse

# This command is used to allow a policy to be bound to a specific command and command parameters.
class TPM2_PolicyCpHash_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session being extended Auth Index: None
        policySession = None,
        # the cpHash added to the policy
        cpHashA = None
    ): 
        self.init()
        self.policySession = policySession
        self.cpHashA = cpHashA
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.cpHashA)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
        this.cpHashA = buf.fromTpm2B(2)
    
    
# TPM2_PolicyCpHash_REQUEST

# This command is used to allow a policy to be bound to a specific command and command parameters.
class PolicyCpHashResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyCpHashResponse

# This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
class TPM2_PolicyNameHash_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session being extended Auth Index: None
        policySession = None,
        # the digest to be added to the policy
        nameHash = None
    ): 
        self.init()
        self.policySession = policySession
        self.nameHash = nameHash
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.nameHash)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
        this.nameHash = buf.fromTpm2B(2)
    
    
# TPM2_PolicyNameHash_REQUEST

# This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
class PolicyNameHashResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyNameHashResponse

# This command allows qualification of duplication to allow duplication to a selected new parent.
class TPM2_PolicyDuplicationSelect_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session being extended Auth Index: None
        policySession = None,
        # the Name of the object to be duplicated
        objectName = None,
        # the Name of the new parent
        newParentName = None,
        # if YES, the objectName will be included in the value in policySessionpolicyDigest
        includeObject = 0
    ): 
        self.init()
        self.policySession = policySession
        self.objectName = objectName
        self.newParentName = newParentName
        self.includeObject = includeObject
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.objectName)
        buf.toTpm2B(this.newParentName)
        buf.toTpm(this.includeObject, 1)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
        this.objectName = buf.fromTpm2B(2)
        this.newParentName = buf.fromTpm2B(2)
        this.includeObject = buf.fromTpm(1)
    
    
# TPM2_PolicyDuplicationSelect_REQUEST

# This command allows qualification of duplication to allow duplication to a selected new parent.
class PolicyDuplicationSelectResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyDuplicationSelectResponse

# This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
class TPM2_PolicyAuthorize_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session being extended Auth Index: None
        policySession = None,
        # digest of the policy being approved
        approvedPolicy = None,
        # a policy qualifier
        policyRef = None,
        # Name of a key that can sign a policy addition
        keySign = None,
        # ticket validating that approvedPolicy and policyRef were signed by keySign
        checkTicket = None
    ): 
        self.init()
        self.policySession = policySession
        self.approvedPolicy = approvedPolicy
        self.policyRef = policyRef
        self.keySign = keySign
        self.checkTicket = checkTicket
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.approvedPolicy)
        buf.toTpm2B(this.policyRef)
        buf.toTpm2B(this.keySign)
        this.checkTicket.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
        this.approvedPolicy = buf.fromTpm2B(2)
        this.policyRef = buf.fromTpm2B(2)
        this.keySign = buf.fromTpm2B(2)
        this.checkTicket = buf.createFromTpm(TPMT_TK_VERIFIED)
    
    
# TPM2_PolicyAuthorize_REQUEST

# This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
class PolicyAuthorizeResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyAuthorizeResponse

# This command allows a policy to be bound to the authorization value of the authorized entity.
class TPM2_PolicyAuthValue_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session being extended Auth Index: None
        policySession = None
    ): 
        self.init()
        self.policySession = policySession
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_PolicyAuthValue_REQUEST

# This command allows a policy to be bound to the authorization value of the authorized entity.
class PolicyAuthValueResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyAuthValueResponse

# This command allows a policy to be bound to the authorization value of the authorized object.
class TPM2_PolicyPassword_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session being extended Auth Index: None
        policySession = None
    ): 
        self.init()
        self.policySession = policySession
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_PolicyPassword_REQUEST

# This command allows a policy to be bound to the authorization value of the authorized object.
class PolicyPasswordResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyPasswordResponse

# This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
class TPM2_PolicyGetDigest_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session Auth Index: None
        policySession = None
    ): 
        self.init()
        self.policySession = policySession
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_PolicyGetDigest_REQUEST

# This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
class PolicyGetDigestResponse(TpmStructure):
    def __init__(self,
        # the current value of the policySessionpolicyDigest
        policyDigest = None
    ): 
        self.init()
        self.policyDigest = policyDigest
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.policyDigest)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policyDigest = buf.fromTpm2B(2)
    
    
# PolicyGetDigestResponse

# This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
class TPM2_PolicyNvWritten_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session being extended Auth Index: None
        policySession = None,
        # YES if NV Index is required to have been written NO if NV Index is required not to have been written
        writtenSet = 0
    ): 
        self.init()
        self.policySession = policySession
        self.writtenSet = writtenSet
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.writtenSet, 1)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
        this.writtenSet = buf.fromTpm(1)
    
    
# TPM2_PolicyNvWritten_REQUEST

# This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
class PolicyNvWrittenResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyNvWrittenResponse

# This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
class TPM2_PolicyTemplate_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session being extended Auth Index: None
        policySession = None,
        # the digest to be added to the policy
        templateHash = None
    ): 
        self.init()
        self.policySession = policySession
        self.templateHash = templateHash
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.templateHash)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
        this.templateHash = buf.fromTpm2B(2)
    
    
# TPM2_PolicyTemplate_REQUEST

# This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
class PolicyTemplateResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyTemplateResponse

# This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
class TPM2_PolicyAuthorizeNV_REQUEST(TpmStructure):
    def __init__(self,
        # handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        authHandle = None,
        # the NV Index of the area to read Auth Index: None
        nvIndex = None,
        # handle for the policy session being extended Auth Index: None
        policySession = None
    ): 
        self.init()
        self.authHandle = authHandle
        self.nvIndex = nvIndex
        self.policySession = policySession
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.nvIndex = buf.createFromTpm(TPM_HANDLE)
        this.policySession = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_PolicyAuthorizeNV_REQUEST

# This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
class PolicyAuthorizeNVResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PolicyAuthorizeNVResponse

# This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
class TPM2_CreatePrimary_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL Auth Index: 1 Auth Role: USER
        primaryHandle = None,
        # the sensitive data, see TPM 2.0 Part 1 Sensitive Values
        inSensitive = None,
        # the public template
        inPublic = None,
        # data that will be included in the creation data for this object to provide permanent, verifiable linkage between this object and some object owner data
        outsideInfo = None,
        # PCR that will be used in creation data
        creationPCR = None
    ): 
        self.init()
        self.primaryHandle = primaryHandle
        self.inSensitive = inSensitive
        self.inPublic = inPublic
        self.outsideInfo = outsideInfo
        self.creationPCR = creationPCR
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.inSensitive, 2)
        buf.sizedToTpm(this.inPublic, 2)
        buf.toTpm2B(this.outsideInfo)
        buf.arrayToTpm(this.creationPCR, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.primaryHandle = buf.createFromTpm(TPM_HANDLE)
        this.inSensitive = buf.sizedFromTpm(TPMS_SENSITIVE_CREATE, 2)
        this.inPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2)
        this.outsideInfo = buf.fromTpm2B(2)
        this.creationPCR = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4)
    
    
# TPM2_CreatePrimary_REQUEST

# This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
class CreatePrimaryResponse(TpmStructure):
    def __init__(self,
        # handle of type TPM_HT_TRANSIENT for created Primary Object
        handle = None,
        # the public portion of the created object
        outPublic = None,
        # contains a TPMT_CREATION_DATA
        creationData = None,
        # digest of creationData using nameAlg of outPublic
        creationHash = None,
        # ticket used by TPM2_CertifyCreation() to validate that the creation data was produced by the TPM
        creationTicket = None,
        # the name of the created object
        name = None
    ): 
        self.init()
        self.handle = handle
        self.outPublic = outPublic
        self.creationData = creationData
        self.creationHash = creationHash
        self.creationTicket = creationTicket
        self.name = name
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.handle.toTpm(buf)
        buf.sizedToTpm(this.outPublic, 2)
        buf.sizedToTpm(this.creationData, 2)
        buf.toTpm2B(this.creationHash)
        this.creationTicket.toTpm(buf)
        buf.toTpm2B(this.name)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.createFromTpm(TPM_HANDLE)
        this.outPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2)
        this.creationData = buf.sizedFromTpm(TPMS_CREATION_DATA, 2)
        this.creationHash = buf.fromTpm2B(2)
        this.creationTicket = buf.createFromTpm(TPMT_TK_CREATION)
        this.name = buf.fromTpm2B(2)
    
    
# CreatePrimaryResponse

# This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
class TPM2_HierarchyControl_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        authHandle = None,
        # the enable being modified TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM, or TPM_RH_PLATFORM_NV
        enable = None,
        # YES if the enable should be SET, NO if the enable should be CLEAR
        state = 0
    ): 
        self.init()
        self.authHandle = authHandle
        self.enable = enable
        self.state = state
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.enable.toTpm(buf)
        buf.toTpm(this.state, 1)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.enable = buf.createFromTpm(TPM_HANDLE)
        this.state = buf.fromTpm(1)
    
    
# TPM2_HierarchyControl_REQUEST

# This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
class HierarchyControlResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# HierarchyControlResponse

# This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
class TPM2_SetPrimaryPolicy_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        authHandle = None,
        # an authorization policy digest; may be the Empty Buffer If hashAlg is TPM_ALG_NULL, then this shall be an Empty Buffer.
        authPolicy = None,
        # the hash algorithm to use for the policy If the authPolicy is an Empty Buffer, then this field shall be TPM_ALG_NULL.
        hashAlg = 0
    ): 
        self.init()
        self.authHandle = authHandle
        self.authPolicy = authPolicy
        self.hashAlg = hashAlg
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.authPolicy)
        buf.toTpm(this.hashAlg, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.authPolicy = buf.fromTpm2B(2)
        this.hashAlg = buf.fromTpm(2)
    
    
# TPM2_SetPrimaryPolicy_REQUEST

# This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
class SetPrimaryPolicyResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# SetPrimaryPolicyResponse

# This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
class TPM2_ChangePPS_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        authHandle = None
    ): 
        self.init()
        self.authHandle = authHandle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_ChangePPS_REQUEST

# This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
class ChangePPSResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# ChangePPSResponse

# This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
class TPM2_ChangeEPS_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER
        authHandle = None
    ): 
        self.init()
        self.authHandle = authHandle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_ChangeEPS_REQUEST

# This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
class ChangeEPSResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# ChangeEPSResponse

# This command removes all TPM context associated with a specific Owner.
class TPM2_Clear_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER
        authHandle = None
    ): 
        self.init()
        self.authHandle = authHandle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_Clear_REQUEST

# This command removes all TPM context associated with a specific Owner.
class ClearResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# ClearResponse

# TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
class TPM2_ClearControl_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER
        auth = None,
        # YES if the disableOwnerClear flag is to be SET, NO if the flag is to be CLEAR.
        disable = 0
    ): 
        self.init()
        self.auth = auth
        self.disable = disable
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.disable, 1)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.auth = buf.createFromTpm(TPM_HANDLE)
        this.disable = buf.fromTpm(1)
    
    
# TPM2_ClearControl_REQUEST

# TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
class ClearControlResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# ClearControlResponse

# This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
class TPM2_HierarchyChangeAuth_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        authHandle = None,
        # new authorization value
        newAuth = None
    ): 
        self.init()
        self.authHandle = authHandle
        self.newAuth = newAuth
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.newAuth)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.newAuth = buf.fromTpm2B(2)
    
    
# TPM2_HierarchyChangeAuth_REQUEST

# This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
class HierarchyChangeAuthResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# HierarchyChangeAuthResponse

# This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
class TPM2_DictionaryAttackLockReset_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_LOCKOUT Auth Index: 1 Auth Role: USER
        lockHandle = None
    ): 
        self.init()
        self.lockHandle = lockHandle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.lockHandle = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_DictionaryAttackLockReset_REQUEST

# This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
class DictionaryAttackLockResetResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# DictionaryAttackLockResetResponse

# This command changes the lockout parameters.
class TPM2_DictionaryAttackParameters_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_LOCKOUT Auth Index: 1 Auth Role: USER
        lockHandle = None,
        # count of authorization failures before the lockout is imposed
        newMaxTries = 0,
        # time in seconds before the authorization failure count is automatically decremented A value of zero indicates that DA protection is disabled.
        newRecoveryTime = 0,
        # time in seconds after a lockoutAuth failure before use of lockoutAuth is allowed A value of zero indicates that a reboot is required.
        lockoutRecovery = 0
    ): 
        self.init()
        self.lockHandle = lockHandle
        self.newMaxTries = newMaxTries
        self.newRecoveryTime = newRecoveryTime
        self.lockoutRecovery = lockoutRecovery
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.newMaxTries, 4)
        buf.toTpm(this.newRecoveryTime, 4)
        buf.toTpm(this.lockoutRecovery, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.lockHandle = buf.createFromTpm(TPM_HANDLE)
        this.newMaxTries = buf.fromTpm(4)
        this.newRecoveryTime = buf.fromTpm(4)
        this.lockoutRecovery = buf.fromTpm(4)
    
    
# TPM2_DictionaryAttackParameters_REQUEST

# This command changes the lockout parameters.
class DictionaryAttackParametersResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# DictionaryAttackParametersResponse

# This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
class TPM2_PP_Commands_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_PLATFORM+PP Auth Index: 1 Auth Role: USER + Physical Presence
        auth = None,
        # list of commands to be added to those that will require that Physical Presence be asserted
        setList = None,
        # list of commands that will no longer require that Physical Presence be asserted
        clearList = None
    ): 
        self.init()
        self.auth = auth
        self.setList = setList
        self.clearList = clearList
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.valArrToTpm(this.setList, 4, 4)
        buf.valArrToTpm(this.clearList, 4, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.auth = buf.createFromTpm(TPM_HANDLE)
        this.setList = buf.valArrFromTpm(4, 4)
        this.clearList = buf.valArrFromTpm(4, 4)
    
    
# TPM2_PP_Commands_REQUEST

# This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
class PP_CommandsResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# PP_CommandsResponse

# This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
class TPM2_SetAlgorithmSet_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_PLATFORM Auth Index: 1 Auth Role: USER
        authHandle = None,
        # a TPM vendor-dependent value indicating the algorithm set selection
        algorithmSet = 0
    ): 
        self.init()
        self.authHandle = authHandle
        self.algorithmSet = algorithmSet
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.algorithmSet, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.algorithmSet = buf.fromTpm(4)
    
    
# TPM2_SetAlgorithmSet_REQUEST

# This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
class SetAlgorithmSetResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# SetAlgorithmSetResponse

# This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
class TPM2_FieldUpgradeStart_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_PLATFORM+{PP} Auth Index:1 Auth Role: ADMIN
        authorization = None,
        # handle of a public area that contains the TPM Vendor Authorization Key that will be used to validate manifestSignature Auth Index: None
        keyHandle = None,
        # digest of the first block in the field upgrade sequence
        fuDigest = None,
        # signature over fuDigest using the key associated with keyHandle (not optional) (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        manifestSignature = None
    ): 
        self.init()
        self.authorization = authorization
        self.keyHandle = keyHandle
        self.fuDigest = fuDigest
        self.manifestSignature = manifestSignature
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.fuDigest)
        buf.toTpm(this.manifestSignature.GetUnionSelector(), 2)
        this.manifestSignature.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authorization = buf.createFromTpm(TPM_HANDLE)
        this.keyHandle = buf.createFromTpm(TPM_HANDLE)
        this.fuDigest = buf.fromTpm2B(2)
        manifestSignatureSigAlg = buf.fromTpm(2)
        this.manifestSignature = createUnion('TPMU_SIGNATURE', manifestSignatureSigAlg)
        this.manifestSignature.fromTpm(buf)
    
    
# TPM2_FieldUpgradeStart_REQUEST

# This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
class FieldUpgradeStartResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# FieldUpgradeStartResponse

# This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
class TPM2_FieldUpgradeData_REQUEST(TpmStructure):
    def __init__(self,
        # field upgrade image data
        fuData = None
    ): 
        self.init()
        self.fuData = fuData
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.fuData)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.fuData = buf.fromTpm2B(2)
    
    
# TPM2_FieldUpgradeData_REQUEST

# This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
class FieldUpgradeDataResponse(TpmStructure):
    def __init__(self,
        # tagged digest of the next block TPM_ALG_NULL if field update is complete
        nextDigest = None,
        # tagged digest of the first block of the sequence
        firstDigest = None
    ): 
        self.init()
        self.nextDigest = nextDigest
        self.firstDigest = firstDigest
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.nextDigest.toTpm(buf)
        this.firstDigest.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.nextDigest = buf.createFromTpm(TPMT_HA)
        this.firstDigest = buf.createFromTpm(TPMT_HA)
    
    
# FieldUpgradeDataResponse

# This command is used to read a copy of the current firmware installed in the TPM.
class TPM2_FirmwareRead_REQUEST(TpmStructure):
    def __init__(self,
        # the number of previous calls to this command in this sequence set to 0 on the first call
        sequenceNumber = 0
    ): 
        self.init()
        self.sequenceNumber = sequenceNumber
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.sequenceNumber, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.sequenceNumber = buf.fromTpm(4)
    
    
# TPM2_FirmwareRead_REQUEST

# This command is used to read a copy of the current firmware installed in the TPM.
class FirmwareReadResponse(TpmStructure):
    def __init__(self,
        # field upgrade image data
        fuData = None
    ): 
        self.init()
        self.fuData = fuData
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.fuData)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.fuData = buf.fromTpm2B(2)
    
    
# FirmwareReadResponse

# This command saves a session context, object context, or sequence object context outside the TPM.
class TPM2_ContextSave_REQUEST(TpmStructure):
    def __init__(self,
        # handle of the resource to save Auth Index: None
        saveHandle = None
    ): 
        self.init()
        self.saveHandle = saveHandle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.saveHandle = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_ContextSave_REQUEST

# This command saves a session context, object context, or sequence object context outside the TPM.
class ContextSaveResponse(TpmStructure):
    def __init__(self,
        # -
        context = None
    ): 
        self.init()
        self.context = context
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.context.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.context = buf.createFromTpm(TPMS_CONTEXT)
    
    
# ContextSaveResponse

# This command is used to reload a context that has been saved by TPM2_ContextSave().
class TPM2_ContextLoad_REQUEST(TpmStructure):
    def __init__(self,
        # the context blob
        context = None
    ): 
        self.init()
        self.context = context
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.context.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.context = buf.createFromTpm(TPMS_CONTEXT)
    
    
# TPM2_ContextLoad_REQUEST

# This command is used to reload a context that has been saved by TPM2_ContextSave().
class ContextLoadResponse(TpmStructure):
    def __init__(self,
        # the handle assigned to the resource after it has been successfully loaded
        handle = None
    ): 
        self.init()
        self.handle = handle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.handle.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.createFromTpm(TPM_HANDLE)
    
    
# ContextLoadResponse

# This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
class TPM2_FlushContext_REQUEST(TpmStructure):
    def __init__(self,
        # the handle of the item to flush NOTE This is a use of a handle as a parameter.
        flushHandle = None
    ): 
        self.init()
        self.flushHandle = flushHandle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.flushHandle.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.flushHandle = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_FlushContext_REQUEST

# This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
class FlushContextResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# FlushContextResponse

# This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
class TPM2_EvictControl_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER
        auth = None,
        # the handle of a loaded object Auth Index: None
        objectHandle = None,
        # if objectHandle is a transient object handle, then this is the persistent handle for the object if objectHandle is a persistent object handle, then it shall be the same value as persistentHandle
        persistentHandle = None
    ): 
        self.init()
        self.auth = auth
        self.objectHandle = objectHandle
        self.persistentHandle = persistentHandle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.persistentHandle.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.auth = buf.createFromTpm(TPM_HANDLE)
        this.objectHandle = buf.createFromTpm(TPM_HANDLE)
        this.persistentHandle = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_EvictControl_REQUEST

# This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
class EvictControlResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# EvictControlResponse

# This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
class TPM2_ReadClock_REQUEST(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# TPM2_ReadClock_REQUEST

# This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
class ReadClockResponse(TpmStructure):
    def __init__(self,
        # -
        currentTime = None
    ): 
        self.init()
        self.currentTime = currentTime
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.currentTime.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.currentTime = buf.createFromTpm(TPMS_TIME_INFO)
    
    
# ReadClockResponse

# This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
class TPM2_ClockSet_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER
        auth = None,
        # new Clock setting in milliseconds
        newTime = 0
    ): 
        self.init()
        self.auth = auth
        self.newTime = newTime
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.newTime, 8)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.auth = buf.createFromTpm(TPM_HANDLE)
        this.newTime = buf.fromTpm(8)
    
    
# TPM2_ClockSet_REQUEST

# This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
class ClockSetResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# ClockSetResponse

# This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
class TPM2_ClockRateAdjust_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER
        auth = None,
        # Adjustment to current Clock update rate
        rateAdjust = 0
    ): 
        self.init()
        self.auth = auth
        self.rateAdjust = rateAdjust
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.rateAdjust, 1)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.auth = buf.createFromTpm(TPM_HANDLE)
        this.rateAdjust = buf.fromTpm(1)
    
    
# TPM2_ClockRateAdjust_REQUEST

# This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
class ClockRateAdjustResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# ClockRateAdjustResponse

# This command returns various information regarding the TPM and its current state.
class TPM2_GetCapability_REQUEST(TpmStructure):
    def __init__(self,
        # group selection; determines the format of the response
        capability = 0,
        # further definition of information
        property = 0,
        # number of properties of the indicated type to return
        propertyCount = 0
    ): 
        self.init()
        self.capability = capability
        self.property = property
        self.propertyCount = propertyCount
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.capability, 4)
        buf.toTpm(this.property, 4)
        buf.toTpm(this.propertyCount, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.capability = buf.fromTpm(4)
        this.property = buf.fromTpm(4)
        this.propertyCount = buf.fromTpm(4)
    
    
# TPM2_GetCapability_REQUEST

# This command returns various information regarding the TPM and its current state.
class GetCapabilityResponse(TpmStructure):
    def __init__(self,
        # flag to indicate if there are more values of this type
        moreData = 0,
        # the capability data (One of TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_CC, TPML_PCR_SELECTION, TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE, TPML_TAGGED_POLICY)
        capabilityData = None
    ): 
        self.init()
        self.moreData = moreData
        self.capabilityData = capabilityData
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.moreData, 1)
        buf.toTpm(this.capabilityData.GetUnionSelector(), 4)
        this.capabilityData.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.moreData = buf.fromTpm(1)
        capabilityDataCapability = buf.fromTpm(4)
        this.capabilityData = createUnion('TPMU_CAPABILITIES', capabilityDataCapability)
        this.capabilityData.fromTpm(buf)
    
    
# GetCapabilityResponse

# This command is used to check to see if specific combinations of algorithm parameters are supported.
class TPM2_TestParms_REQUEST(TpmStructure):
    def __init__(self,
        # algorithm parameters to be validated (One of TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS, TPMS_ASYM_PARMS)
        parameters = None
    ): 
        self.init()
        self.parameters = parameters
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.parameters.GetUnionSelector(), 2)
        this.parameters.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        parametersType = buf.fromTpm(2)
        this.parameters = createUnion('TPMU_PUBLIC_PARMS', parametersType)
        this.parameters.fromTpm(buf)
    
    
# TPM2_TestParms_REQUEST

# This command is used to check to see if specific combinations of algorithm parameters are supported.
class TestParmsResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# TestParmsResponse

# This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
class TPM2_NV_DefineSpace_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        authHandle = None,
        # the authorization value
        auth = None,
        # the public parameters of the NV area
        publicInfo = None
    ): 
        self.init()
        self.authHandle = authHandle
        self.auth = auth
        self.publicInfo = publicInfo
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.auth)
        buf.sizedToTpm(this.publicInfo, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.auth = buf.fromTpm2B(2)
        this.publicInfo = buf.sizedFromTpm(TPMS_NV_PUBLIC, 2)
    
    
# TPM2_NV_DefineSpace_REQUEST

# This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
class NV_DefineSpaceResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# NV_DefineSpaceResponse

# This command removes an Index from the TPM.
class TPM2_NV_UndefineSpace_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        authHandle = None,
        # the NV Index to remove from NV space Auth Index: None
        nvIndex = None
    ): 
        self.init()
        self.authHandle = authHandle
        self.nvIndex = nvIndex
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.nvIndex = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_NV_UndefineSpace_REQUEST

# This command removes an Index from the TPM.
class NV_UndefineSpaceResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# NV_UndefineSpaceResponse

# This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
class TPM2_NV_UndefineSpaceSpecial_REQUEST(TpmStructure):
    def __init__(self,
        # Index to be deleted Auth Index: 1 Auth Role: ADMIN
        nvIndex = None,
        # TPM_RH_PLATFORM + {PP} Auth Index: 2 Auth Role: USER
        platform = None
    ): 
        self.init()
        self.nvIndex = nvIndex
        self.platform = platform
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.nvIndex = buf.createFromTpm(TPM_HANDLE)
        this.platform = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_NV_UndefineSpaceSpecial_REQUEST

# This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
class NV_UndefineSpaceSpecialResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# NV_UndefineSpaceSpecialResponse

# This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
class TPM2_NV_ReadPublic_REQUEST(TpmStructure):
    def __init__(self,
        # the NV Index Auth Index: None
        nvIndex = None
    ): 
        self.init()
        self.nvIndex = nvIndex
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.nvIndex = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_NV_ReadPublic_REQUEST

# This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
class NV_ReadPublicResponse(TpmStructure):
    def __init__(self,
        # the public area of the NV Index
        nvPublic = None,
        # the Name of the nvIndex
        nvName = None
    ): 
        self.init()
        self.nvPublic = nvPublic
        self.nvName = nvName
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.nvPublic, 2)
        buf.toTpm2B(this.nvName)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.nvPublic = buf.sizedFromTpm(TPMS_NV_PUBLIC, 2)
        this.nvName = buf.fromTpm2B(2)
    
    
# NV_ReadPublicResponse

# This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
class TPM2_NV_Write_REQUEST(TpmStructure):
    def __init__(self,
        # handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        authHandle = None,
        # the NV Index of the area to write Auth Index: None
        nvIndex = None,
        # the data to write
        data = None,
        # the octet offset into the NV Area
        offset = 0
    ): 
        self.init()
        self.authHandle = authHandle
        self.nvIndex = nvIndex
        self.data = data
        self.offset = offset
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.data)
        buf.toTpm(this.offset, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.nvIndex = buf.createFromTpm(TPM_HANDLE)
        this.data = buf.fromTpm2B(2)
        this.offset = buf.fromTpm(2)
    
    
# TPM2_NV_Write_REQUEST

# This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
class NV_WriteResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# NV_WriteResponse

# This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
class TPM2_NV_Increment_REQUEST(TpmStructure):
    def __init__(self,
        # handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        authHandle = None,
        # the NV Index to increment Auth Index: None
        nvIndex = None
    ): 
        self.init()
        self.authHandle = authHandle
        self.nvIndex = nvIndex
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.nvIndex = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_NV_Increment_REQUEST

# This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
class NV_IncrementResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# NV_IncrementResponse

# This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
class TPM2_NV_Extend_REQUEST(TpmStructure):
    def __init__(self,
        # handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        authHandle = None,
        # the NV Index to extend Auth Index: None
        nvIndex = None,
        # the data to extend
        data = None
    ): 
        self.init()
        self.authHandle = authHandle
        self.nvIndex = nvIndex
        self.data = data
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.data)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.nvIndex = buf.createFromTpm(TPM_HANDLE)
        this.data = buf.fromTpm2B(2)
    
    
# TPM2_NV_Extend_REQUEST

# This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
class NV_ExtendResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# NV_ExtendResponse

# This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
class TPM2_NV_SetBits_REQUEST(TpmStructure):
    def __init__(self,
        # handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        authHandle = None,
        # NV Index of the area in which the bit is to be set Auth Index: None
        nvIndex = None,
        # the data to OR with the current contents
        bits = 0
    ): 
        self.init()
        self.authHandle = authHandle
        self.nvIndex = nvIndex
        self.bits = bits
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.bits, 8)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.nvIndex = buf.createFromTpm(TPM_HANDLE)
        this.bits = buf.fromTpm(8)
    
    
# TPM2_NV_SetBits_REQUEST

# This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
class NV_SetBitsResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# NV_SetBitsResponse

# If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
class TPM2_NV_WriteLock_REQUEST(TpmStructure):
    def __init__(self,
        # handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        authHandle = None,
        # the NV Index of the area to lock Auth Index: None
        nvIndex = None
    ): 
        self.init()
        self.authHandle = authHandle
        self.nvIndex = nvIndex
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.nvIndex = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_NV_WriteLock_REQUEST

# If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
class NV_WriteLockResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# NV_WriteLockResponse

# The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
class TPM2_NV_GlobalWriteLock_REQUEST(TpmStructure):
    def __init__(self,
        # TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        authHandle = None
    ): 
        self.init()
        self.authHandle = authHandle
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_NV_GlobalWriteLock_REQUEST

# The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
class NV_GlobalWriteLockResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# NV_GlobalWriteLockResponse

# This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
class TPM2_NV_Read_REQUEST(TpmStructure):
    def __init__(self,
        # the handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        authHandle = None,
        # the NV Index to be read Auth Index: None
        nvIndex = None,
        # number of octets to read
        size = 0,
        # octet offset into the NV area This value shall be less than or equal to the size of the nvIndex data.
        offset = 0
    ): 
        self.init()
        self.authHandle = authHandle
        self.nvIndex = nvIndex
        self.size = size
        self.offset = offset
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.size, 2)
        buf.toTpm(this.offset, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.nvIndex = buf.createFromTpm(TPM_HANDLE)
        this.size = buf.fromTpm(2)
        this.offset = buf.fromTpm(2)
    
    
# TPM2_NV_Read_REQUEST

# This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
class NV_ReadResponse(TpmStructure):
    def __init__(self,
        # the data read
        data = None
    ): 
        self.init()
        self.data = data
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.data)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.data = buf.fromTpm2B(2)
    
    
# NV_ReadResponse

# If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
class TPM2_NV_ReadLock_REQUEST(TpmStructure):
    def __init__(self,
        # the handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        authHandle = None,
        # the NV Index to be locked Auth Index: None
        nvIndex = None
    ): 
        self.init()
        self.authHandle = authHandle
        self.nvIndex = nvIndex
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.nvIndex = buf.createFromTpm(TPM_HANDLE)
    
    
# TPM2_NV_ReadLock_REQUEST

# If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
class NV_ReadLockResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# NV_ReadLockResponse

# This command allows the authorization secret for an NV Index to be changed.
class TPM2_NV_ChangeAuth_REQUEST(TpmStructure):
    def __init__(self,
        # handle of the entity Auth Index: 1 Auth Role: ADMIN
        nvIndex = None,
        # new authorization value
        newAuth = None
    ): 
        self.init()
        self.nvIndex = nvIndex
        self.newAuth = newAuth
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.newAuth)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.nvIndex = buf.createFromTpm(TPM_HANDLE)
        this.newAuth = buf.fromTpm2B(2)
    
    
# TPM2_NV_ChangeAuth_REQUEST

# This command allows the authorization secret for an NV Index to be changed.
class NV_ChangeAuthResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# NV_ChangeAuthResponse

# The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
class TPM2_NV_Certify_REQUEST(TpmStructure):
    def __init__(self,
        # handle of the key used to sign the attestation structure Auth Index: 1 Auth Role: USER
        signHandle = None,
        # handle indicating the source of the authorization value for the NV Index Auth Index: 2 Auth Role: USER
        authHandle = None,
        # Index for the area to be certified Auth Index: None
        nvIndex = None,
        # user-provided qualifying data
        qualifyingData = None,
        # signing scheme to use if the scheme for signHandle is TPM_ALG_NULL (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        inScheme = None,
        # number of octets to certify
        size = 0,
        # octet offset into the NV area This value shall be less than or equal to the size of the nvIndex data.
        offset = 0
    ): 
        self.init()
        self.signHandle = signHandle
        self.authHandle = authHandle
        self.nvIndex = nvIndex
        self.qualifyingData = qualifyingData
        self.inScheme = inScheme
        self.size = size
        self.offset = offset
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.qualifyingData)
        buf.toTpm(this.inScheme.GetUnionSelector(), 2)
        this.inScheme.toTpm(buf)
        buf.toTpm(this.size, 2)
        buf.toTpm(this.offset, 2)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.signHandle = buf.createFromTpm(TPM_HANDLE)
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.nvIndex = buf.createFromTpm(TPM_HANDLE)
        this.qualifyingData = buf.fromTpm2B(2)
        inSchemeScheme = buf.fromTpm(2)
        this.inScheme = createUnion('TPMU_SIG_SCHEME', inSchemeScheme)
        this.inScheme.fromTpm(buf)
        this.size = buf.fromTpm(2)
        this.offset = buf.fromTpm(2)
    
    
# TPM2_NV_Certify_REQUEST

# The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
class NV_CertifyResponse(TpmStructure):
    def __init__(self,
        # the structure that was signed
        certifyInfo = None,
        # the asymmetric signature over certifyInfo using the key referenced by signHandle (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        signature = None
    ): 
        self.init()
        self.certifyInfo = certifyInfo
        self.signature = signature
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.sizedToTpm(this.certifyInfo, 2)
        buf.toTpm(this.signature.GetUnionSelector(), 2)
        this.signature.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.certifyInfo = buf.sizedFromTpm(TPMS_ATTEST, 2)
        signatureSigAlg = buf.fromTpm(2)
        this.signature = createUnion('TPMU_SIGNATURE', signatureSigAlg)
        this.signature.fromTpm(buf)
    
    
# NV_CertifyResponse

# The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
class TPM2_AC_GetCapability_REQUEST(TpmStructure):
    def __init__(self,
        # handle indicating the Attached Component Auth Index: None
        ac = None,
        # starting info type
        capability = 0,
        # maximum number of values to return
        count = 0
    ): 
        self.init()
        self.ac = ac
        self.capability = capability
        self.count = count
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.capability, 4)
        buf.toTpm(this.count, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.ac = buf.createFromTpm(TPM_HANDLE)
        this.capability = buf.fromTpm(4)
        this.count = buf.fromTpm(4)
    
    
# TPM2_AC_GetCapability_REQUEST

# The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
class AC_GetCapabilityResponse(TpmStructure):
    def __init__(self,
        # flag to indicate whether there are more values
        moreData = 0,
        # list of capabilities
        capabilitiesData = None
    ): 
        self.init()
        self.moreData = moreData
        self.capabilitiesData = capabilitiesData
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.moreData, 1)
        buf.arrayToTpm(this.capabilitiesData, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.moreData = buf.fromTpm(1)
        this.capabilitiesData = buf.arrayFromTpm(TPMS_AC_OUTPUT, 4)
    
    
# AC_GetCapabilityResponse

# The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
class TPM2_AC_Send_REQUEST(TpmStructure):
    def __init__(self,
        # handle of the object being sent to ac Auth Index: 1 Auth Role: DUP
        sendObject = None,
        # the handle indicating the source of the authorization value Auth Index: 2 Auth Role: USER
        authHandle = None,
        # handle indicating the Attached Component to which the object will be sent Auth Index: None
        ac = None,
        # Optional non sensitive information related to the object
        acDataIn = None
    ): 
        self.init()
        self.sendObject = sendObject
        self.authHandle = authHandle
        self.ac = ac
        self.acDataIn = acDataIn
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.acDataIn)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.sendObject = buf.createFromTpm(TPM_HANDLE)
        this.authHandle = buf.createFromTpm(TPM_HANDLE)
        this.ac = buf.createFromTpm(TPM_HANDLE)
        this.acDataIn = buf.fromTpm2B(2)
    
    
# TPM2_AC_Send_REQUEST

# The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
class AC_SendResponse(TpmStructure):
    def __init__(self,
        # May include AC specific data or information about an error.
        acDataOut = None
    ): 
        self.init()
        self.acDataOut = acDataOut
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.acDataOut.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.acDataOut = buf.createFromTpm(TPMS_AC_OUTPUT)
    
    
# AC_SendResponse

# This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
class TPM2_Policy_AC_SendSelect_REQUEST(TpmStructure):
    def __init__(self,
        # handle for the policy session being extended Auth Index: None
        policySession = None,
        # the Name of the Object to be sent
        objectName = None,
        # the Name associated with authHandle used in the TPM2_AC_Send() command
        authHandleName = None,
        # the Name of the Attached Component to which the Object will be sent
        acName = None,
        # if SET, objectName will be included in the value in policySessionpolicyDigest
        includeObject = 0
    ): 
        self.init()
        self.policySession = policySession
        self.objectName = objectName
        self.authHandleName = authHandleName
        self.acName = acName
        self.includeObject = includeObject
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.objectName)
        buf.toTpm2B(this.authHandleName)
        buf.toTpm2B(this.acName)
        buf.toTpm(this.includeObject, 1)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.policySession = buf.createFromTpm(TPM_HANDLE)
        this.objectName = buf.fromTpm2B(2)
        this.authHandleName = buf.fromTpm2B(2)
        this.acName = buf.fromTpm2B(2)
        this.includeObject = buf.fromTpm(1)
    
    
# TPM2_Policy_AC_SendSelect_REQUEST

# This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
class Policy_AC_SendSelectResponse(TpmStructure):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        return
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        return
    
    
# Policy_AC_SendSelectResponse

# This is a placeholder to allow testing of the dispatch code.
class TPM2_Vendor_TCG_Test_REQUEST(TpmStructure):
    def __init__(self,
        # dummy data
        inputData = None
    ): 
        self.init()
        self.inputData = inputData
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.inputData)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.inputData = buf.fromTpm2B(2)
    
    
# TPM2_Vendor_TCG_Test_REQUEST

# This is a placeholder to allow testing of the dispatch code.
class Vendor_TCG_TestResponse(TpmStructure):
    def __init__(self,
        # dummy data
        outputData = None
    ): 
        self.init()
        self.outputData = outputData
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.outputData)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.outputData = buf.fromTpm2B(2)
    
    
# Vendor_TCG_TestResponse

# Underlying type comment: These are the RSA schemes that only need a hash algorithm as a scheme parameter.
class TPMS_SCHEME_RSASSA(TPMS_SIG_SCHEME_RSASSA):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SCHEME_RSASSA, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SCHEME_RSASSA, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SCHEME_RSASSA, self).fromTpm(buf)
    
    
# TPMS_SCHEME_RSASSA

# Underlying type comment: These are the RSA schemes that only need a hash algorithm as a scheme parameter.
class TPMS_SCHEME_RSAPSS(TPMS_SIG_SCHEME_RSAPSS):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SCHEME_RSAPSS, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SCHEME_RSAPSS, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SCHEME_RSAPSS, self).fromTpm(buf)
    
    
# TPMS_SCHEME_RSAPSS

# Underlying type comment: Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
class TPMS_SCHEME_ECDSA(TPMS_SIG_SCHEME_ECDSA):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SCHEME_ECDSA, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SCHEME_ECDSA, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SCHEME_ECDSA, self).fromTpm(buf)
    
    
# TPMS_SCHEME_ECDSA

# Underlying type comment: Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
class TPMS_SCHEME_SM2(TPMS_SIG_SCHEME_SM2):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SCHEME_SM2, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SCHEME_SM2, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SCHEME_SM2, self).fromTpm(buf)
    
    
# TPMS_SCHEME_SM2

# Underlying type comment: Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
class TPMS_SCHEME_ECSCHNORR(TPMS_SIG_SCHEME_ECSCHNORR):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SCHEME_ECSCHNORR, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SCHEME_ECSCHNORR, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SCHEME_ECSCHNORR, self).fromTpm(buf)
    
    
# TPMS_SCHEME_ECSCHNORR

# Underlying type comment: These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
class TPMS_SCHEME_OAEP(TPMS_ENC_SCHEME_OAEP):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SCHEME_OAEP, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SCHEME_OAEP, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SCHEME_OAEP, self).fromTpm(buf)
    
    
# TPMS_SCHEME_OAEP

# Underlying type comment: These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
class TPMS_SCHEME_RSAES(TPMS_ENC_SCHEME_RSAES):
    def __init__(self
    ): 
        self.init()
    
    # TpmMarshaller method
    def toTpm(this, buf):
        pass
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        pass
    
    
# TPMS_SCHEME_RSAES

# Underlying type comment: These are the ECC schemes that only need a hash algorithm as a controlling parameter.
class TPMS_SCHEME_ECDH(TPMS_KEY_SCHEME_ECDH):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SCHEME_ECDH, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SCHEME_ECDH, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SCHEME_ECDH, self).fromTpm(buf)
    
    
# TPMS_SCHEME_ECDH

# Underlying type comment: These are the ECC schemes that only need a hash algorithm as a controlling parameter.
class TPMS_SCHEME_ECMQV(TPMS_KEY_SCHEME_ECMQV):
    def __init__(self,
        # the hash algorithm used to digest the message
        hashAlg = 0
    ): 
        super(TPMS_SCHEME_ECMQV, self).__init__(hashAlg)
        self.init()
        self.hashAlg = hashAlg
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPMS_SCHEME_ECMQV, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPMS_SCHEME_ECMQV, self).fromTpm(buf)
    
    
# TPMS_SCHEME_ECMQV

# Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM key (or other object)
class TssObject(TpmStructure):
    def __init__(self,
        # Public part of key
        Public = None,
        # Sensitive part of key
        Sensitive = None,
        # Private part is the encrypted sensitive part of key
        Private = None
    ): 
        self.init()
        self.Public = Public
        self.Sensitive = Sensitive
        self.Private = Private
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.Public.toTpm(buf)
        this.Sensitive.toTpm(buf)
        this.Private.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.Public = buf.createFromTpm(TPMT_PUBLIC)
        this.Sensitive = buf.createFromTpm(TPMT_SENSITIVE)
        this.Private = buf.createFromTpm(TPM2B_PRIVATE)
    
    
# TssObject

# Contains a PCR index and associated hash(pcr-value) [TSS]
class PcrValue(TpmStructure):
    def __init__(self,
        # PCR Index
        index = 0,
        # PCR Value
        value = None
    ): 
        self.init()
        self.index = index
        self.value = value
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.index, 4)
        this.value.toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.index = buf.fromTpm(4)
        this.value = buf.createFromTpm(TPMT_HA)
    
    
# PcrValue

# Structure representing a session block in a command buffer [TSS]
class SessionIn(TpmStructure):
    def __init__(self,
        # Session handle
        handle = None,
        # Caller nonce
        nonceCaller = None,
        # Session attributes
        attributes = 0,
        # AuthValue (or HMAC)
        auth = None
    ): 
        self.init()
        self.handle = handle
        self.nonceCaller = nonceCaller
        self.attributes = attributes
        self.auth = auth
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.handle.toTpm(buf)
        buf.toTpm2B(this.nonceCaller)
        buf.toTpm(this.attributes, 1)
        buf.toTpm2B(this.auth)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.handle = buf.createFromTpm(TPM_HANDLE)
        this.nonceCaller = buf.fromTpm2B(2)
        this.attributes = buf.fromTpm(1)
        this.auth = buf.fromTpm2B(2)
    
    
# SessionIn

# Structure representing a session block in a response buffer [TSS]
class SessionOut(TpmStructure):
    def __init__(self,
        # TPM nonce
        nonceTpm = None,
        # Session attributes
        attributes = 0,
        # HMAC value
        auth = None
    ): 
        self.init()
        self.nonceTpm = nonceTpm
        self.attributes = attributes
        self.auth = auth
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm2B(this.nonceTpm)
        buf.toTpm(this.attributes, 1)
        buf.toTpm2B(this.auth)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.nonceTpm = buf.fromTpm2B(2)
        this.attributes = buf.fromTpm(1)
        this.auth = buf.fromTpm2B(2)
    
    
# SessionOut

# Command header [TSS]
class CommandHeader(TpmStructure):
    def __init__(self,
        # Command tag (sessions, or no sessions)
        Tag = 0,
        # Total command buffer length
        CommandSize = 0,
        # Command code
        CommandCode = 0
    ): 
        self.init()
        self.Tag = Tag
        self.CommandSize = CommandSize
        self.CommandCode = CommandCode
    
    # TpmMarshaller method
    def toTpm(this, buf):
        buf.toTpm(this.Tag, 2)
        buf.toTpm(this.CommandSize, 4)
        buf.toTpm(this.CommandCode, 4)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.Tag = buf.fromTpm(2)
        this.CommandSize = buf.fromTpm(4)
        this.CommandCode = buf.fromTpm(4)
    
    
# CommandHeader

# Contains the public and private part of a TPM key
class TSS_KEY(TpmStructure):
    def __init__(self,
        # Public part of key
        publicPart = None,
        # Private part is the encrypted sensitive part of key
        privatePart = None
    ): 
        self.init()
        self.publicPart = publicPart
        self.privatePart = privatePart
    
    # TpmMarshaller method
    def toTpm(this, buf):
        this.publicPart.toTpm(buf)
        buf.toTpm2B(this.privatePart)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        this.publicPart = buf.createFromTpm(TPMT_PUBLIC)
        this.privatePart = buf.fromTpm2B(2)
    
    
# TSS_KEY

# Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation
class TPM2B_DIGEST_Symcipher(TPM2B_DIGEST, TPMU_PUBLIC_ID ):
    def __init__(self,
        # the buffer area that can be no larger than a digest
        buffer = None
    ): 
        super(TPM2B_DIGEST_Symcipher, self).__init__(buffer)
        self.init()
        self.buffer = buffer
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.SYMCIPHER
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPM2B_DIGEST_Symcipher, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPM2B_DIGEST_Symcipher, self).fromTpm(buf)
    
    
# TPM2B_DIGEST_Symcipher

# Auto-derived from TPM2B_DIGEST
class TPM2B_DIGEST_Keyedhash(TPM2B_DIGEST, TPMU_PUBLIC_ID ):
    def __init__(self,
        # the buffer area that can be no larger than a digest
        buffer = None
    ): 
        super(TPM2B_DIGEST_Keyedhash, self).__init__(buffer)
        self.init()
        self.buffer = buffer
    
    # TpmUnion method
    def GetUnionSelector(self):
        return TPM_ALG_ID.KEYEDHASH
    
    # TpmMarshaller method
    def toTpm(this, buf):
        super(TPM2B_DIGEST_Keyedhash, self).toTpm(buf)
    
    # TpmMarshaller method
    def fromTpm(this, buf):
        super(TPM2B_DIGEST_Keyedhash, self).fromTpm(buf)
    
    
# TPM2B_DIGEST_Keyedhash

