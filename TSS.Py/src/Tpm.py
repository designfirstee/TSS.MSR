""" 
 * Copyright(c) Microsoft Corporation.All rights reserved. 
 * Licensed under the MIT License. 
 * See the LICENSE file in the project root for full license information. 
"""

"""
 * This file is automatically generated from the TPM 2.0 rev. 1.46 specification documents.
 * Do not edit it directly.
"""


from .TpmBase import *



class Tpm(TpmBase):
    """
    TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
    Args:
        startupType TPM_SU_CLEAR or TPM_SU_STATE
    """
    def Startup(self, startupType):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.Startup, None, 0)
        inStruct = TPM2_Startup_REQUEST(startupType)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.Startup, respBuf);
    # Startup()
    
    """
    This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
    Args:
        shutdownType TPM_SU_CLEAR or TPM_SU_STATE
    """
    def Shutdown(self, shutdownType):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.Shutdown, None, 0)
        inStruct = TPM2_Shutdown_REQUEST(shutdownType)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.Shutdown, respBuf);
    # Shutdown()
    
    """
    This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
    Args:
        fullTest YES if full test to be performed NO if only test of untested functions required
    """
    def SelfTest(self, fullTest):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.SelfTest, None, 0)
        inStruct = TPM2_SelfTest_REQUEST(fullTest)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.SelfTest, respBuf);
    # SelfTest()
    
    """
    This command causes the TPM to perform a test of the selected algorithms.
    Args:
        toTest list of algorithms that should be tested 
    Returns:
        list of algorithms that need testing
    """
    def IncrementalSelfTest(self, toTest):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.IncrementalSelfTest, None, 0)
        inStruct = TPM2_IncrementalSelfTest_REQUEST(toTest)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.IncrementalSelfTest, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(IncrementalSelfTestResponse)
            return res.toDoList
        else:
            return None
    # IncrementalSelfTest()
    
    """
    This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
    Args:
    Returns:
        class GetTestResultResponse:
            outData test result data contains manufacturer-specific information
            testResult In general, response codes defined in TPM 2.0 Part 2 will be unmarshaling errors and will have the F (format) bit SET. Codes that are unique to TPM 2.0 Part 3 will have the F bit CLEAR but the V (version) attribute will be SET to indicate that it is a TPM 2.0 response code. See Response Code Details in TPM 2.0 Part 1.
    """
    def GetTestResult(self):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.GetTestResult, None, 0)
        inStruct = TPM2_GetTestResult_REQUEST()
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.GetTestResult, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(GetTestResultResponse)
    # GetTestResult()
    
    """
    This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
    Args:
        tpmKey handle of a loaded decrypt key used to encrypt salt may be TPM_RH_NULL Auth Index: None 
        bind entity providing the authValue may be TPM_RH_NULL Auth Index: None 
        nonceCaller initial nonceCaller, sets nonceTPM size for the session shall be at least 16 octets 
        encryptedSalt value encrypted according to the type of tpmKey If tpmKey is TPM_RH_NULL, this shall be the Empty Buffer. 
        sessionType indicates the type of the session; simple HMAC or policy (including a trial policy) 
        symmetric the algorithm and key size for parameter encryption may select TPM_ALG_NULL 
        authHash hash algorithm to use for the session Shall be a hash algorithm supported by the TPM and not TPM_ALG_NULL 
    Returns:
        class StartAuthSessionResponse:
            handle handle for the newly created session
            nonceTPM the initial nonce from the TPM, used in the computation of the sessionKey
    """
    def StartAuthSession(self, tpmKey, bind, nonceCaller, encryptedSalt, sessionType, symmetric, authHash):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.StartAuthSession, [tpmKey, bind], 0)
        inStruct = TPM2_StartAuthSession_REQUEST(tpmKey,bind,nonceCaller,encryptedSalt,sessionType,symmetric,authHash)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.StartAuthSession, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(StartAuthSessionResponse)
    # StartAuthSession()
    
    """
    This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
    Args:
        sessionHandle the handle for the policy session
    """
    def PolicyRestart(self, sessionHandle):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyRestart, [sessionHandle], 0)
        inStruct = TPM2_PolicyRestart_REQUEST(sessionHandle)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyRestart, respBuf);
    # PolicyRestart()
    
    """
    This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
    Args:
        parentHandle handle of parent for new object Auth Index: 1 Auth Role: USER 
        inSensitive the sensitive data 
        inPublic the public template 
        outsideInfo data that will be included in the creation data for this object to provide permanent, verifiable linkage between this object and some object owner data 
        creationPCR PCR that will be used in creation data 
    Returns:
        class CreateResponse:
            outPrivate the private portion of the object
            outPublic the public portion of the created object
            creationData contains a TPMS_CREATION_DATA
            creationHash digest of creationData using nameAlg of outPublic
            creationTicket ticket used by TPM2_CertifyCreation() to validate that the creation data was produced by the TPM
    """
    def Create(self, parentHandle, inSensitive, inPublic, outsideInfo, creationPCR):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.Create, [parentHandle], 1)
        inStruct = TPM2_Create_REQUEST(parentHandle,inSensitive,inPublic,outsideInfo,creationPCR)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.Create, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(CreateResponse)
    # Create()
    
    """
    This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
    Args:
        parentHandle TPM handle of parent key; shall not be a reserved handle Auth Index: 1 Auth Role: USER 
        inPrivate the private portion of the object 
        inPublic the public portion of the object 
    Returns:
        handle of type TPM_HT_TRANSIENT for the loaded object
    """
    def Load(self, parentHandle, inPrivate, inPublic):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.Load, [parentHandle], 1)
        inStruct = TPM2_Load_REQUEST(parentHandle,inPrivate,inPublic)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.Load, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(LoadResponse)
            return res.handle
        else:
            return None
    # Load()
    
    """
    This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
    Args:
        inPrivate the sensitive portion of the object (optional) 
        inPublic the public portion of the object 
        hierarchy hierarchy with which the object area is associated 
    Returns:
        handle of type TPM_HT_TRANSIENT for the loaded object
    """
    def LoadExternal(self, inPrivate, inPublic, hierarchy):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.LoadExternal, None, 0)
        inStruct = TPM2_LoadExternal_REQUEST(inPrivate,inPublic,hierarchy)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.LoadExternal, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(LoadExternalResponse)
            return res.handle
        else:
            return None
    # LoadExternal()
    
    """
    This command allows access to the public area of a loaded object.
    Args:
        objectHandle TPM handle of an object Auth Index: None 
    Returns:
        class ReadPublicResponse:
            outPublic structure containing the public area of an object
            name name of the object
            qualifiedName the Qualified Name of the object
    """
    def ReadPublic(self, objectHandle):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.ReadPublic, [objectHandle], 0)
        inStruct = TPM2_ReadPublic_REQUEST(objectHandle)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.ReadPublic, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(ReadPublicResponse)
    # ReadPublic()
    
    """
    This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
    Args:
        activateHandle handle of the object associated with certificate in credentialBlob Auth Index: 1 Auth Role: ADMIN 
        keyHandle loaded key used to decrypt the TPMS_SENSITIVE in credentialBlob Auth Index: 2 Auth Role: USER 
        credentialBlob the credential 
        secret keyHandle algorithm-dependent encrypted seed that protects credentialBlob 
    Returns:
        the decrypted certificate information
    the data should be no larger than the size of the digest of the nameAlg associated with keyHandle
    """
    def ActivateCredential(self, activateHandle, keyHandle, credentialBlob, secret):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.ActivateCredential, [activateHandle, keyHandle], 2)
        inStruct = TPM2_ActivateCredential_REQUEST(activateHandle,keyHandle,credentialBlob,secret)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.ActivateCredential, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(ActivateCredentialResponse)
            return res.certInfo
        else:
            return None
    # ActivateCredential()
    
    """
    This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
    Args:
        handle loaded public area, used to encrypt the sensitive area containing the credential key Auth Index: None 
        credential the credential information 
        objectName Name of the object to which the credential applies 
    Returns:
        class MakeCredentialResponse:
            credentialBlob the credential
            secret handle algorithm-dependent data that wraps the key that encrypts credentialBlob
    """
    def MakeCredential(self, handle, credential, objectName):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.MakeCredential, [handle], 0)
        inStruct = TPM2_MakeCredential_REQUEST(handle,credential,objectName)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.MakeCredential, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(MakeCredentialResponse)
    # MakeCredential()
    
    """
    This command returns the data in a loaded Sealed Data Object.
    Args:
        itemHandle handle of a loaded data object Auth Index: 1 Auth Role: USER 
    Returns:
        unsealed data
    Size of outData is limited to be no more than 128 octets.
    """
    def Unseal(self, itemHandle):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.Unseal, [itemHandle], 1)
        inStruct = TPM2_Unseal_REQUEST(itemHandle)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.Unseal, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(UnsealResponse)
            return res.outData
        else:
            return None
    # Unseal()
    
    """
    This command is used to change the authorization secret for a TPM-resident object.
    Args:
        objectHandle handle of the object Auth Index: 1 Auth Role: ADMIN 
        parentHandle handle of the parent Auth Index: None 
        newAuth new authorization value 
    Returns:
        private area containing the new authorization value
    """
    def ObjectChangeAuth(self, objectHandle, parentHandle, newAuth):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.ObjectChangeAuth, [objectHandle, parentHandle], 1)
        inStruct = TPM2_ObjectChangeAuth_REQUEST(objectHandle,parentHandle,newAuth)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.ObjectChangeAuth, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(ObjectChangeAuthResponse)
            return res.outPrivate
        else:
            return None
    # ObjectChangeAuth()
    
    """
    This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
    Args:
        parentHandle Handle of a transient storage key, a persistent storage key, TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL Auth Index: 1 Auth Role: USER 
        inSensitive the sensitive data, see TPM 2.0 Part 1 Sensitive Values 
        inPublic the public template 
    Returns:
        class CreateLoadedResponse:
            handle handle of type TPM_HT_TRANSIENT for created object
            outPrivate the sensitive area of the object (optional)
            outPublic the public portion of the created object
            name the name of the created object
    """
    def CreateLoaded(self, parentHandle, inSensitive, inPublic):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.CreateLoaded, [parentHandle], 1)
        inStruct = TPM2_CreateLoaded_REQUEST(parentHandle,inSensitive,inPublic)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.CreateLoaded, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(CreateLoadedResponse)
    # CreateLoaded()
    
    """
    This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
    Args:
        objectHandle loaded object to duplicate Auth Index: 1 Auth Role: DUP 
        newParentHandle shall reference the public area of an asymmetric key Auth Index: None 
        encryptionKeyIn optional symmetric encryption key The size for this key is set to zero when the TPM is to generate the key. This parameter may be encrypted. 
        symmetricAlg definition for the symmetric algorithm to be used for the inner wrapper may be TPM_ALG_NULL if no inner wrapper is applied 
    Returns:
        class DuplicateResponse:
            encryptionKeyOut If the caller provided an encryption key or if symmetricAlg was TPM_ALG_NULL, then this will be the Empty Buffer; otherwise, it shall contain the TPM-generated, symmetric encryption key for the inner wrapper.
            duplicate private area that may be encrypted by encryptionKeyIn; and may be doubly encrypted
            outSymSeed seed protected by the asymmetric algorithms of new parent (NP)
    """
    def Duplicate(self, objectHandle, newParentHandle, encryptionKeyIn, symmetricAlg):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.Duplicate, [objectHandle, newParentHandle], 1)
        inStruct = TPM2_Duplicate_REQUEST(objectHandle,newParentHandle,encryptionKeyIn,symmetricAlg)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.Duplicate, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(DuplicateResponse)
    # Duplicate()
    
    """
    This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
    Args:
        oldParent parent of object Auth Index: 1 Auth Role: User 
        newParent new parent of the object Auth Index: None 
        inDuplicate an object encrypted using symmetric key derived from inSymSeed 
        name the Name of the object being rewrapped 
        inSymSeed the seed for the symmetric key and HMAC key needs oldParent private key to recover the seed and generate the symmetric key 
    Returns:
        class RewrapResponse:
            outDuplicate an object encrypted using symmetric key derived from outSymSeed
            outSymSeed seed for a symmetric key protected by newParent asymmetric key
    """
    def Rewrap(self, oldParent, newParent, inDuplicate, name, inSymSeed):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.Rewrap, [oldParent, newParent], 1)
        inStruct = TPM2_Rewrap_REQUEST(oldParent,newParent,inDuplicate,name,inSymSeed)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.Rewrap, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(RewrapResponse)
    # Rewrap()
    
    """
    This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
    Args:
        parentHandle the handle of the new parent for the object Auth Index: 1 Auth Role: USER 
        encryptionKey the optional symmetric encryption key used as the inner wrapper for duplicate If symmetricAlg is TPM_ALG_NULL, then this parameter shall be the Empty Buffer. 
        objectPublic the public area of the object to be imported This is provided so that the integrity value for duplicate and the object attributes can be checked. NOTE Even if the integrity value of the object is not checked on input, the object Name is required to create the integrity value for the imported object. 
        duplicate the symmetrically encrypted duplicate object that may contain an inner symmetric wrapper 
        inSymSeed the seed for the symmetric key and HMAC key inSymSeed is encrypted/encoded using the algorithms of newParent. 
        symmetricAlg definition for the symmetric algorithm to use for the inner wrapper If this algorithm is TPM_ALG_NULL, no inner wrapper is present and encryptionKey shall be the Empty Buffer. 
    Returns:
        the sensitive area encrypted with the symmetric key of parentHandle
    """
    def Import(self, parentHandle, encryptionKey, objectPublic, duplicate, inSymSeed, symmetricAlg):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.Import, [parentHandle], 1)
        inStruct = TPM2_Import_REQUEST(parentHandle,encryptionKey,objectPublic,duplicate,inSymSeed,symmetricAlg)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.Import, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(ImportResponse)
            return res.outPrivate
        else:
            return None
    # Import()
    
    """
    This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
    Args:
        keyHandle reference to public portion of RSA key to use for encryption Auth Index: None 
        message message to be encrypted NOTE 1 The data type was chosen because it limits the overall size of the input to no greater than the size of the largest RSA public key. This may be larger than allowed for keyHandle. 
        inScheme the padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL 
        label optional label L to be associated with the message Size of the buffer is zero if no label is present NOTE 2 See description of label above. 
    Returns:
        encrypted output
    """
    def RSA_Encrypt(self, keyHandle, message, inScheme, label):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.RSA_Encrypt, [keyHandle], 0)
        inStruct = TPM2_RSA_Encrypt_REQUEST(keyHandle,message,inScheme,label)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.RSA_Encrypt, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(RSA_EncryptResponse)
            return res.outData
        else:
            return None
    # RSA_Encrypt()
    
    """
    This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
    Args:
        keyHandle RSA key to use for decryption Auth Index: 1 Auth Role: USER 
        cipherText cipher text to be decrypted NOTE An encrypted RSA data block is the size of the public modulus. 
        inScheme the padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL 
        label label whose association with the message is to be verified 
    Returns:
        decrypted output
    """
    def RSA_Decrypt(self, keyHandle, cipherText, inScheme, label):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.RSA_Decrypt, [keyHandle], 1)
        inStruct = TPM2_RSA_Decrypt_REQUEST(keyHandle,cipherText,inScheme,label)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.RSA_Decrypt, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(RSA_DecryptResponse)
            return res.message
        else:
            return None
    # RSA_Decrypt()
    
    """
    This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P [hde]QS).
    Args:
        keyHandle Handle of a loaded ECC key public area. Auth Index: None 
    Returns:
        class ECDH_KeyGenResponse:
            zPoint results of P h[de]Qs
            pubPoint generated ephemeral public point (Qe)
    """
    def ECDH_KeyGen(self, keyHandle):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.ECDH_KeyGen, [keyHandle], 0)
        inStruct = TPM2_ECDH_KeyGen_REQUEST(keyHandle)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.ECDH_KeyGen, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(ECDH_KeyGenResponse)
    # ECDH_KeyGen()
    
    """
    This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ) [hds]QB; where h is the cofactor of the curve).
    Args:
        keyHandle handle of a loaded ECC key Auth Index: 1 Auth Role: USER 
        inPoint a public key 
    Returns:
        X and Y coordinates of the product of the multiplication Z = (xZ , yZ)  [hdS]QB
    """
    def ECDH_ZGen(self, keyHandle, inPoint):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.ECDH_ZGen, [keyHandle], 1)
        inStruct = TPM2_ECDH_ZGen_REQUEST(keyHandle,inPoint)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.ECDH_ZGen, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(ECDH_ZGenResponse)
            return res.outPoint
        else:
            return None
    # ECDH_ZGen()
    
    """
    This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
    Args:
        curveID parameter set selector 
    Returns:
        ECC parameters for the selected curve
    """
    def ECC_Parameters(self, curveID):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.ECC_Parameters, None, 0)
        inStruct = TPM2_ECC_Parameters_REQUEST(curveID)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.ECC_Parameters, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(ECC_ParametersResponse)
            return res.parameters
        else:
            return None
    # ECC_Parameters()
    
    """
    This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
    Args:
        keyA handle of an unrestricted decryption key ECC The private key referenced by this handle is used as dS,A Auth Index: 1 Auth Role: USER 
        inQsB other partys static public key (Qs,B = (Xs,B, Ys,B)) 
        inQeB other party's ephemeral public key (Qe,B = (Xe,B, Ye,B)) 
        inScheme the key exchange scheme 
        counter value returned by TPM2_EC_Ephemeral() 
    Returns:
        class ZGen_2PhaseResponse:
            outZ1 X and Y coordinates of the computed value (scheme dependent)
            outZ2 X and Y coordinates of the second computed value (scheme dependent)
    """
    def ZGen_2Phase(self, keyA, inQsB, inQeB, inScheme, counter):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.ZGen_2Phase, [keyA], 1)
        inStruct = TPM2_ZGen_2Phase_REQUEST(keyA,inQsB,inQeB,inScheme,counter)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.ZGen_2Phase, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(ZGen_2PhaseResponse)
    # ZGen_2Phase()
    
    """
    NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
    Args:
        keyHandle the symmetric key used for the operation Auth Index: 1 Auth Role: USER 
        decrypt if YES, then the operation is decryption; if NO, the operation is encryption 
        mode symmetric encryption/decryption mode this field shall match the default mode of the key or be TPM_ALG_NULL. 
        ivIn an initial value as required by the algorithm 
        inData the data to be encrypted/decrypted 
    Returns:
        class EncryptDecryptResponse:
            outData encrypted or decrypted output
            ivOut chaining value to use for IV in next round
    """
    def EncryptDecrypt(self, keyHandle, decrypt, mode, ivIn, inData):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.EncryptDecrypt, [keyHandle], 1)
        inStruct = TPM2_EncryptDecrypt_REQUEST(keyHandle,decrypt,mode,ivIn,inData)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.EncryptDecrypt, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(EncryptDecryptResponse)
    # EncryptDecrypt()
    
    """
    This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
    Args:
        keyHandle the symmetric key used for the operation Auth Index: 1 Auth Role: USER 
        inData the data to be encrypted/decrypted 
        decrypt if YES, then the operation is decryption; if NO, the operation is encryption 
        mode symmetric mode this field shall match the default mode of the key or be TPM_ALG_NULL. 
        ivIn an initial value as required by the algorithm 
    Returns:
        class EncryptDecrypt2Response:
            outData encrypted or decrypted output
            ivOut chaining value to use for IV in next round
    """
    def EncryptDecrypt2(self, keyHandle, inData, decrypt, mode, ivIn):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.EncryptDecrypt2, [keyHandle], 1)
        inStruct = TPM2_EncryptDecrypt2_REQUEST(keyHandle,inData,decrypt,mode,ivIn)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.EncryptDecrypt2, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(EncryptDecrypt2Response)
    # EncryptDecrypt2()
    
    """
    This command performs a hash operation on a data buffer and returns the results.
    Args:
        data data to be hashed 
        hashAlg algorithm for the hash being computed shall not be TPM_ALG_NULL 
        hierarchy hierarchy to use for the ticket (TPM_RH_NULL allowed) 
    Returns:
        class HashResponse:
            outHash results
            validation ticket indicating that the sequence of octets used to compute outDigest did not start with TPM_GENERATED_VALUE will be a NULL ticket if the digest may not be signed with a restricted key
    """
    def Hash(self, data, hashAlg, hierarchy):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.Hash, None, 0)
        inStruct = TPM2_Hash_REQUEST(data,hashAlg,hierarchy)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.Hash, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(HashResponse)
    # Hash()
    
    """
    This command performs an HMAC on the supplied data using the indicated hash algorithm.
    Args:
        handle handle for the symmetric signing key providing the HMAC key Auth Index: 1 Auth Role: USER 
        buffer HMAC data 
        hashAlg algorithm to use for HMAC 
    Returns:
        the returned HMAC in a sized buffer
    """
    def HMAC(self, handle, buffer, hashAlg):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.HMAC, [handle], 1)
        inStruct = TPM2_HMAC_REQUEST(handle,buffer,hashAlg)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.HMAC, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(HMACResponse)
            return res.outHMAC
        else:
            return None
    # HMAC()
    
    """
    This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
    Args:
        handle handle for the symmetric signing key providing the MAC key Auth Index: 1 Auth Role: USER 
        buffer MAC data 
        inScheme algorithm to use for MAC 
    Returns:
        the returned MAC in a sized buffer
    """
    def MAC(self, handle, buffer, inScheme):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.MAC, [handle], 1)
        inStruct = TPM2_MAC_REQUEST(handle,buffer,inScheme)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.MAC, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(MACResponse)
            return res.outMAC
        else:
            return None
    # MAC()
    
    """
    This command returns the next bytesRequested octets from the random number generator (RNG).
    Args:
        bytesRequested number of octets to return 
    Returns:
        the random octets
    """
    def GetRandom(self, bytesRequested):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.GetRandom, None, 0)
        inStruct = TPM2_GetRandom_REQUEST(bytesRequested)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.GetRandom, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(GetRandomResponse)
            return res.randomBytes
        else:
            return None
    # GetRandom()
    
    """
    This command is used to add "additional information" to the RNG state.
    Args:
        inData additional information
    """
    def StirRandom(self, inData):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.StirRandom, None, 0)
        inStruct = TPM2_StirRandom_REQUEST(inData)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.StirRandom, respBuf);
    # StirRandom()
    
    """
    This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
    Args:
        handle handle of an HMAC key Auth Index: 1 Auth Role: USER 
        auth authorization value for subsequent use of the sequence 
        hashAlg the hash algorithm to use for the HMAC 
    Returns:
        a handle to reference the sequence
    """
    def HMAC_Start(self, handle, auth, hashAlg):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.HMAC_Start, [handle], 1)
        inStruct = TPM2_HMAC_Start_REQUEST(handle,auth,hashAlg)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.HMAC_Start, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(HMAC_StartResponse)
            return res.handle
        else:
            return None
    # HMAC_Start()
    
    """
    This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
    Args:
        handle handle of a MAC key Auth Index: 1 Auth Role: USER 
        auth authorization value for subsequent use of the sequence 
        inScheme the algorithm to use for the MAC 
    Returns:
        a handle to reference the sequence
    """
    def MAC_Start(self, handle, auth, inScheme):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.MAC_Start, [handle], 1)
        inStruct = TPM2_MAC_Start_REQUEST(handle,auth,inScheme)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.MAC_Start, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(MAC_StartResponse)
            return res.handle
        else:
            return None
    # MAC_Start()
    
    """
    This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
    Args:
        auth authorization value for subsequent use of the sequence 
        hashAlg the hash algorithm to use for the hash sequence An Event Sequence starts if this is TPM_ALG_NULL. 
    Returns:
        a handle to reference the sequence
    """
    def HashSequenceStart(self, auth, hashAlg):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.HashSequenceStart, None, 0)
        inStruct = TPM2_HashSequenceStart_REQUEST(auth,hashAlg)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.HashSequenceStart, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(HashSequenceStartResponse)
            return res.handle
        else:
            return None
    # HashSequenceStart()
    
    """
    This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
    Args:
        sequenceHandle handle for the sequence object Auth Index: 1 Auth Role: USER 
        buffer data to be added to hash
    """
    def SequenceUpdate(self, sequenceHandle, buffer):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.SequenceUpdate, [sequenceHandle], 1)
        inStruct = TPM2_SequenceUpdate_REQUEST(sequenceHandle,buffer)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.SequenceUpdate, respBuf);
    # SequenceUpdate()
    
    """
    This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
    Args:
        sequenceHandle authorization for the sequence Auth Index: 1 Auth Role: USER 
        buffer data to be added to the hash/HMAC 
        hierarchy hierarchy of the ticket for a hash 
    Returns:
        class SequenceCompleteResponse:
            result the returned HMAC or digest in a sized buffer
            validation ticket indicating that the sequence of octets used to compute outDigest did not start with TPM_GENERATED_VALUE This is a NULL Ticket when the sequence is HMAC.
    """
    def SequenceComplete(self, sequenceHandle, buffer, hierarchy):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.SequenceComplete, [sequenceHandle], 1)
        inStruct = TPM2_SequenceComplete_REQUEST(sequenceHandle,buffer,hierarchy)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.SequenceComplete, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(SequenceCompleteResponse)
    # SequenceComplete()
    
    """
    This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
    Args:
        pcrHandle PCR to be extended with the Event data Auth Index: 1 Auth Role: USER 
        sequenceHandle authorization for the sequence Auth Index: 2 Auth Role: USER 
        buffer data to be added to the Event 
    Returns:
        list of digests computed for the PCR
    """
    def EventSequenceComplete(self, pcrHandle, sequenceHandle, buffer):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.EventSequenceComplete, [pcrHandle, sequenceHandle], 2)
        inStruct = TPM2_EventSequenceComplete_REQUEST(pcrHandle,sequenceHandle,buffer)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.EventSequenceComplete, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(EventSequenceCompleteResponse)
            return res.results
        else:
            return None
    # EventSequenceComplete()
    
    """
    The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
    Args:
        objectHandle handle of the object to be certified Auth Index: 1 Auth Role: ADMIN 
        signHandle handle of the key used to sign the attestation structure Auth Index: 2 Auth Role: USER 
        qualifyingData user provided qualifying data 
        inScheme signing scheme to use if the scheme for signHandle is TPM_ALG_NULL 
    Returns:
        class CertifyResponse:
            certifyInfo the structure that was signed
            signature the asymmetric signature over certifyInfo using the key referenced by signHandle
    """
    def Certify(self, objectHandle, signHandle, qualifyingData, inScheme):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.Certify, [objectHandle, signHandle], 2)
        inStruct = TPM2_Certify_REQUEST(objectHandle,signHandle,qualifyingData,inScheme)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.Certify, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(CertifyResponse)
    # Certify()
    
    """
    This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
    Args:
        signHandle handle of the key that will sign the attestation block Auth Index: 1 Auth Role: USER 
        objectHandle the object associated with the creation data Auth Index: None 
        qualifyingData user-provided qualifying data 
        creationHash hash of the creation data produced by TPM2_Create() or TPM2_CreatePrimary() 
        inScheme signing scheme to use if the scheme for signHandle is TPM_ALG_NULL 
        creationTicket ticket produced by TPM2_Create() or TPM2_CreatePrimary() 
    Returns:
        class CertifyCreationResponse:
            certifyInfo the structure that was signed
            signature the signature over certifyInfo
    """
    def CertifyCreation(self, signHandle, objectHandle, qualifyingData, creationHash, inScheme, creationTicket):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.CertifyCreation, [signHandle, objectHandle], 1)
        inStruct = TPM2_CertifyCreation_REQUEST(signHandle,objectHandle,qualifyingData,creationHash,inScheme,creationTicket)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.CertifyCreation, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(CertifyCreationResponse)
    # CertifyCreation()
    
    """
    This command is used to quote PCR values.
    Args:
        signHandle handle of key that will perform signature Auth Index: 1 Auth Role: USER 
        qualifyingData data supplied by the caller 
        inScheme signing scheme to use if the scheme for signHandle is TPM_ALG_NULL 
        PCRselect PCR set to quote 
    Returns:
        class QuoteResponse:
            quoted the quoted information
            signature the signature over quoted
    """
    def Quote(self, signHandle, qualifyingData, inScheme, PCRselect):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.Quote, [signHandle], 1)
        inStruct = TPM2_Quote_REQUEST(signHandle,qualifyingData,inScheme,PCRselect)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.Quote, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(QuoteResponse)
    # Quote()
    
    """
    This command returns a digital signature of the audit session digest.
    Args:
        privacyAdminHandle handle of the privacy administrator (TPM_RH_ENDORSEMENT) Auth Index: 1 Auth Role: USER 
        signHandle handle of the signing key Auth Index: 2 Auth Role: USER 
        sessionHandle handle of the audit session Auth Index: None 
        qualifyingData user-provided qualifying data may be zero-length 
        inScheme signing scheme to use if the scheme for signHandle is TPM_ALG_NULL 
    Returns:
        class GetSessionAuditDigestResponse:
            auditInfo the audit information that was signed
            signature the signature over auditInfo
    """
    def GetSessionAuditDigest(self, privacyAdminHandle, signHandle, sessionHandle, qualifyingData, inScheme):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.GetSessionAuditDigest, [privacyAdminHandle, signHandle, sessionHandle], 2)
        inStruct = TPM2_GetSessionAuditDigest_REQUEST(privacyAdminHandle,signHandle,sessionHandle,qualifyingData,inScheme)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.GetSessionAuditDigest, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(GetSessionAuditDigestResponse)
    # GetSessionAuditDigest()
    
    """
    This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
    Args:
        privacyHandle handle of the privacy administrator (TPM_RH_ENDORSEMENT) Auth Index: 1 Auth Role: USER 
        signHandle the handle of the signing key Auth Index: 2 Auth Role: USER 
        qualifyingData other data to associate with this audit digest 
        inScheme signing scheme to use if the scheme for signHandle is TPM_ALG_NULL 
    Returns:
        class GetCommandAuditDigestResponse:
            auditInfo the auditInfo that was signed
            signature the signature over auditInfo
    """
    def GetCommandAuditDigest(self, privacyHandle, signHandle, qualifyingData, inScheme):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.GetCommandAuditDigest, [privacyHandle, signHandle], 2)
        inStruct = TPM2_GetCommandAuditDigest_REQUEST(privacyHandle,signHandle,qualifyingData,inScheme)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.GetCommandAuditDigest, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(GetCommandAuditDigestResponse)
    # GetCommandAuditDigest()
    
    """
    This command returns the current values of Time and Clock.
    Args:
        privacyAdminHandle handle of the privacy administrator (TPM_RH_ENDORSEMENT) Auth Index: 1 Auth Role: USER 
        signHandle the keyHandle identifier of a loaded key that can perform digital signatures Auth Index: 2 Auth Role: USER 
        qualifyingData data to tick stamp 
        inScheme signing scheme to use if the scheme for signHandle is TPM_ALG_NULL 
    Returns:
        class GetTimeResponse:
            timeInfo standard TPM-generated attestation block
            signature the signature over timeInfo
    """
    def GetTime(self, privacyAdminHandle, signHandle, qualifyingData, inScheme):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.GetTime, [privacyAdminHandle, signHandle], 2)
        inStruct = TPM2_GetTime_REQUEST(privacyAdminHandle,signHandle,qualifyingData,inScheme)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.GetTime, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(GetTimeResponse)
    # GetTime()
    
    """
    TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
    Args:
        signHandle handle of the key that will be used in the signing operation Auth Index: 1 Auth Role: USER 
        P1 a point (M) on the curve used by signHandle 
        s2 octet array used to derive x-coordinate of a base point 
        y2 y coordinate of the point associated with s2 
    Returns:
        class CommitResponse:
            K ECC point K [ds](x2, y2)
            L ECC point L [r](x2, y2)
            E ECC point E [r]P1
            counter least-significant 16 bits of commitCount
    """
    def Commit(self, signHandle, P1, s2, y2):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.Commit, [signHandle], 1)
        inStruct = TPM2_Commit_REQUEST(signHandle,P1,s2,y2)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.Commit, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(CommitResponse)
    # Commit()
    
    """
    TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
    Args:
        curveID The curve for the computed ephemeral point 
    Returns:
        class EC_EphemeralResponse:
            Q ephemeral public key Q [r]G
            counter least-significant 16 bits of commitCount
    """
    def EC_Ephemeral(self, curveID):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.EC_Ephemeral, None, 0)
        inStruct = TPM2_EC_Ephemeral_REQUEST(curveID)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.EC_Ephemeral, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(EC_EphemeralResponse)
    # EC_Ephemeral()
    
    """
    This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
    Args:
        keyHandle handle of public key that will be used in the validation Auth Index: None 
        digest digest of the signed message 
        signature signature to be tested 
    Returns:
        This ticket is produced by TPM2_VerifySignature(). This formulation is used for multiple ticket uses. The ticket provides evidence that the TPM has validated that a digest was signed by a key with the Name of keyName. The ticket is computed by
    """
    def VerifySignature(self, keyHandle, digest, signature):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.VerifySignature, [keyHandle], 0)
        inStruct = TPM2_VerifySignature_REQUEST(keyHandle,digest,signature)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.VerifySignature, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(VerifySignatureResponse)
            return res.validation
        else:
            return None
    # VerifySignature()
    
    """
    This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
    Args:
        keyHandle Handle of key that will perform signing Auth Index: 1 Auth Role: USER 
        digest digest to be signed 
        inScheme signing scheme to use if the scheme for keyHandle is TPM_ALG_NULL 
        validation proof that digest was created by the TPM If keyHandle is not a restricted signing key, then this may be a NULL Ticket with tag = TPM_ST_CHECKHASH. 
    Returns:
        the signature
    """
    def Sign(self, keyHandle, digest, inScheme, validation):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.Sign, [keyHandle], 1)
        inStruct = TPM2_Sign_REQUEST(keyHandle,digest,inScheme,validation)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.Sign, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(SignResponse)
            return res.signature
        else:
            return None
    # Sign()
    
    """
    This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
    Args:
        auth TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER 
        auditAlg hash algorithm for the audit digest; if TPM_ALG_NULL, then the hash is not changed 
        setList list of commands that will be added to those that will be audited 
        clearList list of commands that will no longer be audited
    """
    def SetCommandCodeAuditStatus(self, auth, auditAlg, setList, clearList):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.SetCommandCodeAuditStatus, [auth], 1)
        inStruct = TPM2_SetCommandCodeAuditStatus_REQUEST(auth,auditAlg,setList,clearList)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.SetCommandCodeAuditStatus, respBuf);
    # SetCommandCodeAuditStatus()
    
    """
    This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
    Args:
        pcrHandle handle of the PCR Auth Handle: 1 Auth Role: USER 
        digests list of tagged digest values to be extended
    """
    def PCR_Extend(self, pcrHandle, digests):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PCR_Extend, [pcrHandle], 1)
        inStruct = TPM2_PCR_Extend_REQUEST(pcrHandle,digests)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PCR_Extend, respBuf);
    # PCR_Extend()
    
    """
    This command is used to cause an update to the indicated PCR.
    Args:
        pcrHandle Handle of the PCR Auth Handle: 1 Auth Role: USER 
        eventData Event data in sized buffer 
    Returns:
    """
    def PCR_Event(self, pcrHandle, eventData):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PCR_Event, [pcrHandle], 1)
        inStruct = TPM2_PCR_Event_REQUEST(pcrHandle,eventData)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PCR_Event, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(PCR_EventResponse)
            return res.digests
        else:
            return None
    # PCR_Event()
    
    """
    This command returns the values of all PCR specified in pcrSelectionIn.
    Args:
        pcrSelectionIn The selection of PCR to read 
    Returns:
        class PCR_ReadResponse:
            pcrUpdateCounter the current value of the PCR update counter
            pcrSelectionOut the PCR in the returned list
            pcrValues the contents of the PCR indicated in pcrSelectOut-) pcrSelection[] as tagged digests
    """
    def PCR_Read(self, pcrSelectionIn):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PCR_Read, None, 0)
        inStruct = TPM2_PCR_Read_REQUEST(pcrSelectionIn)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PCR_Read, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(PCR_ReadResponse)
    # PCR_Read()
    
    """
    This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
    Args:
        authHandle TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER 
        pcrAllocation the requested allocation 
    Returns:
        class PCR_AllocateResponse:
            allocationSuccess YES if the allocation succeeded
            maxPCR maximum number of PCR that may be in a bank
            sizeNeeded number of octets required to satisfy the request
            sizeAvailable Number of octets available. Computed before the allocation.
    """
    def PCR_Allocate(self, authHandle, pcrAllocation):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PCR_Allocate, [authHandle], 1)
        inStruct = TPM2_PCR_Allocate_REQUEST(authHandle,pcrAllocation)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PCR_Allocate, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(PCR_AllocateResponse)
    # PCR_Allocate()
    
    """
    This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
    Args:
        authHandle TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER 
        authPolicy the desired authPolicy 
        hashAlg the hash algorithm of the policy 
        pcrNum the PCR for which the policy is to be set
    """
    def PCR_SetAuthPolicy(self, authHandle, authPolicy, hashAlg, pcrNum):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PCR_SetAuthPolicy, [authHandle], 1)
        inStruct = TPM2_PCR_SetAuthPolicy_REQUEST(authHandle,authPolicy,hashAlg,pcrNum)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PCR_SetAuthPolicy, respBuf);
    # PCR_SetAuthPolicy()
    
    """
    This command changes the authValue of a PCR or group of PCR.
    Args:
        pcrHandle handle for a PCR that may have an authorization value set Auth Index: 1 Auth Role: USER 
        auth the desired authorization value
    """
    def PCR_SetAuthValue(self, pcrHandle, auth):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PCR_SetAuthValue, [pcrHandle], 1)
        inStruct = TPM2_PCR_SetAuthValue_REQUEST(pcrHandle,auth)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PCR_SetAuthValue, respBuf);
    # PCR_SetAuthValue()
    
    """
    If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
    Args:
        pcrHandle the PCR to reset Auth Index: 1 Auth Role: USER
    """
    def PCR_Reset(self, pcrHandle):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PCR_Reset, [pcrHandle], 1)
        inStruct = TPM2_PCR_Reset_REQUEST(pcrHandle)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PCR_Reset, respBuf);
    # PCR_Reset()
    
    """
    This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
    Args:
        authObject handle for a key that will validate the signature Auth Index: None 
        policySession handle for the policy session being extended Auth Index: None 
        nonceTPM the policy nonce for the session This can be the Empty Buffer. 
        cpHashA digest of the command parameters to which this authorization is limited This is not the cpHash for this command but the cpHash for the command to which this policy session will be applied. If it is not limited, the parameter will be the Empty Buffer. 
        policyRef a reference to a policy relating to the authorization may be the Empty Buffer Size is limited to be no larger than the nonce size supported on the TPM. 
        expiration time when authorization will expire, measured in seconds from the time that nonceTPM was generated If expiration is non-negative, a NULL Ticket is returned. See 23.2.5. 
        auth signed authorization (not optional) 
    Returns:
        class PolicySignedResponse:
            timeout implementation-specific time value, used to indicate to the TPM when the ticket expires NOTE If policyTicket is a NULL Ticket, then this shall be the Empty Buffer.
            policyTicket produced if the command succeeds and expiration in the command was non-zero; this ticket will use the TPMT_ST_AUTH_SIGNED structure tag. See 23.2.5
    """
    def PolicySigned(self, authObject, policySession, nonceTPM, cpHashA, policyRef, expiration, auth):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicySigned, [authObject, policySession], 0)
        inStruct = TPM2_PolicySigned_REQUEST(authObject,policySession,nonceTPM,cpHashA,policyRef,expiration,auth)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicySigned, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(PolicySignedResponse)
    # PolicySigned()
    
    """
    This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
    Args:
        authHandle handle for an entity providing the authorization Auth Index: 1 Auth Role: USER 
        policySession handle for the policy session being extended Auth Index: None 
        nonceTPM the policy nonce for the session This can be the Empty Buffer. 
        cpHashA digest of the command parameters to which this authorization is limited This not the cpHash for this command but the cpHash for the command to which this policy session will be applied. If it is not limited, the parameter will be the Empty Buffer. 
        policyRef a reference to a policy relating to the authorization may be the Empty Buffer Size is limited to be no larger than the nonce size supported on the TPM. 
        expiration time when authorization will expire, measured in seconds from the time that nonceTPM was generated If expiration is non-negative, a NULL Ticket is returned. See 23.2.5. 
    Returns:
        class PolicySecretResponse:
            timeout implementation-specific time value used to indicate to the TPM when the ticket expires
            policyTicket produced if the command succeeds and expiration in the command was non-zero ( See 23.2.5). This ticket will use the TPMT_ST_AUTH_SECRET structure tag
    """
    def PolicySecret(self, authHandle, policySession, nonceTPM, cpHashA, policyRef, expiration):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicySecret, [authHandle, policySession], 1)
        inStruct = TPM2_PolicySecret_REQUEST(authHandle,policySession,nonceTPM,cpHashA,policyRef,expiration)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicySecret, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(PolicySecretResponse)
    # PolicySecret()
    
    """
    This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
    Args:
        policySession handle for the policy session being extended Auth Index: None 
        timeout time when authorization will expire The contents are TPM specific. This shall be the value returned when ticket was produced. 
        cpHashA digest of the command parameters to which this authorization is limited If it is not limited, the parameter will be the Empty Buffer. 
        policyRef reference to a qualifier for the policy may be the Empty Buffer 
        authName name of the object that provided the authorization 
        ticket an authorization ticket returned by the TPM in response to a TPM2_PolicySigned() or TPM2_PolicySecret()
    """
    def PolicyTicket(self, policySession, timeout, cpHashA, policyRef, authName, ticket):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyTicket, [policySession], 0)
        inStruct = TPM2_PolicyTicket_REQUEST(policySession,timeout,cpHashA,policyRef,authName,ticket)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyTicket, respBuf);
    # PolicyTicket()
    
    """
    This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
    Args:
        policySession handle for the policy session being extended Auth Index: None 
        pHashList the list of hashes to check for a match
    """
    def PolicyOR(self, policySession, pHashList):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyOR, [policySession], 0)
        inStruct = TPM2_PolicyOR_REQUEST(policySession,pHashList)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyOR, respBuf);
    # PolicyOR()
    
    """
    This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
    Args:
        policySession handle for the policy session being extended Auth Index: None 
        pcrDigest expected digest value of the selected PCR using the hash algorithm of the session; may be zero length 
        pcrs the PCR to include in the check digest
    """
    def PolicyPCR(self, policySession, pcrDigest, pcrs):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyPCR, [policySession], 0)
        inStruct = TPM2_PolicyPCR_REQUEST(policySession,pcrDigest,pcrs)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyPCR, respBuf);
    # PolicyPCR()
    
    """
    This command indicates that the authorization will be limited to a specific locality.
    Args:
        policySession handle for the policy session being extended Auth Index: None 
        locality the allowed localities for the policy
    """
    def PolicyLocality(self, policySession, locality):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyLocality, [policySession], 0)
        inStruct = TPM2_PolicyLocality_REQUEST(policySession,locality)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyLocality, respBuf);
    # PolicyLocality()
    
    """
    This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
    Args:
        authHandle handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
        nvIndex the NV Index of the area to read Auth Index: None 
        policySession handle for the policy session being extended Auth Index: None 
        operandB the second operand 
        offset the octet offset in the NV Index for the start of operand A 
        operation the comparison to make
    """
    def PolicyNV(self, authHandle, nvIndex, policySession, operandB, offset, operation):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyNV, [authHandle, nvIndex, policySession], 1)
        inStruct = TPM2_PolicyNV_REQUEST(authHandle,nvIndex,policySession,operandB,offset,operation)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyNV, respBuf);
    # PolicyNV()
    
    """
    This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
    Args:
        policySession handle for the policy session being extended Auth Index: None 
        operandB the second operand 
        offset the octet offset in the TPMS_TIME_INFO structure for the start of operand A 
        operation the comparison to make
    """
    def PolicyCounterTimer(self, policySession, operandB, offset, operation):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyCounterTimer, [policySession], 0)
        inStruct = TPM2_PolicyCounterTimer_REQUEST(policySession,operandB,offset,operation)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyCounterTimer, respBuf);
    # PolicyCounterTimer()
    
    """
    This command indicates that the authorization will be limited to a specific command code.
    Args:
        policySession handle for the policy session being extended Auth Index: None 
        code the allowed commandCode
    """
    def PolicyCommandCode(self, policySession, code):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyCommandCode, [policySession], 0)
        inStruct = TPM2_PolicyCommandCode_REQUEST(policySession,code)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyCommandCode, respBuf);
    # PolicyCommandCode()
    
    """
    This command indicates that physical presence will need to be asserted at the time the authorization is performed.
    Args:
        policySession handle for the policy session being extended Auth Index: None
    """
    def PolicyPhysicalPresence(self, policySession):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyPhysicalPresence, [policySession], 0)
        inStruct = TPM2_PolicyPhysicalPresence_REQUEST(policySession)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyPhysicalPresence, respBuf);
    # PolicyPhysicalPresence()
    
    """
    This command is used to allow a policy to be bound to a specific command and command parameters.
    Args:
        policySession handle for the policy session being extended Auth Index: None 
        cpHashA the cpHash added to the policy
    """
    def PolicyCpHash(self, policySession, cpHashA):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyCpHash, [policySession], 0)
        inStruct = TPM2_PolicyCpHash_REQUEST(policySession,cpHashA)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyCpHash, respBuf);
    # PolicyCpHash()
    
    """
    This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
    Args:
        policySession handle for the policy session being extended Auth Index: None 
        nameHash the digest to be added to the policy
    """
    def PolicyNameHash(self, policySession, nameHash):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyNameHash, [policySession], 0)
        inStruct = TPM2_PolicyNameHash_REQUEST(policySession,nameHash)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyNameHash, respBuf);
    # PolicyNameHash()
    
    """
    This command allows qualification of duplication to allow duplication to a selected new parent.
    Args:
        policySession handle for the policy session being extended Auth Index: None 
        objectName the Name of the object to be duplicated 
        newParentName the Name of the new parent 
        includeObject if YES, the objectName will be included in the value in policySessionpolicyDigest
    """
    def PolicyDuplicationSelect(self, policySession, objectName, newParentName, includeObject):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyDuplicationSelect, [policySession], 0)
        inStruct = TPM2_PolicyDuplicationSelect_REQUEST(policySession,objectName,newParentName,includeObject)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyDuplicationSelect, respBuf);
    # PolicyDuplicationSelect()
    
    """
    This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
    Args:
        policySession handle for the policy session being extended Auth Index: None 
        approvedPolicy digest of the policy being approved 
        policyRef a policy qualifier 
        keySign Name of a key that can sign a policy addition 
        checkTicket ticket validating that approvedPolicy and policyRef were signed by keySign
    """
    def PolicyAuthorize(self, policySession, approvedPolicy, policyRef, keySign, checkTicket):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyAuthorize, [policySession], 0)
        inStruct = TPM2_PolicyAuthorize_REQUEST(policySession,approvedPolicy,policyRef,keySign,checkTicket)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyAuthorize, respBuf);
    # PolicyAuthorize()
    
    """
    This command allows a policy to be bound to the authorization value of the authorized entity.
    Args:
        policySession handle for the policy session being extended Auth Index: None
    """
    def PolicyAuthValue(self, policySession):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyAuthValue, [policySession], 0)
        inStruct = TPM2_PolicyAuthValue_REQUEST(policySession)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyAuthValue, respBuf);
    # PolicyAuthValue()
    
    """
    This command allows a policy to be bound to the authorization value of the authorized object.
    Args:
        policySession handle for the policy session being extended Auth Index: None
    """
    def PolicyPassword(self, policySession):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyPassword, [policySession], 0)
        inStruct = TPM2_PolicyPassword_REQUEST(policySession)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyPassword, respBuf);
    # PolicyPassword()
    
    """
    This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
    Args:
        policySession handle for the policy session Auth Index: None 
    Returns:
        the current value of the policySessionpolicyDigest
    """
    def PolicyGetDigest(self, policySession):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyGetDigest, [policySession], 0)
        inStruct = TPM2_PolicyGetDigest_REQUEST(policySession)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyGetDigest, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(PolicyGetDigestResponse)
            return res.policyDigest
        else:
            return None
    # PolicyGetDigest()
    
    """
    This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
    Args:
        policySession handle for the policy session being extended Auth Index: None 
        writtenSet YES if NV Index is required to have been written NO if NV Index is required not to have been written
    """
    def PolicyNvWritten(self, policySession, writtenSet):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyNvWritten, [policySession], 0)
        inStruct = TPM2_PolicyNvWritten_REQUEST(policySession,writtenSet)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyNvWritten, respBuf);
    # PolicyNvWritten()
    
    """
    This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
    Args:
        policySession handle for the policy session being extended Auth Index: None 
        templateHash the digest to be added to the policy
    """
    def PolicyTemplate(self, policySession, templateHash):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyTemplate, [policySession], 0)
        inStruct = TPM2_PolicyTemplate_REQUEST(policySession,templateHash)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyTemplate, respBuf);
    # PolicyTemplate()
    
    """
    This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
    Args:
        authHandle handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
        nvIndex the NV Index of the area to read Auth Index: None 
        policySession handle for the policy session being extended Auth Index: None
    """
    def PolicyAuthorizeNV(self, authHandle, nvIndex, policySession):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PolicyAuthorizeNV, [authHandle, nvIndex, policySession], 1)
        inStruct = TPM2_PolicyAuthorizeNV_REQUEST(authHandle,nvIndex,policySession)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PolicyAuthorizeNV, respBuf);
    # PolicyAuthorizeNV()
    
    """
    This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
    Args:
        primaryHandle TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL Auth Index: 1 Auth Role: USER 
        inSensitive the sensitive data, see TPM 2.0 Part 1 Sensitive Values 
        inPublic the public template 
        outsideInfo data that will be included in the creation data for this object to provide permanent, verifiable linkage between this object and some object owner data 
        creationPCR PCR that will be used in creation data 
    Returns:
        class CreatePrimaryResponse:
            handle handle of type TPM_HT_TRANSIENT for created Primary Object
            outPublic the public portion of the created object
            creationData contains a TPMT_CREATION_DATA
            creationHash digest of creationData using nameAlg of outPublic
            creationTicket ticket used by TPM2_CertifyCreation() to validate that the creation data was produced by the TPM
            name the name of the created object
    """
    def CreatePrimary(self, primaryHandle, inSensitive, inPublic, outsideInfo, creationPCR):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.CreatePrimary, [primaryHandle], 1)
        inStruct = TPM2_CreatePrimary_REQUEST(primaryHandle,inSensitive,inPublic,outsideInfo,creationPCR)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.CreatePrimary, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(CreatePrimaryResponse)
        else:
            print("[Tpm] CreatePrimary failed");
            return None;

    # CreatePrimary()
    
    """
    This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
    Args:
        authHandle TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER 
        enable the enable being modified TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM, or TPM_RH_PLATFORM_NV 
        state YES if the enable should be SET, NO if the enable should be CLEAR
    """
    def HierarchyControl(self, authHandle, enable, state):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.HierarchyControl, [authHandle], 1)
        inStruct = TPM2_HierarchyControl_REQUEST(authHandle,enable,state)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.HierarchyControl, respBuf);
    # HierarchyControl()
    
    """
    This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
    Args:
        authHandle TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER 
        authPolicy an authorization policy digest; may be the Empty Buffer If hashAlg is TPM_ALG_NULL, then this shall be an Empty Buffer. 
        hashAlg the hash algorithm to use for the policy If the authPolicy is an Empty Buffer, then this field shall be TPM_ALG_NULL.
    """
    def SetPrimaryPolicy(self, authHandle, authPolicy, hashAlg):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.SetPrimaryPolicy, [authHandle], 1)
        inStruct = TPM2_SetPrimaryPolicy_REQUEST(authHandle,authPolicy,hashAlg)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.SetPrimaryPolicy, respBuf);
    # SetPrimaryPolicy()
    
    """
    This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
    Args:
        authHandle TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
    """
    def ChangePPS(self, authHandle):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.ChangePPS, [authHandle], 1)
        inStruct = TPM2_ChangePPS_REQUEST(authHandle)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.ChangePPS, respBuf);
    # ChangePPS()
    
    """
    This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
    Args:
        authHandle TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER
    """
    def ChangeEPS(self, authHandle):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.ChangeEPS, [authHandle], 1)
        inStruct = TPM2_ChangeEPS_REQUEST(authHandle)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.ChangeEPS, respBuf);
    # ChangeEPS()
    
    """
    This command removes all TPM context associated with a specific Owner.
    Args:
        authHandle TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER
    """
    def Clear(self, authHandle):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.Clear, [authHandle], 1)
        inStruct = TPM2_Clear_REQUEST(authHandle)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.Clear, respBuf);
    # Clear()
    
    """
    TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
    Args:
        auth TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER 
        disable YES if the disableOwnerClear flag is to be SET, NO if the flag is to be CLEAR.
    """
    def ClearControl(self, auth, disable):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.ClearControl, [auth], 1)
        inStruct = TPM2_ClearControl_REQUEST(auth,disable)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.ClearControl, respBuf);
    # ClearControl()
    
    """
    This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
    Args:
        authHandle TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER 
        newAuth new authorization value
    """
    def HierarchyChangeAuth(self, authHandle, newAuth):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.HierarchyChangeAuth, [authHandle], 1)
        inStruct = TPM2_HierarchyChangeAuth_REQUEST(authHandle,newAuth)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.HierarchyChangeAuth, respBuf);
    # HierarchyChangeAuth()
    
    """
    This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
    Args:
        lockHandle TPM_RH_LOCKOUT Auth Index: 1 Auth Role: USER
    """
    def DictionaryAttackLockReset(self, lockHandle):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.DictionaryAttackLockReset, [lockHandle], 1)
        inStruct = TPM2_DictionaryAttackLockReset_REQUEST(lockHandle)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.DictionaryAttackLockReset, respBuf);
    # DictionaryAttackLockReset()
    
    """
    This command changes the lockout parameters.
    Args:
        lockHandle TPM_RH_LOCKOUT Auth Index: 1 Auth Role: USER 
        newMaxTries count of authorization failures before the lockout is imposed 
        newRecoveryTime time in seconds before the authorization failure count is automatically decremented A value of zero indicates that DA protection is disabled. 
        lockoutRecovery time in seconds after a lockoutAuth failure before use of lockoutAuth is allowed A value of zero indicates that a reboot is required.
    """
    def DictionaryAttackParameters(self, lockHandle, newMaxTries, newRecoveryTime, lockoutRecovery):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.DictionaryAttackParameters, [lockHandle], 1)
        inStruct = TPM2_DictionaryAttackParameters_REQUEST(lockHandle,newMaxTries,newRecoveryTime,lockoutRecovery)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.DictionaryAttackParameters, respBuf);
    # DictionaryAttackParameters()
    
    """
    This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
    Args:
        auth TPM_RH_PLATFORM+PP Auth Index: 1 Auth Role: USER + Physical Presence 
        setList list of commands to be added to those that will require that Physical Presence be asserted 
        clearList list of commands that will no longer require that Physical Presence be asserted
    """
    def PP_Commands(self, auth, setList, clearList):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.PP_Commands, [auth], 1)
        inStruct = TPM2_PP_Commands_REQUEST(auth,setList,clearList)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.PP_Commands, respBuf);
    # PP_Commands()
    
    """
    This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
    Args:
        authHandle TPM_RH_PLATFORM Auth Index: 1 Auth Role: USER 
        algorithmSet a TPM vendor-dependent value indicating the algorithm set selection
    """
    def SetAlgorithmSet(self, authHandle, algorithmSet):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.SetAlgorithmSet, [authHandle], 1)
        inStruct = TPM2_SetAlgorithmSet_REQUEST(authHandle,algorithmSet)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.SetAlgorithmSet, respBuf);
    # SetAlgorithmSet()
    
    """
    This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
    Args:
        authorization TPM_RH_PLATFORM+{PP} Auth Index:1 Auth Role: ADMIN 
        keyHandle handle of a public area that contains the TPM Vendor Authorization Key that will be used to validate manifestSignature Auth Index: None 
        fuDigest digest of the first block in the field upgrade sequence 
        manifestSignature signature over fuDigest using the key associated with keyHandle (not optional)
    """
    def FieldUpgradeStart(self, authorization, keyHandle, fuDigest, manifestSignature):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.FieldUpgradeStart, [authorization, keyHandle], 1)
        inStruct = TPM2_FieldUpgradeStart_REQUEST(authorization,keyHandle,fuDigest,manifestSignature)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.FieldUpgradeStart, respBuf);
    # FieldUpgradeStart()
    
    """
    This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
    Args:
        fuData field upgrade image data 
    Returns:
        class FieldUpgradeDataResponse:
            nextDigest tagged digest of the next block TPM_ALG_NULL if field update is complete
            firstDigest tagged digest of the first block of the sequence
    """
    def FieldUpgradeData(self, fuData):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.FieldUpgradeData, None, 0)
        inStruct = TPM2_FieldUpgradeData_REQUEST(fuData)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.FieldUpgradeData, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(FieldUpgradeDataResponse)
    # FieldUpgradeData()
    
    """
    This command is used to read a copy of the current firmware installed in the TPM.
    Args:
        sequenceNumber the number of previous calls to this command in this sequence set to 0 on the first call 
    Returns:
        field upgrade image data
    """
    def FirmwareRead(self, sequenceNumber):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.FirmwareRead, None, 0)
        inStruct = TPM2_FirmwareRead_REQUEST(sequenceNumber)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.FirmwareRead, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(FirmwareReadResponse)
            return res.fuData
        else:
            return None
    # FirmwareRead()
    
    """
    This command saves a session context, object context, or sequence object context outside the TPM.
    Args:
        saveHandle handle of the resource to save Auth Index: None 
    Returns:
        This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when the context was saved (TPM2_ContextSave()), then the TPM shall not load the context.
    """
    def ContextSave(self, saveHandle):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.ContextSave, [saveHandle], 0)
        inStruct = TPM2_ContextSave_REQUEST(saveHandle)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.ContextSave, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(ContextSaveResponse)
            return res.context
        else:
            return None
    # ContextSave()
    
    """
    This command is used to reload a context that has been saved by TPM2_ContextSave().
    Args:
        context the context blob 
    Returns:
        the handle assigned to the resource after it has been successfully loaded
    """
    def ContextLoad(self, context):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.ContextLoad, None, 0)
        inStruct = TPM2_ContextLoad_REQUEST(context)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.ContextLoad, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(ContextLoadResponse)
            return res.handle
        else:
            return None
    # ContextLoad()
    
    """
    This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
    Args:
        flushHandle the handle of the item to flush NOTE This is a use of a handle as a parameter.
    """
    def FlushContext(self, flushHandle):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.FlushContext, None, 0)
        inStruct = TPM2_FlushContext_REQUEST(flushHandle)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.FlushContext, respBuf);
    # FlushContext()
    
    """
    This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
    Args:
        auth TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER 
        objectHandle the handle of a loaded object Auth Index: None 
        persistentHandle if objectHandle is a transient object handle, then this is the persistent handle for the object if objectHandle is a persistent object handle, then it shall be the same value as persistentHandle
    """
    def EvictControl(self, auth, objectHandle, persistentHandle):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.EvictControl, [auth, objectHandle], 1)
        inStruct = TPM2_EvictControl_REQUEST(auth,objectHandle,persistentHandle)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.EvictControl, respBuf);
    # EvictControl()
    
    """
    This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
    Args:
    Returns:
        This structure is used in the TPM2_GetTime() attestation.
    """
    def ReadClock(self):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.ReadClock, None, 0)
        inStruct = TPM2_ReadClock_REQUEST()
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.ReadClock, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(ReadClockResponse)
            return res.currentTime
        else:
            return None
    # ReadClock()
    
    """
    This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
    Args:
        auth TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER 
        newTime new Clock setting in milliseconds
    """
    def ClockSet(self, auth, newTime):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.ClockSet, [auth], 1)
        inStruct = TPM2_ClockSet_REQUEST(auth,newTime)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.ClockSet, respBuf);
    # ClockSet()
    
    """
    This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
    Args:
        auth TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER 
        rateAdjust Adjustment to current Clock update rate
    """
    def ClockRateAdjust(self, auth, rateAdjust):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.ClockRateAdjust, [auth], 1)
        inStruct = TPM2_ClockRateAdjust_REQUEST(auth,rateAdjust)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.ClockRateAdjust, respBuf);
    # ClockRateAdjust()
    
    """
    This command returns various information regarding the TPM and its current state.
    Args:
        capability group selection; determines the format of the response 
        property further definition of information 
        propertyCount number of properties of the indicated type to return 
    Returns:
        class GetCapabilityResponse:
            moreData flag to indicate if there are more values of this type
            capabilityData the capability data
    """
    def GetCapability(self, capability, property, propertyCount):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.GetCapability, None, 0)
        inStruct = TPM2_GetCapability_REQUEST(capability,property,propertyCount)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.GetCapability, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(GetCapabilityResponse)
    # GetCapability()
    
    """
    This command is used to check to see if specific combinations of algorithm parameters are supported.
    Args:
        parameters algorithm parameters to be validated
    """
    def TestParms(self, parameters):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.TestParms, None, 0)
        inStruct = TPM2_TestParms_REQUEST(parameters)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.TestParms, respBuf);
    # TestParms()
    
    """
    This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
    Args:
        authHandle TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER 
        auth the authorization value 
        publicInfo the public parameters of the NV area
    """
    def NV_DefineSpace(self, authHandle, auth, publicInfo):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.NV_DefineSpace, [authHandle], 1)
        inStruct = TPM2_NV_DefineSpace_REQUEST(authHandle,auth,publicInfo)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.NV_DefineSpace, respBuf);
    # NV_DefineSpace()
    
    """
    This command removes an Index from the TPM.
    Args:
        authHandle TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER 
        nvIndex the NV Index to remove from NV space Auth Index: None
    """
    def NV_UndefineSpace(self, authHandle, nvIndex):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.NV_UndefineSpace, [authHandle, nvIndex], 1)
        inStruct = TPM2_NV_UndefineSpace_REQUEST(authHandle,nvIndex)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.NV_UndefineSpace, respBuf);
    # NV_UndefineSpace()
    
    """
    This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
    Args:
        nvIndex Index to be deleted Auth Index: 1 Auth Role: ADMIN 
        platform TPM_RH_PLATFORM + {PP} Auth Index: 2 Auth Role: USER
    """
    def NV_UndefineSpaceSpecial(self, nvIndex, platform):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.NV_UndefineSpaceSpecial, [nvIndex, platform], 2)
        inStruct = TPM2_NV_UndefineSpaceSpecial_REQUEST(nvIndex,platform)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.NV_UndefineSpaceSpecial, respBuf);
    # NV_UndefineSpaceSpecial()
    
    """
    This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
    Args:
        nvIndex the NV Index Auth Index: None 
    Returns:
        class NV_ReadPublicResponse:
            nvPublic the public area of the NV Index
            nvName the Name of the nvIndex
    """
    def NV_ReadPublic(self, nvIndex):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.NV_ReadPublic, [nvIndex], 0)
        inStruct = TPM2_NV_ReadPublic_REQUEST(nvIndex)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.NV_ReadPublic, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(NV_ReadPublicResponse)
    # NV_ReadPublic()
    
    """
    This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
    Args:
        authHandle handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
        nvIndex the NV Index of the area to write Auth Index: None 
        data the data to write 
        offset the octet offset into the NV Area
    """
    def NV_Write(self, authHandle, nvIndex, data, offset):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.NV_Write, [authHandle, nvIndex], 1)
        inStruct = TPM2_NV_Write_REQUEST(authHandle,nvIndex,data,offset)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.NV_Write, respBuf);
    # NV_Write()
    
    """
    This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
    Args:
        authHandle handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
        nvIndex the NV Index to increment Auth Index: None
    """
    def NV_Increment(self, authHandle, nvIndex):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.NV_Increment, [authHandle, nvIndex], 1)
        inStruct = TPM2_NV_Increment_REQUEST(authHandle,nvIndex)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.NV_Increment, respBuf);
    # NV_Increment()
    
    """
    This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
    Args:
        authHandle handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
        nvIndex the NV Index to extend Auth Index: None 
        data the data to extend
    """
    def NV_Extend(self, authHandle, nvIndex, data):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.NV_Extend, [authHandle, nvIndex], 1)
        inStruct = TPM2_NV_Extend_REQUEST(authHandle,nvIndex,data)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.NV_Extend, respBuf);
    # NV_Extend()
    
    """
    This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
    Args:
        authHandle handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
        nvIndex NV Index of the area in which the bit is to be set Auth Index: None 
        bits the data to OR with the current contents
    """
    def NV_SetBits(self, authHandle, nvIndex, bits):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.NV_SetBits, [authHandle, nvIndex], 1)
        inStruct = TPM2_NV_SetBits_REQUEST(authHandle,nvIndex,bits)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.NV_SetBits, respBuf);
    # NV_SetBits()
    
    """
    If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
    Args:
        authHandle handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
        nvIndex the NV Index of the area to lock Auth Index: None
    """
    def NV_WriteLock(self, authHandle, nvIndex):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.NV_WriteLock, [authHandle, nvIndex], 1)
        inStruct = TPM2_NV_WriteLock_REQUEST(authHandle,nvIndex)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.NV_WriteLock, respBuf);
    # NV_WriteLock()
    
    """
    The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
    Args:
        authHandle TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
    """
    def NV_GlobalWriteLock(self, authHandle):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.NV_GlobalWriteLock, [authHandle], 1)
        inStruct = TPM2_NV_GlobalWriteLock_REQUEST(authHandle)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.NV_GlobalWriteLock, respBuf);
    # NV_GlobalWriteLock()
    
    """
    This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
    Args:
        authHandle the handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
        nvIndex the NV Index to be read Auth Index: None 
        size number of octets to read 
        offset octet offset into the NV area This value shall be less than or equal to the size of the nvIndex data. 
    Returns:
        the data read
    """
    def NV_Read(self, authHandle, nvIndex, size, offset):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.NV_Read, [authHandle, nvIndex], 1)
        inStruct = TPM2_NV_Read_REQUEST(authHandle,nvIndex,size,offset)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.NV_Read, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(NV_ReadResponse)
            return res.data
        else:
            return None
    # NV_Read()
    
    """
    If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
    Args:
        authHandle the handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
        nvIndex the NV Index to be locked Auth Index: None
    """
    def NV_ReadLock(self, authHandle, nvIndex):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.NV_ReadLock, [authHandle, nvIndex], 1)
        inStruct = TPM2_NV_ReadLock_REQUEST(authHandle,nvIndex)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.NV_ReadLock, respBuf);
    # NV_ReadLock()
    
    """
    This command allows the authorization secret for an NV Index to be changed.
    Args:
        nvIndex handle of the entity Auth Index: 1 Auth Role: ADMIN 
        newAuth new authorization value
    """
    def NV_ChangeAuth(self, nvIndex, newAuth):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.NV_ChangeAuth, [nvIndex], 1)
        inStruct = TPM2_NV_ChangeAuth_REQUEST(nvIndex,newAuth)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.NV_ChangeAuth, respBuf);
    # NV_ChangeAuth()
    
    """
    The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
    Args:
        signHandle handle of the key used to sign the attestation structure Auth Index: 1 Auth Role: USER 
        authHandle handle indicating the source of the authorization value for the NV Index Auth Index: 2 Auth Role: USER 
        nvIndex Index for the area to be certified Auth Index: None 
        qualifyingData user-provided qualifying data 
        inScheme signing scheme to use if the scheme for signHandle is TPM_ALG_NULL 
        size number of octets to certify 
        offset octet offset into the NV area This value shall be less than or equal to the size of the nvIndex data. 
    Returns:
        class NV_CertifyResponse:
            certifyInfo the structure that was signed
            signature the asymmetric signature over certifyInfo using the key referenced by signHandle
    """
    def NV_Certify(self, signHandle, authHandle, nvIndex, qualifyingData, inScheme, size, offset):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.NV_Certify, [signHandle, authHandle, nvIndex], 2)
        inStruct = TPM2_NV_Certify_REQUEST(signHandle,authHandle,nvIndex,qualifyingData,inScheme,size,offset)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.NV_Certify, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(NV_CertifyResponse)
    # NV_Certify()
    
    """
    The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
    Args:
        ac handle indicating the Attached Component Auth Index: None 
        capability starting info type 
        count maximum number of values to return 
    Returns:
        class AC_GetCapabilityResponse:
            moreData flag to indicate whether there are more values
            capabilitiesData list of capabilities
    """
    def AC_GetCapability(self, ac, capability, count):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.AC_GetCapability, [ac], 0)
        inStruct = TPM2_AC_GetCapability_REQUEST(ac,capability,count)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.AC_GetCapability, respBuf);
        if not self.lastError:
            return respBuf.createFromTpm(AC_GetCapabilityResponse)
    # AC_GetCapability()
    
    """
    The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
    Args:
        sendObject handle of the object being sent to ac Auth Index: 1 Auth Role: DUP 
        authHandle the handle indicating the source of the authorization value Auth Index: 2 Auth Role: USER 
        ac handle indicating the Attached Component to which the object will be sent Auth Index: None 
        acDataIn Optional non sensitive information related to the object 
    Returns:
        May include AC specific data or information about an error.
    """
    def AC_Send(self, sendObject, authHandle, ac, acDataIn):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.AC_Send, [sendObject, authHandle, ac], 2)
        inStruct = TPM2_AC_Send_REQUEST(sendObject,authHandle,ac,acDataIn)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.AC_Send, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(AC_SendResponse)
            return res.acDataOut
        else:
            return None
    # AC_Send()
    
    """
    This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
    Args:
        policySession handle for the policy session being extended Auth Index: None 
        objectName the Name of the Object to be sent 
        authHandleName the Name associated with authHandle used in the TPM2_AC_Send() command 
        acName the Name of the Attached Component to which the Object will be sent 
        includeObject if SET, objectName will be included in the value in policySessionpolicyDigest
    """
    def Policy_AC_SendSelect(self, policySession, objectName, authHandleName, acName, includeObject):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.Policy_AC_SendSelect, [policySession], 0)
        inStruct = TPM2_Policy_AC_SendSelect_REQUEST(policySession,objectName,authHandleName,acName,includeObject)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.Policy_AC_SendSelect, respBuf);
    # Policy_AC_SendSelect()
    
    """
    This is a placeholder to allow testing of the dispatch code.
    Args:
        inputData dummy data 
    Returns:
        dummy data
    """
    def Vendor_TCG_Test(self, inputData):
        cmdBuf = super(Tpm, self).prepareCmdBuf(TPM_CC.Vendor_TCG_Test, None, 0)
        inStruct = TPM2_Vendor_TCG_Test_REQUEST(inputData)
        inStruct.toTpm(cmdBuf)
        respBuf = self.dispatchCommand(cmdBuf)
        if not self.lastError:
            self.processResponse(TPM_CC.Vendor_TCG_Test, respBuf);
        if not self.lastError:
            res = respBuf.createFromTpm(Vendor_TCG_TestResponse)
            return res.outputData
        else:
            return None
    # Vendor_TCG_Test()
    
# class Tpm
